name: InfraCI - ByoVnet cluster
# Credential prerequisites
# 1. IAM Owner on the Resource Group you're deploying into (we're making role assignments)
# 2. IAM Owner on the Vnet (we're making role assignments)

on:
  push:
    paths:
      #- ".github/workflows/ByoVnetCI.yml"
      - ".github/workflows_dep/AksDeploy-ByoVnet.parameters.json"
      - "bicep/*"

  pull_request:
    branches: [main]
    paths:
      - "bicep/*"
      - ".github/workflows/ByoVnetCI.yml"

  #Running on a schedule helps trap issues like Kubernetes versions not being available in the region, or Well Architected recommendations changing
  schedule:
    # At 11:00pm, every Wednesday week
    - cron: "0 23 * * 3"

  workflow_dispatch:
    inputs:
      minihelmbranch:
        description: 'Branch name to use from MiniHelm repo'  
        default: 'main'
      doWellArchitected:
        description: 'Perform the Well Architected Framework assessment  [yes|no]'  
        default: 'no'
      doDebugSteps:
        description: 'Run informational steps [yes|no]'  
        default: 'yes'
      doVerifySteps:
        description: 'Run optional verify steps [yes|no]'  
        default: 'yes'
      doSmokeTestUninstall:
        description: 'Uninstall smoke test apps after tests  [yes|no]'  
        default: 'yes'
        
concurrency: ci-${{ github.ref }}

env:
  AZCLIVERSION: 2.30.0 #2.29.2 #2.26.0 #latest
  RG: "Automation-Actions-AksDeployCI"
  ParamFilePath: ".github/workflows_dep/AksDeploy-ByoVnet.parameters.json"
  RESNAME: "Byo"
  DEPNAME: "Dep${{ github.run_number }}"

jobs:
  Well_Architected:
    runs-on: ubuntu-latest
    if:  github.event_name == 'pull_request' || github.event.inputs.doWellArchitected != 'no'
    steps:
      - uses: actions/checkout@v2
      
      # PSRule does this cool thing where it traverse the parameter file through to the arm template
      # PSRule performs IaC recommendations of the template.
      # https://azure.github.io/PSRule.Rules.Azure/
      - name: PSRule - Analyze Azure parameter file
        uses: Microsoft/ps-rule@main
        continue-on-error: true #Setting this whilst PSRule gets bedded in, in this project
        with:
          modules: 'PSRule.Rules.Azure' 
          inputPath: "${{ env.ParamFilePath }}"
          prerelease: true
        
  #Pre deployment validation of the parameters + bicep code
  Validation:
    runs-on: ubuntu-latest
    environment: azurecirgs

    steps:
      - uses: actions/checkout@v2

      - name: Job parameter check
        if: github.event.inputs.doDebugSteps != 'no'
        run: |       
          RG='${{ env.RG }}'
          echo "RG is: $RG"

          echo "Param file path is: ${{ env.ParamFilePath }}"
          echo "Resource name is ${{ env.RESNAME }}"
          echo "Deployment name is ${{ env.DEPNAME }}"
          echo "Ref is ${{ github.ref }}"
          echo "EventTrigger name is ${{github.event_name}}"
          echo "PR contains bug :  ${{contains(github.event.pull_request.labels.*.name, 'bug')}}"
          echo "PR labels :  ${{github.event.pull_request.labels.*.name}}"
          echo "AZCLIVERSION is ${{ env.AZCLIVERSION }}"
          echo "doDebugSteps is ${{ github.event.inputs.doDebugSteps }}"
          echo "doVerifySteps is ${{ github.event.inputs.doVerifySteps }}"
          echo "doSmokeTestUninstall is ${{ github.event.inputs.doSmokeTestUninstall }}"

      - name: Arm Parameter file check
        if: github.event.inputs.doVerifySteps != 'no'
        shell: pwsh
        run: |
          Write-Output "Checking parameter file existence/contents"
          $paramFilePath="${{ env.ParamFilePath }}"
          Test-Path $paramFilePath

          if (Test-Path $paramFilePath) {
            $paramFileContent=Get-Content $paramFilePath
            Write-Output $paramFileContent
            
            Write-Output "Test Pulling a param (ingressApplicationGateway)"
            $params=$paramFileContent|ConvertFrom-Json
            Write-Output $params.parameters.ingressApplicationGateway.value
          }

      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false

      - name: Install Pwsh modules
        shell: pwsh
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          Install-Module -Name Az.KeyVault -Force
          
      - name: Verify any active Azure Resource Group Deployments #These can mess up our deployment
        id: activedeps
        if: github.event.inputs.doVerifySteps != 'no'
        uses: Azure/cli@1.0.4
        with:
          azcliversion: ${{ env.AZCLIVERSION }}
          inlineScript: |
            echo "AZ CLI version"
            az version
            
            RG='${{ env.RG }}'
            RUNCOUNT=$(az deployment group list -g $RG --query "[?properties.provisioningState=='Running'].[properties.provisioningState, name] | length(@)" -o tsv)
            echo "Active deployments : $RUNCOUNT"

            echo 'Active deployment list'
            az deployment group list -g $RG --query "[?properties.provisioningState=='Running'].[properties.provisioningState, name]"

            #echo 'Verbose deployment list'
            #az deployment group list -g $RG --query "[].[properties.provisioningState, name]"

            echo "::set-output name=RUNCOUNT::$RUNCOUNT" #outputting for condition
            
      - name: Verify AKS Preview Features are available in target Subscription
        if: github.event.inputs.doVerifySteps != 'no'
        shell: pwsh
        run: |
          write-output 'Full list of features of AKS'
          az feature list -o table --query "[?contains(name, 'Microsoft.ContainerService')].{Name:name,State:properties.state}"

          write-output 'Features that are still registering'
          az feature list -o table --query "[?contains(name, 'Microsoft.ContainerService') && properties.state=='Registering'].{Name:name,State:properties.state}"

          write-output 'Checking to ensure no features are still registering'
          #Not going to use JMES as i'm getting a weird error that i don't see locally in powershell
          $aksfeatures = az feature list --query "[?contains(name, 'Microsoft.ContainerService')]" | ConvertFrom-Json
          #$aksfeatures = $allfeatures | Where-Object {$_.Name -like 'Microsoft.ContainerService*'}
          $registeringfeatures = $aksfeatures |  Where-Object {$_.properties.state -eq 'Registering'}
          
          if ($registeringfeatures -gt 0) {
            Write-Error "There are still features registering"
          } else { Write-Output "-- All good, no features in the process of registering" }

          write-output 'Check specific features.'
          $paramFilePath="${{ env.ParamFilePath }}"
          $paramFileContent=Get-Content $paramFilePath
          $params=$paramFileContent|ConvertFrom-Json
          
          if($params.parameters.upgradeChannel.value -ne $null) {
            $feature='AutoUpgradePreview'
            write-output "-- $feature"
            $featureCsi = $aksfeatures |  Where-Object {$_.name -like "*$feature"}
            $featureCsi.properties.state
            
            if ($featureCsi.properties.state -ne 'Registered') {
              Write-Ouput $featureCsi
              Write-Error "$feature NOT registered"
            } else { Write-Output "-- Looks like $feature is registered properly" }
          }
                   
          if($params.parameters.azureKeyvaultSecretsProvider.value -eq $true) {
            $feature='AKS-AzureKeyVaultSecretsProvider'
            write-output "-- $feature"
            $featureCsi = $aksfeatures |  Where-Object {$_.name -like "*$feature"}
            $featureCsi.properties.state
            
            if ($featureCsi.properties.state -ne 'Registered') {
              Write-Ouput $featureCsi
              Write-Error "$feature NOT registered"
            } else { Write-Output "-- Looks like $feature is registered properly" }
          }

      - name: Create Parameter file imperative override string
        uses: Azure/cli@1.0.4
        id: imperitiveparams
        with:
          azcliversion: ${{ env.AZCLIVERSION }}
          inlineScript: |
            RG='${{ env.RG }}'
            PARAMOVERRIDES="resourceName=$RESNAME byoAKSSubnetId=${{ secrets.ByoAksSubnetId }} byoAGWSubnetId=${{ secrets.ByoAgwSubnetId }} dnsZoneId=${{ secrets.DnsIdAzdemocouk }}"
            echo $PARAMOVERRIDES
            echo "::set-output name=PARAMOVERRIDES::$PARAMOVERRIDES"

      - name: Validate Infrastructure deployment
        uses: Azure/cli@1.0.4
        with:
          azcliversion: ${{ env.AZCLIVERSION }}
          inlineScript: |
            RG='${{ env.RG }}'
            RESNAME='${{ env.RESNAME }}'
            DEPNAME='Dep${{ github.run_number }}'
            PARAMS='${{ steps.imperitiveparams.outputs.PARAMOVERRIDES}}'
            
            echo $PARAMS
            
            az deployment group validate -f bicep/main.bicep -g $RG -p ${{ env.ParamFilePath }} -p $PARAMS --verbose

      - name: What If (GA edge Az cli version) (has issues)
        uses: Azure/cli@1.0.4
        id: edgeWhatIf
        continue-on-error: true #Setting to true due to bug in the AzureCLI https://github.com/Azure/azure-cli/issues/19850
        with:
          azcliversion: ${{ env.AZCLIVERSION }} #latest
          inlineScript: |
            RG='${{ env.RG }}'
            RESNAME='${{ env.RESNAME }}'
            DEPNAME='${{ env.DEPNAME }}'
            WHATIFPATH='whatif.json'
            PARAMS='${{ steps.imperitiveparams.outputs.PARAMOVERRIDES}}'

            #az deployment group what-if --debug -f bicep/main.bicep -g $RG -p ${{ env.ParamFilePath }} -p resourceName=$RESNAME byoAKSSubnetId=${{ secrets.ByoAksSubnetId }} byoAGWSubnetId=${{ secrets.ByoAgwSubnetId }} 

            az deployment group what-if --no-pretty-print -f bicep/main.bicep -g $RG -p ${{ env.ParamFilePath }} -p $PARAMS > $WHATIFPATH

            if [[ -f $WHATIFPATH ]]
            then
                echo "The WhatIf json file was created"
            fi

            cat $WHATIFPATH
            
            echo "::set-output name=edgeSuccess::true"

      - name: What If (workaround task)
        uses: Azure/cli@1.0.4
        continue-on-error: true #Setting to true due to bug in the AzureCLI https://github.com/Azure/azure-cli/issues/19850
        if: steps.edgeWhatIf.outputs.edgeSuccess != 'true'
        with:
          azcliversion: 2.26.0
          inlineScript: |
            RG='${{ env.RG }}'
            RESNAME='${{ env.RESNAME }}'
            DEPNAME='${{ env.DEPNAME }}'
            WHATIFPATH='whatif.json'
            PARAMS='${{ steps.imperitiveparams.outputs.PARAMOVERRIDES}}'

            az deployment group what-if --no-pretty-print -f bicep/main.bicep -g $RG -p ${{ env.ParamFilePath }} -p $PARAMS > $WHATIFPATH

            if [[ -f $WHATIFPATH ]]
            then
                echo "The WhatIf json file was created"
            fi

            cat $WHATIFPATH
            
      - name: What If Analysis Output - Parse output
        if: github.event.inputs.doVerifySteps != 'no'
        shell: pwsh
        run: |
          $whatifpath='whatif.json'

          Write-Output "Checking for JSON What-If"
          $whatifexists=Test-Path -path $whatifpath
          Write-Output $whatifexists

          if ($whatifexists) {
            $jsonFileRaw=Get-Content $whatifpath
            Write-Output $jsonFileRaw
            
            $whatIf=$jsonFileRaw | ConvertFrom-Json
            
            if ($null -eq $whatIf) {
              Write-Output "What If results are null"
              #We might want to throw an error here, after the whatif bug gets fixed https://github.com/Azure/azure-cli/issues/19850
            } else {
              Write-Output $whatif.changes[0].after.type
            }
          }

      - name: What If Analysis Output - Pester Testing
        shell: pwsh
        run: |
          Write-Output "https://pester.dev/"
          Write-Output "TODO"
          
      - name: What If Analysis Gaps - Check for Soft deleted KeyVaults
        shell: pwsh
        run: |     
          #This is a current gap in the What-If analysis.
          $whatifpath='whatif.json'
          $whatifexists=Test-Path -path $whatifpath

          if ($whatifexists) {
            $whatIf = Get-Content $whatifpath | ConvertFrom-Json
            
            if ($null -eq $whatIf) {
              Write-Output "What If results are null"
              #We might want to throw an error here, after the whatif bug gets fixed https://github.com/Azure/azure-cli/issues/19850
            } else {          
              $paramFilePath="${{ env.ParamFilePath }}"
              $paramFileContent=Get-Content $paramFilePath
              $params=$paramFileContent|ConvertFrom-Json

              if($params.parameters.createKV.value -eq $true) {
                Write-Output "Checking for already existing soft deleted KV"

                #lets do this properly and interrogate the whatif file for the KVNAME
                $kvafter = $whatif.changes | where-object {$_.after.type -eq 'Microsoft.KeyVault/vaults'} | where {$_.changeType -ne 'Ignore'}  | select after
                $vaultname = $kvafter.after.name

                write-output "Looking for KeyVault $vaultname"
                Get-AzKeyVault -InRemovedState | ft 

                $deletedKv = Get-AzKeyVault -InRemovedState | where-object {$_.vaultname -eq $vaultname}

                if($deletedKv.length -eq 0) {
                  Write-Output "All is good, soft deleted KV not found in soft deleted list."
                }
                else {
                  Write-Output "Soft deleted KV output"
                  Write-Output $deletedKv.length
                  Write-Output $deletedKv

                  Write-Error "Existing soft deleted Key Vault ($vaultName) Found - Cannot proceed, as deployment will fail"
                }
              }
            }
          }

  Deploy:
    runs-on: ubuntu-latest
    needs: [Validation]
    environment: azurecirgs
    outputs: 
      AKSNAME: ${{ steps.deployAks.outputs.AKSNAME}}
      LANAME : ${{ steps.deployAks.outputs.LANAME}}
      LAWGUID : ${{ steps.deployAks.outputs.LAWGUID}}
      AKVNAME : ${{ steps.deployAks.outputs.AKVNAME}}
      ACRNAME : ${{ steps.deployAks.outputs.ACRNAME}}
      AGNAME : ${{ steps.deployAks.outputs.AGNAME}}
      
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/develop' || contains( github.event.pull_request.labels.*.name, 'bug')
    steps:
      - uses: actions/checkout@v2

      - name: Job parameter check
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          RG='${{ env.RG }}'
          echo "RG is: $RG"

          echo "Param file path is: ${{ env.ParamFilePath }}"
          echo "Resource name is ${{ env.RESNAME }}
          echo "Deployment name is ${{ env.DEPNAME }}
          
      - name: Parameter file dependency check
        if: github.event.inputs.doVerifySteps != 'no'
        shell: pwsh
        run: |
          Write-Output "Checking parameter file existence/contents"
          $paramFilePath="${{ env.ParamFilePath }}"
          Test-Path $paramFilePath

          if (Test-Path $paramFilePath) {
            $paramFileContent=Get-Content $paramFilePath
            Write-Output $paramFileContent
          }

      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false
            
      - name: Deploy Infrastructure
        id: deployAks
        uses: Azure/cli@1.0.4
        with:
          azcliversion: ${{ env.AZCLIVERSION }}
          inlineScript: |
            RG='${{ env.RG }}'
            RESNAME='${{ env.RESNAME }}'
            DEPNAME='Dep${{ github.run_number }}'
            PARAMS="resourceName=$RESNAME byoAKSSubnetId=${{ secrets.ByoAksSubnetId }} byoAGWSubnetId=${{ secrets.ByoAgwSubnetId }} dnsZoneId=${{ secrets.DnsIdAzdemocouk }}"

            az deployment group create -f bicep/main.bicep -g $RG -p ${{ env.ParamFilePath }} -p $PARAMS --name $DEPNAME --verbose

            DEPSTATUS=$(az deployment operation group list --resource-group $RG --name $DEPNAME) #--query "[?properties.provisioningState=='Failed']"
            echo $DEPSTATUS

            #outputs
            AKSNAME=$(az deployment group show -n $DEPNAME -g $RG --query "properties.outputs.aksClusterName.value" -o tsv)
            echo "::set-output name=AKSNAME::$AKSNAME"

            AGNAME=$(az deployment group show -n $DEPNAME -g $RG --query "properties.outputs.applicationGatewayName.value" -o tsv)
            echo "::set-output name=AGNAME::$AGNAME" 

            AKVNAME=$(az deployment group show -n $DEPNAME -g $RG --query "properties.outputs.keyVaultName.value" -o tsv)
            echo "::set-output name=AKVNAME::$AKVNAME" 
            
            LANAME=$(az deployment group show -n $DEPNAME -g $RG --query "properties.outputs.logAnalyticsName.value" -o tsv)
            echo "::set-output name=LANAME::$LANAME" #outputting for conditon
            
            LAWGUID=$(az deployment group show -n $DEPNAME -g $RG --query "properties.outputs.logAnalyticsGuid.value" -o tsv)
            echo "::set-output name=LAWGUID::$LAWGUID" #outputting for conditon
            
            ACRNAME=$(az deployment group show -n $DEPNAME -g $RG --query "properties.outputs.containerRegistryName.value" -o tsv)
            echo "::set-output name=ACRNAME::$ACRNAME" #outputting for conditon
            
            
      - name: Enable AGIC Addon
        uses: Azure/cli@1.0.4
        if: ${{ needs.Deploy.outputs.AGNAME}} != ''
        with:
          azcliversion: ${{ env.AZCLIVERSION }}
          inlineScript: |
            RG='${{ env.RG }}'
            AKSNAME='${{ steps.deployAks.outputs.AKSNAME}}'
            AGNAME='${{ steps.deployAks.outputs.AGNAME}}'

            echo "AKS $AKSNAME"
            echo "AG $AGNAME"

            echo "Checking if ingressApplicationGateway is enabled"
            AGICEnabled=$(az aks show -n $AKSNAME -g  $RG --query "addonProfiles.ingressApplicationGateway.enabled")
            echo "AGICEnabled = $AGICEnabled"

            if [ "$AGICEnabled" != "true" ];
            then
                az aks enable-addons -n $AKSNAME -g $RG -a ingress-appgw --appgw-id $(az network application-gateway show -g $RG -n $AGNAME --query id -o tsv)
            fi
          
      - name: Create AGIC role assignments (if not exist)
        if: ${{ needs.Deploy.outputs.AGNAME}} != ''
        continue-on-error: true
        shell: pwsh
        run: |
            $RG='${{ env.RG }}'
            $AKSNAME='${{ steps.deployAks.outputs.AKSNAME}}'
            $AGNAME='${{ steps.deployAks.outputs.AGNAME}}'

                     write-output "AKS $AKSNAME"
            write-output "AG $AGNAME"

            write-output "Checking if ingressApplicationGateway is enabled"
            $AGICEnabled=az aks show -n $AKSNAME -g  $RG --query "addonProfiles.ingressApplicationGateway.enabled"
            write-output "AGICEnabled = $AGICEnabled"

            if ($AGICEnabled -eq $true) {
            	$agicobjid=az aks show -g $RG -n $AKSNAME --query "addonProfiles.ingressApplicationGateway.identity.objectId" -o tsv
              az role assignment list --assignee $agicobjid

              $rgScope=az group show -n $RG --query id
              az role assignment create --role Reader --assignee-object-id $agicobjid --assignee-principal-type ServicePrincipal --scope $rgScope

              $agwScope=az network application-gateway show -g $RG -n $AGNAME --query id -o tsv
              az role assignment create --role Contributor --assignee-object-id $agicobjid --assignee-principal-type ServicePrincipal --scope $agwScope

              az role assignment list --assignee $agicobjid
            }     
            
  CertificateConfig:
    runs-on: ubuntu-latest
    needs: [Deploy]
    environment: azurecirgs
    steps:
      - uses: actions/checkout@v2
      
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: false
          environment: azurecloud
          allow-no-subscriptions: false
          
      - name: Add KV access policy for managing certificates as this CI action user
        run: |
          CiSpId='${{ secrets.AZURE_CREDENTIALS_OBJID }}'
          AKVNAME='${{ needs.Deploy.outputs.AKVNAME}}'
          
          az keyvault set-policy --name $AKVNAME --object-id $CiSpId --secret-permissions get list --certificate-permissions get list delete create import update managecontacts getissuers listissuers setissuers deleteissuers manageissuers recover purge backup restore

      - name: Create self signed certs in Key Vault
        env:
          CERTNAMES: '["openjdk-demo","openjdk-demo-service","openjdk-kvssl","openjdk-kvssl-fe","aspnetapp"]'
        run: |
            RG='${{ env.RG }}'
            AKVNAME='${{ needs.Deploy.outputs.AKVNAME}}'

            echo $CERTNAMES
            
            jq --version

            echo $CERTNAMES | jq -r

            echo $CERTNAMES | jq -r '.[]' | while read cert; do
             echo "creating $cert"; 
             COMMON_NAME=$cert;
             az keyvault certificate create --vault-name $AKVNAME -n $COMMON_NAME -p "$(az keyvault certificate get-default-policy | sed -e s/CN=CLIGetDefaultPolicy/CN=${COMMON_NAME}/g )";
            done
            
            sleep 2m

      - name: Create Root Cert references in AppGW
        env:
          CERTNAMES: '["openjdk-demo","openjdk-demo-service","openjdk-kvssl"]'
        id: AppGwRootCert
        run: |
          AGNAME='${{ needs.Deploy.outputs.AGNAME}}'
          RG='${{ env.RG }}'
          KVNAME='${{ needs.Deploy.outputs.AKVNAME}}'

          echo $CERTNAMES | jq -r '.[]' | while read cert; do
             echo "getting id for $cert"; 
             versionedSecretId=$(az keyvault certificate show -n $cert --vault-name $KVNAME --query "sid" -o tsv);
             unversionedSecretId=$(echo $versionedSecretId | cut -d'/' -f-5) # remove the version from the url;
             echo $unversionedSecretId;
             rootcertcmd="az network application-gateway root-cert create --gateway-name $AGNAME  -g $RG -n $cert --keyvault-secret $unversionedSecretId";
             $rootcertcmd || $rootcertcmd --verbose
          done
          
      - name: Create FrontEnd Cert references in AppGW
        env:
          CERTNAMES: '["aspnetapp","openjdk-kvssl-fe"]'
        run: |
          AGNAME='${{ needs.Deploy.outputs.AGNAME}}'
          RG='${{ env.RG }}'
          KVNAME='${{ needs.Deploy.outputs.AKVNAME}}'
            
          echo $CERTNAMES | jq -r '.[]' | while read cert; do
             echo "getting id for $cert"; 
             versionedSecretId=$(az keyvault certificate show -n $cert --vault-name $KVNAME --query "sid" -o tsv);
             unversionedSecretId=$(echo $versionedSecretId | cut -d'/' -f-5) # remove the version from the url;
             echo $unversionedSecretId;
             fecertcmd="az network application-gateway ssl-cert create -n $cert --gateway-name $AGNAME -g $RG --key-vault-secret-id $unversionedSecretId";
             $fecertcmd || $fecertcmd --verbose
          done

      - name: Confirm certificates registered in AppGw
        if: github.event.inputs.doVerifySteps != 'no'
        run: |
          AGNAME='${{ needs.Deploy.outputs.AGNAME}}'
          RG='${{ env.RG }}'

          az network application-gateway ssl-cert list -g $RG --gateway-name $AGNAME --query "[].name"
          az network application-gateway root-cert list -g $RG --gateway-name $AGNAME --query "[].name"

  SmokeTest_PrivateJavaTLSApp:
    runs-on: ubuntu-latest
    needs: [Deploy, CertificateConfig, SmokeTest_SimpleApp]
    environment: azurecirgs
    steps:
      - uses: actions/checkout@v2

      - name: Param check
        if: github.event.inputs.doVerifySteps != 'no'
        run: |
          RG='${{ env.RG }}'
          echo "RG is: $RG"
          
          echo "Param file path is: ${{ env.ParamFilePath }}"
          echo "Resource name is ${{ env.RESNAME }}"
          echo "Deployment name is ${{ env.DEPNAME }}"
          echo "AKS name is ${{ needs.Deploy.outputs.AKSNAME}}"
          echo "ACR name is ${{ needs.Deploy.outputs.ACRNAME}}"
          
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false
        
      - name: AKS Connect
        run: |
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          az aks get-credentials -n $AKSNAME -g $RG --admin --overwrite-existing
          
      - name: Kubectl
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          #sudo az aks install-cli
          kubectl version
          
      - name: Observe Existing DNSConfig
        if: github.event.inputs.doDebugSteps != 'no'
        env:
          DNSDOMAIN: "azdemo.co.uk"
          DNSRG: "domainssl"
          RECORDNAME: "openjdk-demo"
        run: |
          az network dns record-set list -g $DNSRG -z $DNSDOMAIN --query "[?name=='$RECORDNAME'][{type:type,fqdn:fqdn,aRecords:aRecords,txtRecords:txtRecords}]"

      - name: Grab some Helm charts to install
        run: |
          BRANCH='${{ github.event.inputs.minihelmbranch }}'
          echo "$BRANCH"

          if [ -z "$BRANCH" ]
          then
                BRANCH='main'
          fi

          git clone -b $BRANCH https://github.com/Gordonby/minihelm.git helmcharts

      - name: Add a azure-config secret for use with externaldns
        env:
          DNSRESOURCEGROUP: "domainssl"
        run: |
          RG='${{ env.RG }}'
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'

          echo "AKS $AKSNAME"
          echo $DNSRESOURCEGROUP

          KubeletId=$(az aks show -n $AKSNAME -g  $RG --query "identityProfile.kubeletidentity.clientId" -o tsv)
          TenantId=$(az account show --query tenantId -o tsv)
          SubscriptionId=$(az account show --query id -o tsv)

          JSONSECRETPATH="azure.json"
          cat<<EOF>$JSONSECRETPATH
          {
            "userAssignedIdentityID": "$KubeletId",
            "tenantId": "$TenantId",
            "useManagedIdentityExtension": true,
            "subscriptionId": "$SubscriptionId",
            "resourceGroup": "$DNSRESOURCEGROUP"
          }
          EOF
          
          kubectl create secret generic azure-config-file --dry-run=client -o yaml --from-file=azure.json | kubectl apply -f -

      - name: Add external dns config
        env:
          DOMAINFILTER: "azdemo.co.uk"
        run: |
          echo $DOMAINFILTER
          helm upgrade --install externaldns ./helmcharts/samples/externaldns --set externaldns.domainfilter="$DOMAINFILTER"

      - name: Check DNS config
        if: github.event.inputs.doVerifySteps != 'no'
        env:
          DNSDOMAIN: "azdemo.co.uk"
          DNSRG: "domainssl"
          RECORDNAME: "openjdk-demo"
        run: |
          az network dns record-set list -g $DNSRG -z $DNSDOMAIN --query "[?name=='$RECORDNAME'][{type:type,fqdn:fqdn,aRecords:aRecords,txtRecords:txtRecords}]"

      - name: Install the Java sample app
        env:
          NAMESP: "default"
          APPNAME: "openjdk-kvssl" #Using backend cert common name
          DOMAINSUFFIX: "azdemo.co.uk"
          FRONTENDCERTNAME: "openjdk-kvssl-fe"
          
        run: |
          # REF: https://github.com/khowling/e2e-tls-java-aks
          
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          RG='${{ env.RG }}'
          KVNAME='${{ needs.Deploy.outputs.AKVNAME}}'
          KVNAMELOWER=${KVNAME,,}
          APPNAME='${{ env.APPNAME }}'
          KVTENANT=$(az account show --query tenantId -o tsv)
          AGNAME='${{ needs.Deploy.outputs.AGNAME}}'
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          DNSNAME=${APPNAME}.${DOMAINSUFFIX}

          echo 'Get the identity created from the KeyVaultSecret Addon'
          export CSISECRET_CLIENTID=$(az aks show -g $RG --name $AKSNAME --query addonProfiles.azureKeyvaultSecretsProvider.identity.clientId -o tsv)
          echo $CSISECRET_CLIENTID
          
          helm upgrade --install $APPNAME ./helmcharts/samples/javatlsappv2 --set nameOverride="${APPNAME}",csisecrets.vaultname="${KVNAMELOWER}",csisecrets.tenantId="${KVTENANT}",csisecrets.clientId="${CSISECRET_CLIENTID}",dnsname="${DNSNAME}",appgw.frontendCertificateName="${FRONTENDCERTNAME}",appgw.rootCertificateName="${APPNAME}" --dry-run
          helm upgrade --install $APPNAME ./helmcharts/samples/javatlsappv2 --set nameOverride="${APPNAME}",csisecrets.vaultname="${KVNAMELOWER}",csisecrets.tenantId="${KVTENANT}",csisecrets.clientId="${CSISECRET_CLIENTID}",dnsname="${DNSNAME}",appgw.frontendCertificateName="${FRONTENDCERTNAME}",appgw.rootCertificateName="${APPNAME}"
      
      - name: Verify Java App is reachable
        env:
          NAMESP: "default"
          APPNAME: "openjdk-kvssl"
          
          URLTOHIT: "https://openjdk-kvssl.azdemo.co.uk"
        run: |
          sleep 3m #Give everything a chance to work
        
          INGNAME="${APPNAME}-ingress"
          
          kubectl get po -n  $NAMESP
          kubectl get svc -n  $NAMESP
          kubectl get ingress -n  $NAMESP
          
          echo "Getting public ip"
          pubId=$(kubectl get ing -n $NAMESP $INGNAME -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Public ip : $pubId"
          echo "URL to hit: $URLTOHIT"
          
          respcode=$(curl -X GET --insecure --write-out %{http_code} --silent --output /dev/null $URLTOHIT)
          echo $respcode   
          
          #TODO: This is going to need to be rewritten. #loopshambles
          #SSH'ing on the runner shows this works, sometimes it just takes ages
          #Needs to be investigated.
          if [ "$respcode" != "200" ];
          then
              echo "going to need to wait longer i guess?"
              sleep 3m
              
              respcode=$(curl -X GET --insecure --write-out %{http_code} --silent --output /dev/null $URLTOHIT)
              echo $respcode    
              
              if [ "$respcode" != "200" ];
              then
                echo "going to need to wait EVEN longer i guess?  (wtf)"
                sleep 3m
                respcode=$(curl -X GET --insecure --write-out %{http_code} --silent --output /dev/null $URLTOHIT)
                echo $respcode    
                if [ "$respcode" != "200" ];
                then
                  echo "Non 200 response code from app - Raising error"
                  exit 1
                fi
              fi
          fi
          
          curl --insecure $URLTOHIT

      - name: Verify Frontend Certificate
        if: github.event.inputs.doVerifySteps != 'no'
        env:
          URLTOHIT: "https://openjdk-demo.azdemo.co.uk"
        run: |
          curl --insecure -vvI $URLTOHIT 2>&1 | awk 'BEGIN { cert=0 } /^\* SSL connection/ { cert=1 } /^\*/ { if (cert) print }'

      - name: Cleanup app
        if: github.event.inputs.doSmokeTestUninstall == 'yes'
        env:
          APPNAME: "openjdk-kvssl"
        run: helm uninstall $APPNAME
          
  SmokeTest_PublicJavaTLSApp:
    runs-on: ubuntu-latest
    needs: [Deploy, CertificateConfig, SmokeTest_SimpleApp, SmokeTest_PrivateJavaTLSApp]
    environment: azurecirgs
    steps:
      - uses: actions/checkout@v2

      - name: Param check
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          RG='${{ env.RG }}'
          echo "RG is: $RG"
          
          echo "Param file path is: ${{ env.ParamFilePath }}"
          echo "Resource name is ${{ env.RESNAME }}"
          echo "Deployment name is ${{ env.DEPNAME }}"
          echo "AKS name is ${{ needs.Deploy.outputs.AKSNAME}}"
          echo "ACR name is ${{ needs.Deploy.outputs.ACRNAME}}"
          
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false
        
      - name: AKS Connect
        run: |
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          az aks get-credentials -n $AKSNAME -g $RG --admin --overwrite-existing
          
      - name: Kubectl
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          #sudo az aks install-cli
          kubectl version
          
      - name: Observe Existing DNSConfig
        if: github.event.inputs.doDebugSteps != 'no'
        env:
          DNSDOMAIN: "azdemo.co.uk"
          DNSRG: "domainssl"
          RECORDNAME: "openjdk-demo"
        run: |
          az network dns record-set list -g $DNSRG -z $DNSDOMAIN --query "[?name=='$RECORDNAME'][{type:type,fqdn:fqdn,aRecords:aRecords,txtRecords:txtRecords}]"

      - name: Grab some Helm charts to install
        run: |
          git clone https://github.com/Gordonby/minihelm.git helmcharts

      - name: Add a azure-config secret for use with externaldns
        env:
          DNSRESOURCEGROUP: "domainssl"
        run: |
          RG='${{ env.RG }}'
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'

          echo "AKS $AKSNAME"
          echo $DNSRESOURCEGROUP

          KubeletId=$(az aks show -n $AKSNAME -g  $RG --query "identityProfile.kubeletidentity.clientId" -o tsv)
          TenantId=$(az account show --query tenantId -o tsv)
          SubscriptionId=$(az account show --query id -o tsv)

          JSONSECRETPATH="azure.json"
          cat<<EOF>$JSONSECRETPATH
          {
            "userAssignedIdentityID": "$KubeletId",
            "tenantId": "$TenantId",
            "useManagedIdentityExtension": true,
            "subscriptionId": "$SubscriptionId",
            "resourceGroup": "$DNSRESOURCEGROUP"
          }
          EOF
          
          kubectl create secret generic azure-config-file --dry-run=client -o yaml --from-file=azure.json | kubectl apply -f -

      - name: Add external dns config
        env:
          DOMAINFILTER: "azdemo.co.uk"
        run: |
          echo $DOMAINFILTER
          helm upgrade --install externaldns ./helmcharts/samples/externaldns --set externaldns.domainfilter="$DOMAINFILTER"

      - name: Check DNS config
        if: github.event.inputs.doVerifySteps != 'no'
        env:
          DNSDOMAIN: "azdemo.co.uk"
          DNSRG: "domainssl"
          RECORDNAME: "openjdk-demo"
        run: |
          az network dns record-set list -g $DNSRG -z $DNSDOMAIN --query "[?name=='$RECORDNAME'][{type:type,fqdn:fqdn,aRecords:aRecords,txtRecords:txtRecords}]"

      - name: Install Cert Manager
        env:
          MANIFESTTESTURL: "https://github.com/jetstack/cert-manager/releases/download/v1.5.3/cert-manager.yaml"
        run: |
          kubectl apply -f $MANIFESTTESTURL
          sleep 1m

      - name: Install ClusterIssuer
        env:
          EMAILAD: "gdogg@microsoft.com"
        run: |
          echo "Email Address for Lets Encrypt: $EMAILAD"
          helm upgrade --install smokecertissuer ./helmcharts/samples/certmanagerissuer --set email=$EMAILAD

      - name: Verify ClusterIssuer
        if: github.event.inputs.doVerifySteps != 'no'
        env:
          EMAILAD: "gdogg@microsoft.com"
        run: |
          sleep 1m          
          kubectl describe clusterissuer letsencrypt-staging

      - name: Install the Java sample app
        env:
          NAMESP: "default"
          CERTNAME: "openjdk-demo"
          DOMAINSUFFIX: "azdemo.co.uk"
          DOMAINPREFIX: "openjdk-demo"
          
        run: |
          # REF: https://github.com/khowling/e2e-tls-java-aks
          
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          RG='${{ env.RG }}'
          KVNAME='${{ needs.Deploy.outputs.AKVNAME}}'
          KVNAMELOWER=${KVNAME,,}
          CERTNAME='${{ env.CERTNAME }}'
          KVTENANT=$(az account show --query tenantId -o tsv)
          AGNAME='${{ needs.Deploy.outputs.AGNAME}}'
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          DNSNAME=${DOMAINPREFIX}.${DOMAINSUFFIX}

          echo 'Get the identity created from the KeyVaultSecret Addon'
          export CSISECRET_CLIENTID=$(az aks show -g $RG --name $AKSNAME --query addonProfiles.azureKeyvaultSecretsProvider.identity.clientId -o tsv)
          echo $CSISECRET_CLIENTID
          
          helm upgrade --install e2esmokeapp ./helmcharts/samples/javatlsapp --set nameOverride="openjdk-demo",csisecrets.vaultname="${KVNAMELOWER}",csisecrets.tenantId="${KVTENANT}",csisecrets.clientId="${CSISECRET_CLIENTID}",dnsname="${DNSNAME}" --dry-run
          helm upgrade --install e2esmokeapp ./helmcharts/samples/javatlsapp --set nameOverride="openjdk-demo",csisecrets.vaultname="${KVNAMELOWER}",csisecrets.tenantId="${KVTENANT}",csisecrets.clientId="${CSISECRET_CLIENTID}",dnsname="${DNSNAME}"

      - name: Verify LetsEncrypt Certificate logs
        if: github.event.inputs.doVerifySteps != 'no'
        run: |
          sleep 1m
          kubectl describe cert

      - name: Verify Java App is reachable
        env:
          NAMESP: "default"
          INGNAME: "openjdk-demo-ingress"
          URLTOHIT: "https://openjdk-demo.azdemo.co.uk"
        run: |
          sleep 2m #Give everything a chance to work
        
          kubectl get po -n  $NAMESP
          kubectl get svc -n  $NAMESP
          kubectl get ingress -n  $NAMESP
          
          echo "Getting public ip"
          pubId=$(kubectl get ing -n $NAMESP $INGNAME -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Public ip : $pubId"
          echo "URL to hit: $URLTOHIT"
          
          respcode=$(curl -X GET --insecure --write-out %{http_code} --silent --output /dev/null $URLTOHIT)
          echo $respcode   
          
          #TODO: This is going to need to be rewritten. #loopshambles
          #SSH'ing on the runner shows this works, sometimes it just takes ages
          #Needs to be investigated.
          if [ "$respcode" != "200" ];
          then
              echo "going to need to wait longer i guess?"
              sleep 3m
              
              respcode=$(curl -X GET --insecure --write-out %{http_code} --silent --output /dev/null $URLTOHIT)
              echo $respcode    
              
              if [ "$respcode" != "200" ];
              then
                echo "going to need to wait EVEN longer i guess?  (wtf)"
                sleep 3m
                respcode=$(curl -X GET --insecure --write-out %{http_code} --silent --output /dev/null $URLTOHIT)
                echo $respcode    
                if [ "$respcode" != "200" ];
                then
                  echo "Non 200 response code from app - Raising error"
                  exit 1
                fi
              fi
          fi
          
          curl --insecure $URLTOHIT
          
      - name: Verify Frontend Certificate
        if: github.event.inputs.doVerifySteps != 'no'
        env:
          URLTOHIT: "https://openjdk-demo.azdemo.co.uk"
        run: |
          curl --insecure -vvI $URLTOHIT 2>&1 | awk 'BEGIN { cert=0 } /^\* SSL connection/ { cert=1 } /^\*/ { if (cert) print }'

      - name: Cleanup app
        if: github.event.inputs.doSmokeTestUninstall == 'yes'
        env:
          APPNAME: "e2esmokeapp"
        run: helm uninstall $APPNAME

  SmokeTest_SimpleApp:
    runs-on: ubuntu-latest
    needs: [Deploy]
    environment: azurecirgs
    steps:
      - uses: actions/checkout@v2

      - name: Param check
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          RG='${{ env.RG }}'
          echo "RG is: $RG"
          
          echo "Param file path is: ${{ env.ParamFilePath }}"
          echo "Resource name is ${{ env.RESNAME }}"
          echo "Deployment name is ${{ env.DEPNAME }}"
          echo "AKS name is ${{ needs.Deploy.outputs.AKSNAME}}"
          
          whoami
          
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false
        
      - name: AKS Connect
        run: |
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          az aks get-credentials -n $AKSNAME -g $RG --admin --overwrite-existing
          
      - name: Kubectl
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          #sudo az aks install-cli
          kubectl version
          
      - name: Deploy AGIC Public Facing Workload
        env:
          MANIFESTTESTURL: "https://raw.githubusercontent.com/Gordonby/Snippets/master/AKS/Azure-Vote-Labelled-ILB-AGIC-NetPolicy.yaml"
          NAMESP: "default"
        run: |
          kubectl create namespace $NAMESP --dry-run=client -o yaml | kubectl apply -f -
          
          echo $MANIFESTTESTURL
          kubectl apply -f $MANIFESTTESTURL -n  $NAMESP
          kubectl get po -n  $NAMESP
          kubectl get svc -n  $NAMESP
          kubectl get ingress -n  $NAMESP
          
      - name: Verify AGIC Public Workload
        env:
          NAMESP: "default"
        run: |
          sleep 2m #Give everything a chance to work
        
          kubectl get po -n  $NAMESP
          kubectl get svc -n  $NAMESP
          kubectl get ingress -n  $NAMESP
          
          echo "Getting public ip"
          pubId=$(kubectl get ing -n $NAMESP azure-vote-ing -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Public ip : $pubId"
          
          respcode=$(curl -o /dev/null -s -w "%{http_code}\n" $pubId)
          echo $respcode   
          
          #TODO: This is going to need to be rewritten. #loopshambles
          #SSH'ing on the runner shows this works, sometimes it just takes ages
          #Needs to be investigated.
          if [ "$respcode" != "200" ];
          then
              echo "going to need to wait longer i guess?"
              sleep 3m
              
              respcode=$(curl -o /dev/null -s -w "%{http_code}\n" $pubId)
              echo $respcode    
              
              if [ "$respcode" != "200" ];
              then
                echo "going to need to wait EVEN longer i guess?  (wtf)"
                sleep 6m
                respcode=$(curl -o /dev/null -s -w "%{http_code}\n" $pubId)
                echo $respcode    
                if [ "$respcode" != "200" ];
                then
                  echo "Non 200 response code from app - Raising error"
                  exit 1
                fi
              fi
          fi
          
          curl $pubId
          
      - name: Remove App from cluster
        env:
          MANIFESTTESTURL: "https://raw.githubusercontent.com/Gordonby/Snippets/master/AKS/Azure-Vote-Labelled-ILB-AGIC-NetPolicy.yaml"
          NAMESP: "default"
        run: kubectl delete -f $MANIFESTTESTURL -n $NAMESP
          
  DeployVerify:
    runs-on: ubuntu-latest
    needs: [Deploy]
    steps:
      - uses: actions/checkout@v2
      
      - name: Param check
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          RG='${{ env.RG }}'
          echo "RG is: $RG"
          
          echo "Param file path is: ${{ env.ParamFilePath }}"
          echo "Resource name is ${{ env.RESNAME }}"
          echo "Deployment name is ${{ env.DEPNAME }}"
          echo "AKS name is ${{ needs.Deploy.outputs.AKSNAME }}"
          
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false
          
      - name: Test Control Plane Config
        shell: pwsh
        run: |
          $RG='${{ env.RG }}'
          $AKSNAME='${{ needs.Deploy.outputs.AKSNAME }}'
          $paramFilePath="${{ env.ParamFilePath }}"
          $params = Get-Content $paramFilePath | ConvertFrom-Json

          Write-Output "Checking for User Assigned Identity"
          if($params.parameters.custom_vnet.value -eq $true) {
            $aksId=az aks show -n $AKSNAME -g $RG --query "identity.type" -o tsv
            write-output $aksId
            
            if($aksId -eq "UserAssigned"){
              Write-Output "UAI set correctly"
            } else {
              Write-Error "UAI not set properly"}
          }
          
          Write-Output "Checking for CSI Secrets driver"
          if($params.parameters.azureKeyvaultSecretsProvider.value -eq $true) {
            $csiEnabled=az aks show -n $AKSNAME -g $RG --query "addonProfiles.omsagent.enabled" -o tsv
            write-output $csiEnabled
            
            if($csiEnabled -eq "true"){
              Write-Output "CSI Secrets driver set correctly"
            } else {
              Write-Error "CSI Secrets driver not set properly"}
          }
          #grep KeyvaultSecretsProvider

  InfraTests:
    runs-on: ubuntu-latest
    needs: [Deploy]
    steps:
      - name: Param check
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          RG='${{ env.RG }}'
          echo "RG is: $RG"
          
          echo "Param file path is: ${{ env.ParamFilePath }}"
          echo "Resource name is ${{ env.RESNAME }}"
          echo "Deployment name is ${{ env.DEPNAME }}"
          echo "LA name is ${{ needs.Deploy.outputs.LANAME }}"
          echo "LA workspace guid is ${{ needs.Deploy.outputs.LAWGUID }}"
          
      - name: Allow Monitoring extension
        shell: pwsh
        run: |
          az extension add -n log-analytics -y
          
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds:  ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false
          
      - name: Log Analytics log table verification
        shell: pwsh
        run: |
          Write-Output "Check for Logs in the Log Analytics Workspace"
          $LANAME='${{ needs.Deploy.outputs.LANAME}}'
          $LAWGUID='${{ needs.Deploy.outputs.LAWGUID}}'
          $AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          
          #$KubeNode = az monitor log-analytics query -w $LAWGUID --analytics-query "KubeNodeInventory | summarize count() by Computer, bin(TimeGenerated, 1h)"
          $KubeNode = az monitor log-analytics query -w $LAWGUID --analytics-query "KubeNodeInventory | count" -o json | ConvertFrom-Json
          Write-Output $KubeNode
          Write-Output $KubeNode[0].Count
          
          if ($KubeNode[0].Count -eq 0) {
            throw "Log Analytics Workspace table: KubeNodeInventory does not have any data. Check network traffic is not being supressed by firewall egress rules"
          }
          
          $containers = az monitor log-analytics query -w $LAWGUID --analytics-query "ContainerLog | join(KubePodInventory| where TimeGenerated > startofday(ago(1h))) on ContainerID |where TimeGenerated > startofday(ago(10m)) | project TimeGenerated ,Namespace , LogEntrySource , LogEntry | summarize count() by Namespace, LogEntrySource"
          Write-Output $containers

  CaptureAgicLogs:
    runs-on: ubuntu-latest
    needs: [Deploy, SmokeTest_SimpleApp, SmokeTest_PublicJavaTLSApp]
    if: always() && ${{ needs.Deploy.outputs.AGNAME != '' }}
    steps:
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false

      - name: AKS Connect
        run: |
          AKSNAME='${{ needs.Deploy.outputs.AKSNAME}}'
          az aks get-credentials -n $AKSNAME -g $RG --admin --overwrite-existing
          
      - name: Kubectl
        if: github.event.inputs.doDebugSteps != 'no'
        run: |
          #sudo az aks install-cli
          kubectl version
          
      - name: Describe AGIC Pod
        env:
          NAMESP: "kube-system"
        run: |
          APPGWPODNAME=$(kubectl get pods -n $NAMESP -o json | jq -r '.items[] | select(.metadata.name | test("appgw-")).metadata.name')
          kubectl describe po -n $NAMESP $APPGWPODNAME

      - name: Grab AGIC pod logs
        env:
          NAMESP: "kube-system"
        run: |
          APPGWPODNAME=$(kubectl get pods -n $NAMESP -o json | jq -r '.items[] | select(.metadata.name | test("appgw-")).metadata.name')
          kubectl logs -n $NAMESP $APPGWPODNAME
          
      - name: Check Events for default namespace
        env:
          NAMESP: "default"
        run: kubectl get events -n $NAMESP

  Infra_Destroy:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    needs: [Validation, Deploy, InfraTests, DeployVerify, CertificateConfig, SmokeTest_SimpleApp, SmokeTest_PublicJavaTLSApp, Well_Architected, CaptureAgicLogs]
    steps:
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
          environment: azurecloud
          allow-no-subscriptions: false

      - name: Install Pwsh modules
        shell: pwsh
        run: |
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          Install-Module -Name Az.Accounts
          Install-Module -Name Az.Resources

      - name: Cleanup
        shell: pwsh
        run: |
          $RG='${{ env.RG }}'
          # Get all ARM resources from all resource groups
          $rgToPurge = Get-AzResourceGroup -Name $RG
          try {
            #purge any KV's
            Get-AzResource -ResourceGroupName $rgToPurge.ResourceGroupName | ? {$_.ResourceType -eq "Microsoft.KeyVault/vaults"} | Remove-AzKeyVault -force
            
            #Remove all but public ip addresses
            Get-AzResource -ResourceGroupName $rgToPurge.ResourceGroupName | ? {$_.ResourceType -ne "Microsoft.Network/publicIPAddresses"} | Remove-AzResource -Force
            
            #Remove public ip addresses
            Get-AzResource -ResourceGroupName $rgToPurge.ResourceGroupName | ? {$_.ResourceType -eq "Microsoft.Network/publicIPAddresses"} | Remove-AzResource -Force
            
            #Final run to clean other dependant resources in parent-child graph
            Get-AzResource -ResourceGroupName $rgToPurge.ResourceGroupName | Remove-AzResource -Force
          }
          Catch #we're wanting to suppress failures in this step. If it fails to clean, the nightly automation will catch it.
          {
            write-output error
          }
