on: 
  workflow_call:
    inputs:
      RG:
        required: true
        type: string
      AKSNAME:
        required: true
        type: string
      AGNAME:
        required: true
        type: string
      APPNAME:
        required: true
        type: string
      NAMESPACE:
        default: "default"
        required: false
        type: string
      INGRESSTYPE:
        default: "PublicLoadBalancer"
        required: false
        type: string  # - 'PublicLoadBalancer'/InternalLoadBalancer/AGIC-Public-Ingress/AGIC-Private-Ingress
      UNINSTALLAFTERVERIFY:
        description: 'Uninstall app after tests  [yes|no]'  
        type: boolean
        default: false
        required: true
      MINIHELMBRANCH:
        default: "main"
        required: false
        type: string
        description: "The branch of MINIHELM to use"
      USERUNCOMMAND:
        description: 'Use the AKS Run Command to install App'  
        type: boolean
        default: true
        required: true
    secrets:
      AZURE_CREDENTIALS:
        required: true
        
jobs:
  App_Create:
    runs-on: ubuntu-latest
    concurrency: ${{ inputs.AGNAME}} #AppGateway doesn't like concurrent updates
    steps:
      - uses: actions/checkout@v2
      
      - name: Job parameter inspection
        run: |
          echo "RG is ${{ inputs.RG }}"
          echo "AKS name is ${{ inputs.AKSNAME }}"
          
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: false
          environment: azurecloud
          allow-no-subscriptions: false

      - name: AKS Connect
        if: inputs.USERUNCOMMAND == false
        env:
          RG: "${{ inputs.RG }}"
          AKSNAME: "${{ inputs.AKSNAME }}"
        run: |
          az aks get-credentials -n $AKSNAME -g $RG --admin --overwrite-existing
          
      - name: Kubectl
        if: inputs.USERUNCOMMAND == false
        run: |
          #sudo az aks install-cli
          kubectl version

      - name: Grab Helm chart to install
        if: inputs.USERUNCOMMAND == false
        run: |
          BRANCH='${{ inputs.MINIHELMBRANCH }}'
          echo "$BRANCH"

          if [ -z "$BRANCH" ]
          then
                BRANCH='main'
          fi

          git clone -b $BRANCH https://github.com/Gordonby/minihelm.git helmcharts
          
      - name: Check if App Helm Chart already installed
        if: inputs.USERUNCOMMAND == false
        env:
          APPNAME: "${{ inputs.APPNAME }}"          
        run: |
          APPINSTALLED=$(helm list --filter ^$APPNAME$ --short)
          if [ -z "$APPINSTALLED" ]
          then
                echo "App not installed"
          else
                echo "App already installed, forcing uninstall"
                helm list --short
                helm uninstall $APPNAME
                sleep 1m
          fi

      - name: Install the Vote app
        if: inputs.USERUNCOMMAND == false
        env:
          NAMESP: "default"
          APPNAME: "${{ inputs.APPNAME }}" #Using backend cert common name
          
        run: |
          # REF: https://github.com/khowling/e2e-tls-java-aks
          
          AKSNAME='${{ inputs.AKSNAME}}'
          RG='${{ inputs.RG }}'
          APPNAME='${{ inputs.APPNAME }}'
          #AGNAME='${{ inputs.AGNAME}}'
          
          helm upgrade --install $APPNAME ./helmcharts/samples/azurevote-simple --set service.azureLbInternal="false" --dry-run
          helm upgrade --install $APPNAME ./helmcharts/samples/azurevote-simple --set service.azureLbInternal="false"

      - name: Install the Vote app (run cmd)
        if: inputs.USERUNCOMMAND == true
        env:
          NAMESP: "default"
          APPNAME: "${{ inputs.APPNAME }}"
        run: |
          AKSNAME='${{ inputs.AKSNAME}}'
          RG='${{ inputs.RG }}'
          APPNAME='${{ inputs.APPNAME }}'
          #AGNAME='${{ inputs.AGNAME}}'
          
          az aks command invoke -g $RG -n $AKSNAME --command "
          helm upgrade --install $APPNAME https://github.com/Gordonby/minihelm/raw/main/samples/AzureVote-0.1.0.tgz --set service.azureLbInternal=false
          "
      - name: Checking deployment (Run cmd invoke)
        if: inputs.USERUNCOMMAND == true
        env:
          NAMESP: "default"
        run: |
          RG='${{ inputs.RG }}'
          AKSNAME='${{ inputs.AKSNAME}}'

          az aks command invoke -g $RG -n $AKSNAME --command "
          kubectl get po -n $NAMESP
          "
          
          az aks command invoke -g $RG -n $AKSNAME --command "
          kubectl get svc -n $NAMESP
          "
          
          az aks command invoke -g $RG -n $AKSNAME --command "
          kubectl get svc -n $NAMESP
          "


      - name: Verify App is reachable
        #if: github.event.inputs.INGRESSTYPE == 'PublicLoadBalancer'
        if: inputs.INGRESSTYPE == 'PublicLoadBalancer' && inputs.USERUNCOMMAND == false
        env:
          NAMESP: "default"
          APPNAME: "${{ inputs.APPNAME }}"
        run: |
          echo "Waiting on IP allocation"
          sleep 1m
          
          pubIp=$(kubectl get svc -n $NAMESP azure-vote-front -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Public ip : $pubIp"
          
          counter=1
          while [ $counter -le 20 ] && [ "$respcode" != "200" ]
          do
            echo "curl $pubIp [$counter]"
            respcode=$(curl -o /dev/null -s -w "%{http_code}\n" $pubIp)
            echo $respcode   

            cleanResponseCode=$(echo $respcode|tr -d '\n')
            echo $cleanResponseCode

            if [ "$cleanResponseCode" != "200" ];
            then
                echo "going to wait another 30s [$counter] [$(date +"%T")]"
                ((counter++))
                sleep 30s
            fi
          done
          
          curl $pubIp

      - name: Verify Public LB App is reachable via IP (run cmd)
        #if: github.event.inputs.INGRESSTYPE == 'PublicLoadBalancer'
        if: inputs.INGRESSTYPE == 'PublicLoadBalancer' && inputs.USERUNCOMMAND == true
        env:
          NAMESP: "default"
          APPNAME: "${{ inputs.APPNAME }}"
        run: |
          echo "Waiting on IP allocation"
          sleep 2m

          AKSNAME='${{ inputs.AKSNAME}}'
          RG='${{ inputs.RG }}'

          echo "Invoking Get SVC to retrieve IP for $AKSNAME in $RG"

          command="kubectl get svc azure-vote-front -n $NAMESP -ojson"
          echo "Sending command $command to AKS"
          cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}")
          
          ipAddress=$(echo $cmdOut | jq -r '.logs' | jq -r '.status.loadBalancer.ingress[0].ip')
          echo "IPAddress is $ipAddress"
          
          counter=1
          while [ $counter -le 20 ] && [ "$respcode" != "200" ]
          do
            echo "curl $ipAddress for response code [$counter]"

            command="curl -o /dev/null -s -w "%{http_code}\n" $ipAddress"
            echo "Sending command to AKS : $command"
            
            cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}")  

            echo $cmdOut > debug.json
            respcode=$(echo $cmdOut | jq -r '.logs')

            echo $respcode   
            if [ "$respcode" == "200" ] || [ "$respcode" == "200n" ];
            then
                echo "going to wait another 30s [$counter] [$(date +"%T")]"
                ((counter++))
                sleep 30s
            else
                break 2
            fi
          done
          
          echo "curl $ipAddress for content [$counter attempts for 200]"
          command="curl $ipAddress"
          cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}") 
          cmdLogs=$(echo $cmdOut | jq -r '.logs')
          
          echo $cmdLogs

      - name: Cleanup app
        if: inputs.UNINSTALLAFTERVERIFY
        env:
          APPNAME: "${{ inputs.APPNAME }}"
        run: helm uninstall $APPNAME
        
      - name: Debug Artifact
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: Json out
          path: debug.json
