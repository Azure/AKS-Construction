# Demonstrates how to install the Azure Voting app, leveraging the AKS Run Command. This works great for private clusters.

on: 
  workflow_call:
    inputs:
      RG:
        required: true
        type: string
      AKSNAME:
        required: true
        type: string
      AGNAME:
        required: true
        type: string
      APPNAME:
        required: true
        type: string
      NAMESPACE:
        default: "default"
        required: false
        type: string
      INGRESSTYPE:
        default: "PublicLoadBalancer"
        required: false
        type: string  # - 'PublicLoadBalancer'/InternalLoadBalancer/AGIC-Public-Ingress/AGIC-Private-Ingress
      UNINSTALLAFTERVERIFY:
        description: 'Uninstall app after tests  [yes|no]'  
        type: boolean
        default: false
        required: true
      HELMPACKAGEURI:
        default: "https://github.com/Gordonby/minihelm/raw/azureVoteIngress/samples/AzureVote-0.2.0.tgz"
        required: false
        type: string
        description: "The location of the Helm package"
      CURLRETRIES:
        description: 'How many retry attempts when verifying deployed App Url'  
        type: number
        default: 10
        required: false
    secrets:
      AZURE_CREDENTIALS:
        required: true
        
jobs:
  App_Create:
    runs-on: ubuntu-latest
    concurrency: "Ag-${{ inputs.AGNAME}}" #AppGateway doesn't like concurrent updates
    steps:
      - uses: actions/checkout@v2
      
      - name: Job parameter inspection
        run: |
          echo "RG is ${{ inputs.RG }}"
          echo "AKS name is ${{ inputs.AKSNAME }}"
          
      - name: Azure Login
        uses: Azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: false
          environment: azurecloud
          allow-no-subscriptions: false
                   
      - name: Install the Vote app
        id: installapp
        env:
          NAMESP: "${{ inputs.NAMESPACE }}"
          APPNAME: "${{ inputs.APPNAME }}"
        run: |
          AKSNAME='${{ inputs.AKSNAME}}'
          RG='${{ inputs.RG }}'
          APPNAME='${{ inputs.APPNAME }}'
          #AGNAME='${{ inputs.AGNAME}}'
          
          #This deployment maps the Ingress Parameter type to underlying parameters in the Helm Chart
          echo ${{ inputs.INGRESSTYPE }}
          
          case "${{ inputs.INGRESSTYPE }}" in
          PublicLoadBalancer)
            serviceType="LoadBalancer"
            privateIp=false
            ingress=false
            echo "::set-output name=RESTYPE::svc"
            echo "::set-output name=ISPUBLIC::true"
            ;;

          InternalLoadBalancer)
            serviceType="LoadBalancer"
            privateIp=true
            ingress=false
            echo "::set-output name=RESTYPE::svc"
            ;;

          AGIC-Public-Ingress)
            serviceType="ClusterIP"
            privateIp=false
            ingress=true
            echo "::set-output name=RESTYPE::ing"
            echo "::set-output name=ISPUBLIC::true"
            ;;

          AGIC-Private-Ingress)
            serviceType="ClusterIP"
            privateIp=true
            ingress=true
            echo "::set-output name=RESTYPE::ing"
            ;;
          esac
          
          #Create a list of parameters to override
          helmsetparams="ingress.enabled=${ingress},ingress.appGwPrivateIp=$privateIp,service.azureLbInternal=$privateIp,service.type=\"$serviceType\""
          echo $helmsetparams
          
          #Helm Dry Run
          command="helm upgrade --install $APPNAME ${{ inputs.HELMPACKAGEURI }} --set $helmsetparams --dry-run"
          echo "Sending command $command to AKS"
          cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}")
          echo $cmdOut
          
          #Helm Install
          command="helm upgrade --install $APPNAME ${{ inputs.HELMPACKAGEURI }} --set $helmsetparams"
          echo "Sending command $command to AKS"
          cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}")
          echo $cmdOut

      - name: Checking deployment
        env:
          NAMESP: "${{ inputs.NAMESPACE }}"
        run: |
          RG='${{ inputs.RG }}'
          AKSNAME='${{ inputs.AKSNAME}}'

          command="kubectl get po -n $NAMESP"
          echo "Sending command $command to AKS"
          az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}"
          
          command="kubectl get svc -n $NAMESP"
          echo "Sending command $command to AKS"
          az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}"

          command="kubectl get ing -n $NAMESP"
          echo "Sending command $command to AKS"
          az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}"

      - name: Verify App is reachable (from run cmd container)
        id: verifyAppAvailable
        env:
          NAMESP: "${{ inputs.NAMESPACE }}"
          APPNAME: "${{ inputs.APPNAME }}"
        run: |
          AKSNAME='${{ inputs.AKSNAME}}'
          RG='${{ inputs.RG }}'

          echo "Invoking Get ${{ steps.installapp.outputs.RESTYPE}} to retrieve IP for $AKSNAME in $RG"
          
          counter=1
          while [ $counter -le 10 ]
          do
            command="kubectl get ${{ steps.installapp.outputs.RESTYPE}} azure-vote-front -n $NAMESP -ojson"
            echo "Sending command $command to AKS"
            cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}")

            ipAddress=$(echo $cmdOut | jq -r '.logs' | jq -r '.status.loadBalancer.ingress[0].ip')
            echo "IPAddress is $ipAddress"

            echo $ipAddress
            if [ "$ipAddress" != "" ];
            then
                break 2
            else
                echo "going to wait another 10s [$counter] [$(date +"%T")]"
                ((counter++))
                sleep 10
            fi
          done

          echo "::set-output name=IPADDRESS::$ipAddress"
          
          counter=1
          while [ $counter -le ${{ inputs.CURLRETRIES }} ] && [ "$respcode" != "200" ]
          do
            echo "curl $ipAddress for response code [$counter]"

            #command="curl -o /dev/null -s -w "%{http_code}\n" $ipAddress"
            command="curl --connect-timeout 2 --retry 2 --retry-delay 5 --no-keepalive --no-tcp-nodelay  -o /dev/null -s -w "%{http_code}\n" $ipAddress"
            echo "Sending command to AKS : $command"
            
            cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}")  

            echo $cmdOut > debug.json
            respcode=$(echo $cmdOut | jq -r '.logs')

            echo $respcode
            if [ "$respcode" == "200" ] || [ "$respcode" == "200n" ];
            then
                echo "200 response code received after $counter trys"
                break 2
            else
                echo "going to wait another 15s [$counter] [$(date +"%T")]"
                ((counter++))
                sleep 15
            fi
          done
          
          if [ "$respcode" == "200" ] || [ "$respcode" == "200n" ];
          then
            echo "curl $ipAddress for content [$counter attempts for 200]"
            command="curl $ipAddress"
            cmdOut=$(az aks command invoke -g $RG -n $AKSNAME -o json --command "${command}") 
            cmdLogs=$(echo $cmdOut | jq -r '.logs')

            echo $cmdLogs
          else
              echo "$respcode not 200 - failing"
             exit 1
          fi

      - name: Verify Public LB App is reachable (from GitHub agent)
        if: ${{ steps.installapp.outputs.ISPUBLIC}} = 'true'
        env:
          NAMESP: "${{ inputs.NAMESPACE }}"
          APPNAME: "${{ inputs.APPNAME }}"
        run: |
          AKSNAME='${{ inputs.AKSNAME}}'
          RG='${{ inputs.RG }}'

          ipAddress='${{ steps.verifyAppAvailable.outputs.IPADDRESS}}'
          
          counter=1
          while [ $counter -le ${{ inputs.CURLRETRIES }} ] && [ "$respcode" != "200" ]
          do
            echo "curl $ipAddress for response code [$counter]"

            respcode=$(curl -o /dev/null -s -w "%{http_code}\n" $ipAddress)

            echo $respcode
            if [ "$respcode" == "200" ] || [ "$respcode" == "200n" ];
            then
                echo "200 response code received after $counter trys"
                break 2
            else
                echo "going to wait another 15s [$counter] [$(date +"%T")]"
                ((counter++))
                sleep 15
            fi
          done
          
          if [ "$respcode" == "200" ] || [ "$respcode" == "200n" ];
          then
            echo "curl $ipAddress for content [$counter attempts for 200]"
            command="curl $ipAddress"
            cmdOut=$(command) 
            cmdLogs=$(echo $cmdOut | jq -r '.logs')

            echo $cmdLogs
          else
              echo "$respcode not 200 - failing"
              curl $ipAddress
             exit 1
          fi

      - name: Cleanup app
        if: inputs.UNINSTALLAFTERVERIFY
        env:
          APPNAME: "${{ inputs.APPNAME }}"
        run: helm uninstall $APPNAME
        
      - name: Store any generated debug files as artifact
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: DebugFiles
          path: debug*.json
