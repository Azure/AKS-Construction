{"version":3,"file":"dynamicproto-js.min.js","sources":["../../out/lib/src/DynamicProto.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nvar _a;\r\n;\r\nvar UNDEFINED = \"undefined\";\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar Constructor = 'constructor';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar Prototype = 'prototype';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar strFunction = 'function';\r\n/**\r\n * Used to define the name of the instance function lookup table\r\n * @ignore\r\n */\r\nvar DynInstFuncTable = '_dynInstFuncs';\r\n/**\r\n * Name used to tag the dynamic prototype function\r\n * @ignore\r\n */\r\nvar DynProxyTag = '_isDynProxy';\r\n/**\r\n * Name added to a prototype to define the dynamic prototype \"class\" name used to lookup the function table\r\n * @ignore\r\n */\r\nvar DynClassName = '_dynClass';\r\n/**\r\n * Prefix added to the classname to avoid any name clashes with other instance level properties\r\n * @ignore\r\n */\r\nvar DynClassNamePrefix = '_dynCls$';\r\n/**\r\n * A tag which is used to check if we have already to attempted to set the instance function if one is not present\r\n * @ignore\r\n */\r\nvar DynInstChkTag = '_dynInstChk';\r\n/**\r\n * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same\r\n * tag name as the function level but a different const name for readability only.\r\n */\r\nvar DynAllowInstChkTag = DynInstChkTag;\r\n/**\r\n * The global (imported) instances where the global performance options are stored\r\n */\r\nvar DynProtoDefaultOptions = '_dfOpts';\r\n/**\r\n * Value used as the name of a class when it cannot be determined\r\n * @ignore\r\n */\r\nvar UnknownValue = '_unknown_';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar str__Proto = \"__proto__\";\r\n/**\r\n * The polyfill version of __proto__ so that it doesn't cause issues for anyone not expecting it to exist\r\n */\r\nvar DynProtoBaseProto = \"_dyn\" + str__Proto;\r\n/**\r\n * Runtime Global holder for dynamicProto settings\r\n */\r\nvar DynProtoGlobalSettings = \"__dynProto$Gbl\";\r\n/**\r\n * Track the current prototype for IE8 as you can't look back to get the prototype\r\n */\r\nvar DynProtoCurrent = \"_dynInstProto\";\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar strUseBaseInst = 'useBaseInst';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar strSetInstFuncs = 'setInstFuncs';\r\nvar Obj = Object;\r\n/**\r\n * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)\r\n * @ignore\r\n */\r\nvar _objGetPrototypeOf = Obj[\"getPrototypeOf\"];\r\n/**\r\n * Pre-lookup to check for the existence of this function\r\n */\r\nvar _objGetOwnProps = Obj[\"getOwnPropertyNames\"];\r\n/**\r\n * Gets the runtime global reference\r\n * @returns\r\n */\r\nfunction _getGlobal() {\r\n    var result;\r\n    if (typeof globalThis !== UNDEFINED) {\r\n        result = globalThis;\r\n    }\r\n    if (!result && typeof self !== UNDEFINED) {\r\n        result = self;\r\n    }\r\n    if (!result && typeof window !== UNDEFINED) {\r\n        result = window;\r\n    }\r\n    if (!result && typeof global !== UNDEFINED) {\r\n        result = global;\r\n    }\r\n    return result || {};\r\n}\r\n// Since 1.1.7 moving these to the runtime global to work around mixed version and module issues\r\n// See Issue https://github.com/microsoft/DynamicProto-JS/issues/57 for details\r\nvar _gbl = _getGlobal();\r\nvar _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {\r\n    o: (_a = {},\r\n        _a[strSetInstFuncs] = true,\r\n        _a[strUseBaseInst] = true,\r\n        _a),\r\n    n: 1000 // Start new global index @ 1000 so we \"fix\" some cases when mixed with 1.1.6 or earlier\r\n});\r\n/**\r\n * Helper to check if the object contains a property of the name\r\n * @ignore\r\n */\r\nfunction _hasOwnProperty(obj, prop) {\r\n    return obj && Obj[Prototype].hasOwnProperty.call(obj, prop);\r\n}\r\n/**\r\n * Helper used to check whether the target is an Object prototype or Array prototype\r\n * @ignore\r\n */\r\nfunction _isObjectOrArrayPrototype(target) {\r\n    return target && (target === Obj[Prototype] || target === Array[Prototype]);\r\n}\r\n/**\r\n * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype\r\n * @ignore\r\n */\r\nfunction _isObjectArrayOrFunctionPrototype(target) {\r\n    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];\r\n}\r\n/**\r\n * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.\r\n * @ignore\r\n */\r\nfunction _getObjProto(target) {\r\n    var newProto;\r\n    if (target) {\r\n        // This method doesn't exist in older browsers (e.g. IE8)\r\n        if (_objGetPrototypeOf) {\r\n            return _objGetPrototypeOf(target);\r\n        }\r\n        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);\r\n        // Using the pre-calculated value as IE8 doesn't support looking up the prototype of a prototype and thus fails for more than 1 base class\r\n        newProto = target[DynProtoBaseProto] || curProto;\r\n        if (!_hasOwnProperty(target, DynProtoBaseProto)) {\r\n            // As this prototype doesn't have this property then this is from an inherited class so newProto is the base to return so save it\r\n            // so we can look it up value (which for a multiple hierarchy dynamicProto will be the base class)\r\n            delete target[DynProtoCurrent]; // Delete any current value allocated to this instance so we pick up the value from prototype hierarchy\r\n            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];\r\n            target[DynProtoCurrent] = curProto;\r\n        }\r\n    }\r\n    return newProto;\r\n}\r\n/**\r\n * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6\r\n * are not enumerable.\r\n * @param target\r\n */\r\nfunction _forEachProp(target, func) {\r\n    var props = [];\r\n    if (_objGetOwnProps) {\r\n        props = _objGetOwnProps(target);\r\n    }\r\n    else {\r\n        for (var name_1 in target) {\r\n            if (typeof name_1 === \"string\" && _hasOwnProperty(target, name_1)) {\r\n                props.push(name_1);\r\n            }\r\n        }\r\n    }\r\n    if (props && props.length > 0) {\r\n        for (var lp = 0; lp < props.length; lp++) {\r\n            func(props[lp]);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper function to check whether the provided function name is a potential candidate for dynamic\r\n * callback and prototype generation.\r\n * @param target The target object, may be a prototype or class object\r\n * @param funcName The function name\r\n * @param skipOwn Skips the check for own property\r\n * @ignore\r\n */\r\nfunction _isDynamicCandidate(target, funcName, skipOwn) {\r\n    return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || _hasOwnProperty(target, funcName)));\r\n}\r\n/**\r\n * Helper to throw a TypeError exception\r\n * @param message the message\r\n * @ignore\r\n */\r\nfunction _throwTypeError(message) {\r\n    throw new TypeError(\"DynamicProto: \" + message);\r\n}\r\n/**\r\n * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does\r\n * not return any inherited functions\r\n * @param thisTarget The object to get the instance functions from\r\n * @ignore\r\n */\r\nfunction _getInstanceFuncs(thisTarget) {\r\n    // Get the base proto\r\n    var instFuncs = {};\r\n    // Save any existing instance functions\r\n    _forEachProp(thisTarget, function (name) {\r\n        // Don't include any dynamic prototype instances - as we only want the real functions\r\n        if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {\r\n            // Create an instance callback for passing the base function to the caller\r\n            instFuncs[name] = thisTarget[name];\r\n        }\r\n    });\r\n    return instFuncs;\r\n}\r\n/**\r\n * Returns whether the value is included in the array\r\n * @param values The array of values\r\n * @param value  The value\r\n */\r\nfunction _hasVisited(values, value) {\r\n    for (var lp = values.length - 1; lp >= 0; lp--) {\r\n        if (values[lp] === value) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns an object that contains callback functions for all \"base/super\" functions, this is used to \"save\"\r\n * enabling calling super.xxx() functions without requiring that the base \"class\" has defined a prototype references\r\n * @param target The current instance\r\n * @ignore\r\n */\r\nfunction _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {\r\n    function _instFuncProxy(target, funcHost, funcName) {\r\n        var theFunc = funcHost[funcName];\r\n        if (theFunc[DynProxyTag] && useBaseInst) {\r\n            // grab and reuse the hosted looking function (if available) otherwise the original passed function\r\n            var instFuncTable = target[DynInstFuncTable] || {};\r\n            if (instFuncTable[DynAllowInstChkTag] !== false) {\r\n                theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;\r\n            }\r\n        }\r\n        return function () {\r\n            // eslint-disable-next-line prefer-rest-params\r\n            return theFunc.apply(target, arguments);\r\n        };\r\n    }\r\n    // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)\r\n    var baseFuncs = {};\r\n    _forEachProp(instFuncs, function (name) {\r\n        // Create an instance callback for passing the base function to the caller\r\n        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);\r\n    });\r\n    // Get the base prototype functions\r\n    var baseProto = _getObjProto(classProto);\r\n    var visited = [];\r\n    // Don't include base object functions for Object, Array or Function\r\n    while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {\r\n        // look for prototype functions\r\n        _forEachProp(baseProto, function (name) {\r\n            // Don't include any dynamic prototype instances - as we only want the real functions\r\n            // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the \r\n            // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return\r\n            // the Object prototype methods while bypassing the check\r\n            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {\r\n                // Create an instance callback for passing the base function to the caller\r\n                baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);\r\n            }\r\n        });\r\n        // We need to find all possible functions that might be overloaded by walking the entire prototype chain\r\n        // This avoids the caller from needing to check whether it's direct base class implements the function or not\r\n        // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\r\n        visited.push(baseProto);\r\n        baseProto = _getObjProto(baseProto);\r\n    }\r\n    return baseFuncs;\r\n}\r\nfunction _getInstFunc(target, funcName, proto, currentDynProtoProxy) {\r\n    var instFunc = null;\r\n    // We need to check whether the class name is defined directly on this prototype otherwise\r\n    // it will walk the proto chain and return any parent proto classname.\r\n    if (target && _hasOwnProperty(proto, DynClassName)) {\r\n        var instFuncTable = target[DynInstFuncTable] || {};\r\n        instFunc = (instFuncTable[proto[DynClassName]] || {})[funcName];\r\n        if (!instFunc) {\r\n            // Avoid stack overflow from recursive calling the same function\r\n            _throwTypeError(\"Missing [\" + funcName + \"] \" + strFunction);\r\n        }\r\n        // We have the instance function, lets check it we can speed up further calls\r\n        // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)\r\n        if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {\r\n            // If the instance already has an instance function we can't replace it\r\n            var canAddInst = !_hasOwnProperty(target, funcName);\r\n            // Get current prototype\r\n            var objProto = _getObjProto(target);\r\n            var visited = [];\r\n            // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function\r\n            // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut\r\n            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {\r\n                var protoFunc = objProto[funcName];\r\n                if (protoFunc) {\r\n                    canAddInst = (protoFunc === currentDynProtoProxy);\r\n                    break;\r\n                }\r\n                // We need to find all possible initial functions to ensure that we don't bypass a valid override function\r\n                visited.push(objProto);\r\n                objProto = _getObjProto(objProto);\r\n            }\r\n            try {\r\n                if (canAddInst) {\r\n                    // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version\r\n                    // so it's safe to directly assign for any subsequent calls (for better performance)\r\n                    target[funcName] = instFunc;\r\n                }\r\n                // Block further attempts to set the instance function for any\r\n                instFunc[DynInstChkTag] = 1;\r\n            }\r\n            catch (e) {\r\n                // Don't crash if the object is readonly or the runtime doesn't allow changing this\r\n                // And set a flag so we don't try again for any function\r\n                instFuncTable[DynAllowInstChkTag] = false;\r\n            }\r\n        }\r\n    }\r\n    return instFunc;\r\n}\r\nfunction _getProtoFunc(funcName, proto, currentDynProtoProxy) {\r\n    var protoFunc = proto[funcName];\r\n    // Check that the prototype function is not a self reference -- try to avoid stack overflow!\r\n    if (protoFunc === currentDynProtoProxy) {\r\n        // It is so lookup the base prototype\r\n        protoFunc = _getObjProto(proto)[funcName];\r\n    }\r\n    if (typeof protoFunc !== strFunction) {\r\n        _throwTypeError(\"[\" + funcName + \"] is not a \" + strFunction);\r\n    }\r\n    return protoFunc;\r\n}\r\n/**\r\n * Add the required dynamic prototype methods to the the class prototype\r\n * @param proto - The class prototype\r\n * @param className - The instance classname\r\n * @param target - The target instance\r\n * @param baseInstFuncs - The base instance functions\r\n * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist\r\n * @ignore\r\n */\r\nfunction _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {\r\n    function _createDynamicPrototype(proto, funcName) {\r\n        var dynProtoProxy = function () {\r\n            // Use the instance or prototype function\r\n            var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);\r\n            // eslint-disable-next-line prefer-rest-params\r\n            return instFunc.apply(this, arguments);\r\n        };\r\n        // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing\r\n        // via which can dynamically replace the prototype function reference)\r\n        dynProtoProxy[DynProxyTag] = 1;\r\n        return dynProtoProxy;\r\n    }\r\n    if (!_isObjectOrArrayPrototype(proto)) {\r\n        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || {};\r\n        var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || {}); // fetch and assign if as it may not exist yet\r\n        // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable\r\n        if (instFuncTable[DynAllowInstChkTag] !== false) {\r\n            instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;\r\n        }\r\n        _forEachProp(target, function (name) {\r\n            // Only add overridden functions\r\n            if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {\r\n                // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function\r\n                instFuncs_1[name] = target[name];\r\n                delete target[name];\r\n                // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one\r\n                if (!_hasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {\r\n                    proto[name] = _createDynamicPrototype(proto, name);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance\r\n * @param classProto The class prototype instance\r\n * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy\r\n * @ignore\r\n */\r\nfunction _checkPrototype(classProto, thisTarget) {\r\n    // This method doesn't existing in older browsers (e.g. IE8)\r\n    if (_objGetPrototypeOf) {\r\n        // As this is primarily a coding time check, don't bother checking if running in IE8 or lower\r\n        var visited = [];\r\n        var thisProto = _getObjProto(thisTarget);\r\n        while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {\r\n            if (thisProto === classProto) {\r\n                return true;\r\n            }\r\n            // This avoids the caller from needing to check whether it's direct base class implements the function or not\r\n            // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\r\n            visited.push(thisProto);\r\n            thisProto = _getObjProto(thisProto);\r\n        }\r\n        return false;\r\n    }\r\n    // If objGetPrototypeOf doesn't exist then just assume everything is ok.\r\n    return true;\r\n}\r\n/**\r\n * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.\r\n * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.\r\n * @param target\r\n * @param unknownValue\r\n * @ignore\r\n */\r\nfunction _getObjName(target, unknownValue) {\r\n    if (_hasOwnProperty(target, Prototype)) {\r\n        // Look like a prototype\r\n        return target.name || unknownValue || UnknownValue;\r\n    }\r\n    return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;\r\n}\r\n/**\r\n * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-\r\n * - Saves references to all defined base class functions\r\n * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all \"super\" functions.\r\n * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.\r\n * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is\r\n * passed both the target \"this\" and an object that can be used to call any base (super) functions, using this based object in place of\r\n * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct \"this\"\r\n * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions\r\n * defined in the constructor or some other function (rather than declared as complete typescript functions).\r\n * ### Usage\r\n * ```typescript\r\n * import dynamicProto from \"@microsoft/dynamicproto-js\";\r\n * class ExampleClass extends BaseClass {\r\n *     constructor() {\r\n *         dynamicProto(ExampleClass, this, (_self, base) => {\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.newFunc = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     ...\r\n *                 }\r\n *             }\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.myFunction = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     // Call the base version of the function that we are overriding\r\n *                     base.myFunction();\r\n *                 }\r\n *                 ...\r\n *             }\r\n *             _self.initialize = () => {\r\n *                 ...\r\n *             }\r\n *             // Warnings: While the following will work as _self is simply a reference to\r\n *             // this, if anyone overrides myFunction() the overridden will be called first\r\n *             // as the normal JavaScript method resolution will occur and the defined\r\n *             // _self.initialize() function is actually gets removed from the instance and\r\n *             // a proxy prototype version is created to reference the created method.\r\n *             _self.initialize();\r\n *         });\r\n *     }\r\n * }\r\n * ```\r\n * @typeparam DPType This is the generic type of the class, used to keep intellisense valid\r\n * @typeparam DPCls The type that contains the prototype of the current class\r\n * @param theClass - This is the current class instance which contains the prototype for the current class\r\n * @param target - The current \"this\" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.\r\n * @param delegateFunc - The callback function (closure) that will create the dynamic function\r\n * @param options - Additional options to configure how the dynamic prototype operates\r\n */\r\nexport default function dynamicProto(theClass, target, delegateFunc, options) {\r\n    // Make sure that the passed theClass argument looks correct\r\n    if (!_hasOwnProperty(theClass, Prototype)) {\r\n        _throwTypeError(\"theClass is an invalid class definition.\");\r\n    }\r\n    // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)\r\n    var classProto = theClass[Prototype];\r\n    if (!_checkPrototype(classProto, target)) {\r\n        _throwTypeError(\"[\" + _getObjName(theClass) + \"] not in hierarchy of [\" + _getObjName(target) + \"]\");\r\n    }\r\n    var className = null;\r\n    if (_hasOwnProperty(classProto, DynClassName)) {\r\n        // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)\r\n        className = classProto[DynClassName];\r\n    }\r\n    else {\r\n        // As not all browser support name on the prototype creating a unique dynamic one if we have not already\r\n        // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance\r\n        // function table lookup.\r\n        className = DynClassNamePrefix + _getObjName(theClass, \"_\") + \"$\" + _gblInst.n;\r\n        _gblInst.n++;\r\n        classProto[DynClassName] = className;\r\n    }\r\n    var perfOptions = dynamicProto[DynProtoDefaultOptions];\r\n    var useBaseInst = !!perfOptions[strUseBaseInst];\r\n    if (useBaseInst && options && options[strUseBaseInst] !== undefined) {\r\n        useBaseInst = !!options[strUseBaseInst];\r\n    }\r\n    // Get the current instance functions\r\n    var instFuncs = _getInstanceFuncs(target);\r\n    // Get all of the functions for any base instance (before they are potentially overridden)\r\n    var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);\r\n    // Execute the delegate passing in both the current target \"this\" and \"base\" function references\r\n    // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support\r\n    delegateFunc(target, baseFuncs);\r\n    // Don't allow setting instance functions for older IE instances\r\n    var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];\r\n    if (setInstanceFunc && options) {\r\n        setInstanceFunc = !!options[strSetInstFuncs];\r\n    }\r\n    // Populate the Prototype for any overridden instance functions\r\n    _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);\r\n}\r\n/**\r\n * Exposes the default global options to allow global configuration, if the global values are disabled these will override\r\n * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose\r\n * their internal usage of dynamic proto.\r\n */\r\ndynamicProto[DynProtoDefaultOptions] = _gblInst.o;\r\n//# sourceMappingURL=DynamicProto.js.map"],"names":["result","UNDEFINED","Constructor","Prototype","strFunction","DynInstFuncTable","DynProxyTag","DynClassName","DynInstChkTag","DynAllowInstChkTag","DynProtoDefaultOptions","UnknownValue","str__Proto","DynProtoBaseProto","DynProtoGlobalSettings","DynProtoCurrent","strUseBaseInst","strSetInstFuncs","Obj","Object","_objGetPrototypeOf","_objGetOwnProps","_gbl","globalThis","self","window","global","_gblInst","o","_a","n","_hasOwnProperty","obj","prop","hasOwnProperty","call","_isObjectOrArrayPrototype","target","Array","_isObjectArrayOrFunctionPrototype","Function","_getObjProto","curProto","newProto","_forEachProp","func","props","name_1","push","length","lp","_isDynamicCandidate","funcName","skipOwn","_throwTypeError","message","TypeError","_hasVisited","values","value","_getObjName","unknownValue","name","dynamicProto","theClass","delegateFunc","options","thisTarget","instFuncs","proto","baseInstFuncs","instFuncs_1","classProto","className","visited","thisProto","perfOptions","useBaseInst","undefined","setInstanceFunc","_instFuncProxy","funcHost","instFuncTable","theFunc","apply","arguments","baseFuncs","baseProto","dynProtoProxy","protoFunc","currentDynProtoProxy","instFunc","canAddInst","objProto","e","this"],"mappings":"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"}