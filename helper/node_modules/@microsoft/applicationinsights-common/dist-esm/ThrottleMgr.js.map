{"version":3,"file":"ThrottleMgr.js.map","sources":["ThrottleMgr.js"],"sourcesContent":["import { _throwInternal, arrForEach, isNotNullOrUndefined, isNullOrUndefined, randomValue, safeGetLogger, strTrim } from \"@microsoft/applicationinsights-core-js\";\r\nimport { utlCanUseLocalStorage, utlGetLocalStorage, utlSetLocalStorage } from \"./StorageHelperFuncs\";\r\nimport { _DYN_COUNT, _DYN_DATE, _DYN_DISABLED, _DYN_GET_UTCDATE, _DYN_LENGTH, _DYN_MAX_TIMES_PER_MONTH, _DYN_MESSAGE, _DYN_PRE_TRIGGER_DATE, _DYN_STRINGIFY } from \"./__DynamicConstants\";\r\nvar THROTTLE_STORAGE_PREFIX = \"appInsightsThrottle\";\r\nvar ThrottleMgr = /** @class */ (function () {\r\n    function ThrottleMgr(throttleMgr, core, namePrefix) {\r\n        var _self = this;\r\n        var _canUseLocalStorage;\r\n        var _logger;\r\n        var _config;\r\n        var _localStorageName;\r\n        var _localStorageObj;\r\n        var _isTriggered; //_isTriggered is to make sure that we only trigger throttle once a day\r\n        var _namePrefix;\r\n        var _queue;\r\n        var _isReady = false;\r\n        _initConfig();\r\n        _self.getConfig = function () {\r\n            return _config;\r\n        };\r\n        /**\r\n         * Check if it is the correct day to send message.\r\n         * If _isTriggered is true, even if canThrottle returns true, message will not be sent,\r\n         * because we only allow triggering sendMessage() once a day.\r\n         * @returns if the current date is the valid date to send message\r\n         */\r\n        _self.canThrottle = function () {\r\n            return _canThrottle(_config, _canUseLocalStorage, _localStorageObj);\r\n        };\r\n        /**\r\n         * Check if throttle is triggered on current day(UTC)\r\n         * if canThrottle returns false, isTriggered will return false\r\n         * @returns if throttle is triggered on current day(UTC)\r\n         */\r\n        _self.isTriggered = function () {\r\n            return _isTriggered;\r\n        };\r\n        /**\r\n         * Before isReady set to true, all message will be stored in queue.\r\n         * Message will only be sent out after isReady set to true.\r\n         * Initial and default value: false\r\n         * @returns isReady state\r\n         */\r\n        _self.isReady = function () {\r\n            return _isReady;\r\n        };\r\n        /**\r\n         * Flush all message in queue with isReady state set to true.\r\n         * @returns if message queue is flushed\r\n         */\r\n        _self.flush = function () {\r\n            try {\r\n                if (_isReady && _queue[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    arrForEach(_queue, function (item) {\r\n                        _self.sendMessage(item.msgID, item[_DYN_MESSAGE /* @min:%2emessage */], item.severity);\r\n                    });\r\n                    return true;\r\n                }\r\n            }\r\n            catch (err) {\r\n                // eslint-disable-next-line no-empty\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Set isReady State\r\n         * if isReady set to true, message queue will be flushed automatically.\r\n         * @param isReady isReady State\r\n         * @returns if message queue is flushed\r\n         */\r\n        _self.onReadyState = function (isReady) {\r\n            _isReady = isNullOrUndefined(isReady) ? true : isReady;\r\n            return _self.flush();\r\n        };\r\n        _self.sendMessage = function (msgID, message, severity) {\r\n            if (_isReady) {\r\n                var isSampledIn = _canSampledIn();\r\n                if (!isSampledIn) {\r\n                    return;\r\n                }\r\n                var canThrottle = _canThrottle(_config, _canUseLocalStorage, _localStorageObj);\r\n                var throttled = false;\r\n                var number = 0;\r\n                try {\r\n                    if (canThrottle && !_isTriggered) {\r\n                        number = Math.min(_config.limit.maxSendNumber, _localStorageObj[_DYN_COUNT /* @min:%2ecount */] + 1);\r\n                        _localStorageObj[_DYN_COUNT /* @min:%2ecount */] = 0;\r\n                        throttled = true;\r\n                        _isTriggered = true;\r\n                        _localStorageObj[_DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */] = new Date();\r\n                    }\r\n                    else {\r\n                        _isTriggered = canThrottle;\r\n                        _localStorageObj[_DYN_COUNT /* @min:%2ecount */] += 1;\r\n                    }\r\n                    _resetLocalStorage(_logger, _localStorageName, _localStorageObj);\r\n                    for (var i = 0; i < number; i++) {\r\n                        _sendMessage(msgID, _logger, message, severity);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n                return {\r\n                    isThrottled: throttled,\r\n                    throttleNum: number\r\n                };\r\n            }\r\n            else {\r\n                _queue.push({\r\n                    msgID: msgID,\r\n                    message: message,\r\n                    severity: severity\r\n                });\r\n            }\r\n            return null;\r\n        };\r\n        function _initConfig() {\r\n            var _a, _b, _c, _d, _e;\r\n            _canUseLocalStorage = utlCanUseLocalStorage();\r\n            _logger = safeGetLogger(core);\r\n            _isTriggered = false;\r\n            _namePrefix = isNotNullOrUndefined(namePrefix) ? namePrefix : \"\";\r\n            _queue = [];\r\n            var configMgr = throttleMgr;\r\n            _config = {};\r\n            _config[_DYN_DISABLED /* @min:%2edisabled */] = !!configMgr[_DYN_DISABLED /* @min:%2edisabled */];\r\n            _config.msgKey = configMgr.msgKey;\r\n            // default: send data on 28th every 3 month each year\r\n            var interval = {\r\n                // dafault: sent every three months\r\n                monthInterval: ((_a = configMgr.interval) === null || _a === void 0 ? void 0 : _a.monthInterval) || 3,\r\n                dayInterval: ((_b = configMgr.interval) === null || _b === void 0 ? void 0 : _b.dayInterval) || 28,\r\n                maxTimesPerMonth: ((_c = configMgr.interval) === null || _c === void 0 ? void 0 : _c.maxTimesPerMonth) || 1\r\n            };\r\n            _config.interval = interval;\r\n            var limit = {\r\n                samplingRate: ((_d = configMgr.limit) === null || _d === void 0 ? void 0 : _d.samplingRate) || 100,\r\n                // dafault: every time sent only 1 event\r\n                maxSendNumber: ((_e = configMgr.limit) === null || _e === void 0 ? void 0 : _e.maxSendNumber) || 1\r\n            };\r\n            _config.limit = limit;\r\n            _localStorageName = _getLocalStorageName(_config.msgKey, _namePrefix);\r\n            if (_canUseLocalStorage && _localStorageName) {\r\n                _localStorageObj = _getLocalStorageObj(utlGetLocalStorage(_logger, _localStorageName), _logger, _localStorageName);\r\n            }\r\n            if (_localStorageObj) {\r\n                _isTriggered = _isTriggeredOnCurDate(_localStorageObj[_DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */]);\r\n            }\r\n        }\r\n        function _canThrottle(config, canUseLocalStorage, localStorageObj) {\r\n            if (!config[_DYN_DISABLED /* @min:%2edisabled */] && canUseLocalStorage && isNotNullOrUndefined(localStorageObj)) {\r\n                var curDate = _getThrottleDate();\r\n                var date = localStorageObj[_DYN_DATE /* @min:%2edate */];\r\n                var interval = config.interval;\r\n                var monthExpand = (curDate.getUTCFullYear() - date.getUTCFullYear()) * 12 + curDate.getUTCMonth() - date.getUTCMonth();\r\n                var monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);\r\n                var dayCheck = _checkInterval(interval.dayInterval, 0, curDate[_DYN_GET_UTCDATE /* @min:%2egetUTCDate */]()) - 1;\r\n                return monthCheck >= 0 && dayCheck >= 0 && dayCheck <= config.interval[_DYN_MAX_TIMES_PER_MONTH /* @min:%2emaxTimesPerMonth */];\r\n            }\r\n            return false;\r\n        }\r\n        function _getLocalStorageName(msgKey, prefix) {\r\n            var fix = isNotNullOrUndefined(prefix) ? prefix : \"\";\r\n            if (msgKey) {\r\n                return THROTTLE_STORAGE_PREFIX + fix + \"-\" + msgKey;\r\n            }\r\n            return null;\r\n        }\r\n        // returns if throttle is triggered on current Date\r\n        function _isTriggeredOnCurDate(preTriggerDate) {\r\n            try {\r\n                if (preTriggerDate) {\r\n                    var curDate = new Date();\r\n                    return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() &&\r\n                        preTriggerDate.getUTCMonth() === curDate.getUTCMonth() &&\r\n                        preTriggerDate[_DYN_GET_UTCDATE /* @min:%2egetUTCDate */]() === curDate[_DYN_GET_UTCDATE /* @min:%2egetUTCDate */]();\r\n                }\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-empty\r\n            }\r\n            return false;\r\n        }\r\n        // transfer local storage string value to object that identifies start date, current count and preTriggerDate\r\n        function _getLocalStorageObj(value, logger, storageName) {\r\n            try {\r\n                var storageObj = {\r\n                    date: _getThrottleDate(),\r\n                    count: 0\r\n                };\r\n                if (value) {\r\n                    var obj = JSON.parse(value);\r\n                    return {\r\n                        date: _getThrottleDate(obj[_DYN_DATE /* @min:%2edate */]) || storageObj[_DYN_DATE /* @min:%2edate */],\r\n                        count: obj[_DYN_COUNT /* @min:%2ecount */] || storageObj[_DYN_COUNT /* @min:%2ecount */],\r\n                        preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */]) : undefined\r\n                    };\r\n                }\r\n                else {\r\n                    _resetLocalStorage(logger, storageName, storageObj);\r\n                    return storageObj;\r\n                }\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-empty\r\n            }\r\n            return null;\r\n        }\r\n        // if datestr is not defined, current date will be returned\r\n        function _getThrottleDate(dateStr) {\r\n            // if new Date() can't be created through the provided dateStr, null will be returned.\r\n            try {\r\n                if (dateStr) {\r\n                    var date = new Date(dateStr);\r\n                    //make sure it is a valid Date Object\r\n                    if (!isNaN(date.getDate())) {\r\n                        return date;\r\n                    }\r\n                }\r\n                else {\r\n                    return new Date();\r\n                }\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-empty\r\n            }\r\n            return null;\r\n        }\r\n        function _resetLocalStorage(logger, storageName, obj) {\r\n            try {\r\n                return utlSetLocalStorage(logger, storageName, strTrim(JSON[_DYN_STRINGIFY /* @min:%2estringify */](obj)));\r\n            }\r\n            catch (e) {\r\n                //     // eslint-disable-next-line no-empty\r\n            }\r\n            return false;\r\n        }\r\n        function _checkInterval(interval, start, current) {\r\n            // count from start year\r\n            return (current >= start) && (current - start) % interval == 0 ? Math.floor((current - start) / interval) + 1 : -1;\r\n        }\r\n        function _sendMessage(msgID, logger, message, severity) {\r\n            _throwInternal(logger, severity || 1 /* eLoggingSeverity.CRITICAL */, msgID, message);\r\n        }\r\n        // NOTE: config.limit.samplingRate is set to 4 decimal places,\r\n        // so config.limit.samplingRate = 1 means 0.0001%\r\n        function _canSampledIn() {\r\n            return randomValue(1000000) <= _config.limit.samplingRate;\r\n        }\r\n    }\r\n    return ThrottleMgr;\r\n}());\r\nexport { ThrottleMgr };\r\n//# sourceMappingURL=ThrottleMgr.js.map"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}