{"version":3,"file":"Exception.js.map","sources":["Exception.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { __assign } from \"tslib\";\r\nimport { arrForEach, arrMap, isArray, isError, isFunction, isNullOrUndefined, isObject, isString, strTrim } from \"@microsoft/applicationinsights-core-js\";\r\nimport { strNotSpecified } from \"../Constants\";\r\nimport { _DYN_ASSEMBLY, _DYN_EXCEPTIONS, _DYN_FILE_NAME, _DYN_HAS_FULL_STACK, _DYN_INDEX_OF, _DYN_IS_MANUAL, _DYN_LENGTH, _DYN_LEVEL, _DYN_LINE, _DYN_MEASUREMENTS, _DYN_MESSAGE, _DYN_METHOD, _DYN_NAME, _DYN_PARSED_STACK, _DYN_PROBLEM_GROUP, _DYN_PROPERTIES, _DYN_SEVERITY_LEVEL, _DYN_SIZE_IN_BYTES, _DYN_SPLIT, _DYN_STRINGIFY, _DYN_TO_STRING, _DYN_TYPE_NAME, _DYN__CREATE_FROM_INTERFA1 } from \"../__DynamicConstants\";\r\nimport { dataSanitizeException, dataSanitizeMeasurements, dataSanitizeMessage, dataSanitizeProperties, dataSanitizeString } from \"./Common/DataSanitizer\";\r\nvar NoMethod = \"<no_method>\";\r\nvar strError = \"error\";\r\nvar strStack = \"stack\";\r\nvar strStackDetails = \"stackDetails\";\r\nvar strErrorSrc = \"errorSrc\";\r\nvar strMessage = \"message\";\r\nvar strDescription = \"description\";\r\nfunction _stringify(value, convertToString) {\r\n    var result = value;\r\n    if (result && !isString(result)) {\r\n        if (JSON && JSON[_DYN_STRINGIFY /* @min:%2estringify */]) {\r\n            result = JSON[_DYN_STRINGIFY /* @min:%2estringify */](value);\r\n            if (convertToString && (!result || result === \"{}\")) {\r\n                if (isFunction(value[_DYN_TO_STRING /* @min:%2etoString */])) {\r\n                    result = value[_DYN_TO_STRING /* @min:%2etoString */]();\r\n                }\r\n                else {\r\n                    result = \"\" + value;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result = \"\" + value + \" - (Missing JSON.stringify)\";\r\n        }\r\n    }\r\n    return result || \"\";\r\n}\r\nfunction _formatMessage(theEvent, errorType) {\r\n    var evtMessage = theEvent;\r\n    if (theEvent) {\r\n        if (evtMessage && !isString(evtMessage)) {\r\n            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;\r\n        }\r\n        // Make sure the message is a string\r\n        if (evtMessage && !isString(evtMessage)) {\r\n            // tslint:disable-next-line: prefer-conditional-expression\r\n            evtMessage = _stringify(evtMessage, true);\r\n        }\r\n        if (theEvent[\"filename\"]) {\r\n            // Looks like an event object with filename\r\n            evtMessage = evtMessage + \" @\" + (theEvent[\"filename\"] || \"\") + \":\" + (theEvent[\"lineno\"] || \"?\") + \":\" + (theEvent[\"colno\"] || \"?\");\r\n        }\r\n    }\r\n    // Automatically add the error type to the message if it does already appear to be present\r\n    if (errorType && errorType !== \"String\" && errorType !== \"Object\" && errorType !== \"Error\" && (evtMessage || \"\")[_DYN_INDEX_OF /* @min:%2eindexOf */](errorType) === -1) {\r\n        evtMessage = errorType + \": \" + evtMessage;\r\n    }\r\n    return evtMessage || \"\";\r\n}\r\nfunction _isExceptionDetailsInternal(value) {\r\n    try {\r\n        if (isObject(value)) {\r\n            return \"hasFullStack\" in value && \"typeName\" in value;\r\n        }\r\n    }\r\n    catch (e) {\r\n        // This can happen with some native browser objects, but should not happen for the type we are checking for\r\n    }\r\n    return false;\r\n}\r\nfunction _isExceptionInternal(value) {\r\n    try {\r\n        if (isObject(value)) {\r\n            return (\"ver\" in value && \"exceptions\" in value && \"properties\" in value);\r\n        }\r\n    }\r\n    catch (e) {\r\n        // This can happen with some native browser objects, but should not happen for the type we are checking for\r\n    }\r\n    return false;\r\n}\r\nfunction _isStackDetails(details) {\r\n    return details && details.src && isString(details.src) && details.obj && isArray(details.obj);\r\n}\r\nfunction _convertStackObj(errorStack) {\r\n    var src = errorStack || \"\";\r\n    if (!isString(src)) {\r\n        if (isString(src[strStack])) {\r\n            src = src[strStack];\r\n        }\r\n        else {\r\n            src = \"\" + src;\r\n        }\r\n    }\r\n    var items = src[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\r\n    return {\r\n        src: src,\r\n        obj: items\r\n    };\r\n}\r\nfunction _getOperaStack(errorMessage) {\r\n    var stack = [];\r\n    var lines = errorMessage[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\r\n    for (var lp = 0; lp < lines[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n        var entry = lines[lp];\r\n        if (lines[lp + 1]) {\r\n            entry += \"@\" + lines[lp + 1];\r\n            lp++;\r\n        }\r\n        stack.push(entry);\r\n    }\r\n    return {\r\n        src: errorMessage,\r\n        obj: stack\r\n    };\r\n}\r\nfunction _getStackFromErrorObj(errorObj) {\r\n    var details = null;\r\n    if (errorObj) {\r\n        try {\r\n            /* Using bracket notation is support older browsers (IE 7/8 -- dont remember the version) that throw when using dot\r\n            notation for undefined objects and we don't want to loose the error from being reported */\r\n            if (errorObj[strStack]) {\r\n                // Chrome/Firefox\r\n                details = _convertStackObj(errorObj[strStack]);\r\n            }\r\n            else if (errorObj[strError] && errorObj[strError][strStack]) {\r\n                // Edge error event provides the stack and error object\r\n                details = _convertStackObj(errorObj[strError][strStack]);\r\n            }\r\n            else if (errorObj[\"exception\"] && errorObj.exception[strStack]) {\r\n                details = _convertStackObj(errorObj.exception[strStack]);\r\n            }\r\n            else if (_isStackDetails(errorObj)) {\r\n                details = errorObj;\r\n            }\r\n            else if (_isStackDetails(errorObj[strStackDetails])) {\r\n                details = errorObj[strStackDetails];\r\n            }\r\n            else if (window && window[\"opera\"] && errorObj[strMessage]) {\r\n                // Opera\r\n                details = _getOperaStack(errorObj[_DYN_MESSAGE /* @min:%2emessage */]);\r\n            }\r\n            else if (errorObj[\"reason\"] && errorObj.reason[strStack]) {\r\n                // UnhandledPromiseRejection\r\n                details = _convertStackObj(errorObj.reason[strStack]);\r\n            }\r\n            else if (isString(errorObj)) {\r\n                details = _convertStackObj(errorObj);\r\n            }\r\n            else {\r\n                var evtMessage = errorObj[strMessage] || errorObj[strDescription] || \"\";\r\n                if (isString(errorObj[strErrorSrc])) {\r\n                    if (evtMessage) {\r\n                        evtMessage += \"\\n\";\r\n                    }\r\n                    evtMessage += \" from \" + errorObj[strErrorSrc];\r\n                }\r\n                if (evtMessage) {\r\n                    details = _convertStackObj(evtMessage);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // something unexpected happened so to avoid failing to report any error lets swallow the exception\r\n            // and fallback to the callee/caller method\r\n            details = _convertStackObj(e);\r\n        }\r\n    }\r\n    return details || {\r\n        src: \"\",\r\n        obj: null\r\n    };\r\n}\r\nfunction _formatStackTrace(stackDetails) {\r\n    var stack = \"\";\r\n    if (stackDetails) {\r\n        if (stackDetails.obj) {\r\n            arrForEach(stackDetails.obj, function (entry) {\r\n                stack += entry + \"\\n\";\r\n            });\r\n        }\r\n        else {\r\n            stack = stackDetails.src || \"\";\r\n        }\r\n    }\r\n    return stack;\r\n}\r\nfunction _parseStack(stack) {\r\n    var parsedStack;\r\n    var frames = stack.obj;\r\n    if (frames && frames[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n        parsedStack = [];\r\n        var level_1 = 0;\r\n        var totalSizeInBytes_1 = 0;\r\n        arrForEach(frames, function (frame) {\r\n            var theFrame = frame[_DYN_TO_STRING /* @min:%2etoString */]();\r\n            if (_StackFrame.regex.test(theFrame)) {\r\n                var parsedFrame = new _StackFrame(theFrame, level_1++);\r\n                totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                parsedStack.push(parsedFrame);\r\n            }\r\n        });\r\n        // DP Constraint - exception parsed stack must be < 32KB\r\n        // remove frames from the middle to meet the threshold\r\n        var exceptionParsedStackThreshold = 32 * 1024;\r\n        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {\r\n            var left = 0;\r\n            var right = parsedStack[_DYN_LENGTH /* @min:%2elength */] - 1;\r\n            var size = 0;\r\n            var acceptedLeft = left;\r\n            var acceptedRight = right;\r\n            while (left < right) {\r\n                // check size\r\n                var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                size += lSize + rSize;\r\n                if (size > exceptionParsedStackThreshold) {\r\n                    // remove extra frames from the middle\r\n                    var howMany = acceptedRight - acceptedLeft + 1;\r\n                    parsedStack.splice(acceptedLeft, howMany);\r\n                    break;\r\n                }\r\n                // update pointers\r\n                acceptedLeft = left;\r\n                acceptedRight = right;\r\n                left++;\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n    return parsedStack;\r\n}\r\nfunction _getErrorType(errorType) {\r\n    // Gets the Error Type by passing the constructor (used to get the true type of native error object).\r\n    var typeName = \"\";\r\n    if (errorType) {\r\n        typeName = errorType.typeName || errorType[_DYN_NAME /* @min:%2ename */] || \"\";\r\n        if (!typeName) {\r\n            try {\r\n                var funcNameRegex = /function (.{1,200})\\(/;\r\n                var results = (funcNameRegex).exec((errorType).constructor[_DYN_TO_STRING /* @min:%2etoString */]());\r\n                typeName = (results && results[_DYN_LENGTH /* @min:%2elength */] > 1) ? results[1] : \"\";\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\r\n            }\r\n        }\r\n    }\r\n    return typeName;\r\n}\r\n/**\r\n * Formats the provided errorObj for display and reporting, it may be a String, Object, integer or undefined depending on the browser.\r\n * @param errorObj The supplied errorObj\r\n */\r\nexport function _formatErrorCode(errorObj) {\r\n    if (errorObj) {\r\n        try {\r\n            if (!isString(errorObj)) {\r\n                var errorType = _getErrorType(errorObj);\r\n                var result = _stringify(errorObj, false);\r\n                if (!result || result === \"{}\") {\r\n                    if (errorObj[strError]) {\r\n                        // Looks like an MS Error Event\r\n                        errorObj = errorObj[strError];\r\n                        errorType = _getErrorType(errorObj);\r\n                    }\r\n                    result = _stringify(errorObj, true);\r\n                }\r\n                if (result[_DYN_INDEX_OF /* @min:%2eindexOf */](errorType) !== 0 && errorType !== \"String\") {\r\n                    return errorType + \":\" + result;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\r\n        }\r\n    }\r\n    // Fallback to just letting the object format itself into a string\r\n    return \"\" + (errorObj || \"\");\r\n}\r\nvar Exception = /** @class */ (function () {\r\n    /**\r\n     * Constructs a new instance of the ExceptionTelemetry object\r\n     */\r\n    function Exception(logger, exception, properties, measurements, severityLevel, id) {\r\n        this.aiDataContract = {\r\n            ver: 1 /* FieldType.Required */,\r\n            exceptions: 1 /* FieldType.Required */,\r\n            severityLevel: 0 /* FieldType.Default */,\r\n            properties: 0 /* FieldType.Default */,\r\n            measurements: 0 /* FieldType.Default */\r\n        };\r\n        var _self = this;\r\n        _self.ver = 2; // TODO: handle the CS\"4.0\" ==> breeze 2 conversion in a better way\r\n        if (!_isExceptionInternal(exception)) {\r\n            if (!properties) {\r\n                properties = {};\r\n            }\r\n            _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = [new _ExceptionDetails(logger, exception, properties)];\r\n            _self[_DYN_PROPERTIES /* @min:%2eproperties */] = dataSanitizeProperties(logger, properties);\r\n            _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = dataSanitizeMeasurements(logger, measurements);\r\n            if (severityLevel) {\r\n                _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;\r\n            }\r\n            if (id) {\r\n                _self.id = id;\r\n            }\r\n        }\r\n        else {\r\n            _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */] || [];\r\n            _self[_DYN_PROPERTIES /* @min:%2eproperties */] = exception[_DYN_PROPERTIES /* @min:%2eproperties */];\r\n            _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = exception[_DYN_MEASUREMENTS /* @min:%2emeasurements */];\r\n            if (exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */]) {\r\n                _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */];\r\n            }\r\n            if (exception.id) {\r\n                _self.id = exception.id;\r\n            }\r\n            if (exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */]) {\r\n                _self[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */] = exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */];\r\n            }\r\n            // bool/int types, use isNullOrUndefined\r\n            if (!isNullOrUndefined(exception[_DYN_IS_MANUAL /* @min:%2eisManual */])) {\r\n                _self[_DYN_IS_MANUAL /* @min:%2eisManual */] = exception[_DYN_IS_MANUAL /* @min:%2eisManual */];\r\n            }\r\n        }\r\n    }\r\n    Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {\r\n        var _a;\r\n        var errorType = _getErrorType(error || evt || message);\r\n        return _a = {},\r\n            _a[_DYN_MESSAGE /* @min:message */] = _formatMessage(message, errorType),\r\n            _a.url = url,\r\n            _a.lineNumber = lineNumber,\r\n            _a.columnNumber = columnNumber,\r\n            _a.error = _formatErrorCode(error || evt || message),\r\n            _a.evt = _formatErrorCode(evt || message),\r\n            _a[_DYN_TYPE_NAME /* @min:typeName */] = errorType,\r\n            _a.stackDetails = _getStackFromErrorObj(stack || error || evt),\r\n            _a.errorSrc = errorSrc,\r\n            _a;\r\n    };\r\n    Exception.CreateFromInterface = function (logger, exception, properties, measurements) {\r\n        var exceptions = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */]\r\n            && arrMap(exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */], function (ex) { return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](logger, ex); });\r\n        var exceptionData = new Exception(logger, __assign(__assign({}, exception), { exceptions: exceptions }), properties, measurements);\r\n        return exceptionData;\r\n    };\r\n    Exception.prototype.toInterface = function () {\r\n        var _a;\r\n        var _b = this, exceptions = _b.exceptions, properties = _b.properties, measurements = _b.measurements, severityLevel = _b.severityLevel, problemGroup = _b.problemGroup, id = _b.id, isManual = _b.isManual;\r\n        var exceptionDetailsInterface = exceptions instanceof Array\r\n            && arrMap(exceptions, function (exception) { return exception.toInterface(); })\r\n            || undefined;\r\n        return _a = {\r\n                ver: \"4.0\"\r\n            },\r\n            _a[_DYN_EXCEPTIONS /* @min:exceptions */] = exceptionDetailsInterface,\r\n            _a.severityLevel = severityLevel,\r\n            _a.properties = properties,\r\n            _a.measurements = measurements,\r\n            _a.problemGroup = problemGroup,\r\n            _a.id = id,\r\n            _a.isManual = isManual,\r\n            _a;\r\n    };\r\n    /**\r\n     * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.\r\n     */\r\n    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {\r\n        var _a;\r\n        return {\r\n            exceptions: [\r\n                (_a = {},\r\n                    _a[_DYN_HAS_FULL_STACK /* @min:hasFullStack */] = true,\r\n                    _a.message = message,\r\n                    _a.stack = details,\r\n                    _a.typeName = typeName,\r\n                    _a)\r\n            ]\r\n        };\r\n    };\r\n    Exception.envelopeType = \"Microsoft.ApplicationInsights.{0}.Exception\";\r\n    Exception.dataType = \"ExceptionData\";\r\n    Exception.formatError = _formatErrorCode;\r\n    return Exception;\r\n}());\r\nexport { Exception };\r\nvar _ExceptionDetails = /** @class */ (function () {\r\n    function _ExceptionDetails(logger, exception, properties) {\r\n        this.aiDataContract = {\r\n            id: 0 /* FieldType.Default */,\r\n            outerId: 0 /* FieldType.Default */,\r\n            typeName: 1 /* FieldType.Required */,\r\n            message: 1 /* FieldType.Required */,\r\n            hasFullStack: 0 /* FieldType.Default */,\r\n            stack: 0 /* FieldType.Default */,\r\n            parsedStack: 2 /* FieldType.Array */\r\n        };\r\n        var _self = this;\r\n        if (!_isExceptionDetailsInternal(exception)) {\r\n            var error = exception;\r\n            var evt = error && error.evt;\r\n            if (!isError(error)) {\r\n                error = error[strError] || evt || error;\r\n            }\r\n            _self[_DYN_TYPE_NAME /* @min:%2etypeName */] = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified;\r\n            _self[_DYN_MESSAGE /* @min:%2emessage */] = dataSanitizeMessage(logger, _formatMessage(exception || error, _self[_DYN_TYPE_NAME /* @min:%2etypeName */])) || strNotSpecified;\r\n            var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);\r\n            _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] = _parseStack(stack);\r\n            _self[strStack] = dataSanitizeException(logger, _formatStackTrace(stack));\r\n            _self.hasFullStack = isArray(_self.parsedStack) && _self.parsedStack[_DYN_LENGTH /* @min:%2elength */] > 0;\r\n            if (properties) {\r\n                properties[_DYN_TYPE_NAME /* @min:%2etypeName */] = properties[_DYN_TYPE_NAME /* @min:%2etypeName */] || _self[_DYN_TYPE_NAME /* @min:%2etypeName */];\r\n            }\r\n        }\r\n        else {\r\n            _self[_DYN_TYPE_NAME /* @min:%2etypeName */] = exception[_DYN_TYPE_NAME /* @min:%2etypeName */];\r\n            _self[_DYN_MESSAGE /* @min:%2emessage */] = exception[_DYN_MESSAGE /* @min:%2emessage */];\r\n            _self[strStack] = exception[strStack];\r\n            _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] = exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */] || [];\r\n            _self[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */] = exception[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */];\r\n        }\r\n    }\r\n    _ExceptionDetails.prototype.toInterface = function () {\r\n        var _a;\r\n        var _self = this;\r\n        var parsedStack = _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array\r\n            && arrMap(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return frame.toInterface(); });\r\n        var exceptionDetailsInterface = (_a = {\r\n                id: _self.id,\r\n                outerId: _self.outerId,\r\n                typeName: _self[_DYN_TYPE_NAME /* @min:%2etypeName */],\r\n                message: _self[_DYN_MESSAGE /* @min:%2emessage */],\r\n                hasFullStack: _self[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */],\r\n                stack: _self[strStack]\r\n            },\r\n            _a[_DYN_PARSED_STACK /* @min:parsedStack */] = parsedStack || undefined,\r\n            _a);\r\n        return exceptionDetailsInterface;\r\n    };\r\n    _ExceptionDetails.CreateFromInterface = function (logger, exception) {\r\n        var parsedStack = (exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array\r\n            && arrMap(exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return _StackFrame[_DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](frame); }))\r\n            || exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */];\r\n        var exceptionDetails = new _ExceptionDetails(logger, __assign(__assign({}, exception), { parsedStack: parsedStack }));\r\n        return exceptionDetails;\r\n    };\r\n    return _ExceptionDetails;\r\n}());\r\nexport { _ExceptionDetails };\r\nvar _StackFrame = /** @class */ (function () {\r\n    function _StackFrame(sourceFrame, level) {\r\n        this.aiDataContract = {\r\n            level: 1 /* FieldType.Required */,\r\n            method: 1 /* FieldType.Required */,\r\n            assembly: 0 /* FieldType.Default */,\r\n            fileName: 0 /* FieldType.Default */,\r\n            line: 0 /* FieldType.Default */\r\n        };\r\n        var _self = this;\r\n        _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;\r\n        // Not converting this to isString() as typescript uses this logic to \"understand\" the different\r\n        // types for the 2 different code paths\r\n        if (typeof sourceFrame === \"string\") {\r\n            var frame = sourceFrame;\r\n            _self[_DYN_LEVEL /* @min:%2elevel */] = level;\r\n            _self[_DYN_METHOD /* @min:%2emethod */] = NoMethod;\r\n            _self[_DYN_ASSEMBLY /* @min:%2eassembly */] = strTrim(frame);\r\n            _self[_DYN_FILE_NAME /* @min:%2efileName */] = \"\";\r\n            _self[_DYN_LINE /* @min:%2eline */] = 0;\r\n            var matches = frame.match(_StackFrame.regex);\r\n            if (matches && matches[_DYN_LENGTH /* @min:%2elength */] >= 5) {\r\n                _self[_DYN_METHOD /* @min:%2emethod */] = strTrim(matches[2]) || _self[_DYN_METHOD /* @min:%2emethod */];\r\n                _self[_DYN_FILE_NAME /* @min:%2efileName */] = strTrim(matches[4]);\r\n                _self[_DYN_LINE /* @min:%2eline */] = parseInt(matches[5]) || 0;\r\n            }\r\n        }\r\n        else {\r\n            _self[_DYN_LEVEL /* @min:%2elevel */] = sourceFrame[_DYN_LEVEL /* @min:%2elevel */];\r\n            _self[_DYN_METHOD /* @min:%2emethod */] = sourceFrame[_DYN_METHOD /* @min:%2emethod */];\r\n            _self[_DYN_ASSEMBLY /* @min:%2eassembly */] = sourceFrame[_DYN_ASSEMBLY /* @min:%2eassembly */];\r\n            _self[_DYN_FILE_NAME /* @min:%2efileName */] = sourceFrame[_DYN_FILE_NAME /* @min:%2efileName */];\r\n            _self[_DYN_LINE /* @min:%2eline */] = sourceFrame[_DYN_LINE /* @min:%2eline */];\r\n            _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;\r\n        }\r\n        _self.sizeInBytes += _self.method[_DYN_LENGTH /* @min:%2elength */];\r\n        _self.sizeInBytes += _self.fileName[_DYN_LENGTH /* @min:%2elength */];\r\n        _self.sizeInBytes += _self.assembly[_DYN_LENGTH /* @min:%2elength */];\r\n        // todo: these might need to be removed depending on how the back-end settles on their size calculation\r\n        _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] += _StackFrame.baseSize;\r\n        _self.sizeInBytes += _self.level.toString()[_DYN_LENGTH /* @min:%2elength */];\r\n        _self.sizeInBytes += _self.line.toString()[_DYN_LENGTH /* @min:%2elength */];\r\n    }\r\n    _StackFrame.CreateFromInterface = function (frame) {\r\n        return new _StackFrame(frame, null /* level is available in frame interface */);\r\n    };\r\n    _StackFrame.prototype.toInterface = function () {\r\n        var _self = this;\r\n        return {\r\n            level: _self[_DYN_LEVEL /* @min:%2elevel */],\r\n            method: _self[_DYN_METHOD /* @min:%2emethod */],\r\n            assembly: _self[_DYN_ASSEMBLY /* @min:%2eassembly */],\r\n            fileName: _self[_DYN_FILE_NAME /* @min:%2efileName */],\r\n            line: _self[_DYN_LINE /* @min:%2eline */]\r\n        };\r\n    };\r\n    // regex to match stack frames from ie/chrome/ff\r\n    // methodName=$2, fileName=$4, lineNo=$5, column=$6\r\n    _StackFrame.regex = /^([\\s]+at)?[\\s]{0,50}([^\\@\\()]+?)[\\s]{0,50}(\\@|\\()([^\\(\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\r\n    _StackFrame.baseSize = 58; // '{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\r\n    return _StackFrame;\r\n}());\r\nexport { _StackFrame };\r\n//# sourceMappingURL=Exception.js.map"],"names":[],"mappings":";;;;AAA4D;AAC1B;AAClC,8EAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}