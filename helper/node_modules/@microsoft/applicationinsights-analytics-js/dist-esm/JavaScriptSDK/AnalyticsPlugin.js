/*
 * Application Insights JavaScript SDK - Web Analytics, 2.8.9
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
/**
* ApplicationInsights.ts
* @copyright Microsoft 2018
*/
import { __assignFn as __assign, __extendsFn as __extends } from "@microsoft/applicationinsights-shims";
import dynamicProto from "@microsoft/dynamicproto-js";
import { AnalyticsPluginIdentifier, Event as EventTelemetry, Exception, Metric, PageView, PageViewPerformance, PropertiesPluginIdentifier, RemoteDependencyData, Trace, createDistributedTraceContextFromTrace, createDomEvent, createTelemetryItem, dataSanitizeString, isCrossOriginError, strNotSpecified, stringToBoolOrDefault, utlDisableStorage, utlEnableStorage } from "@microsoft/applicationinsights-common";
import { BaseTelemetryPlugin, InstrumentEvent, arrForEach, createProcessTelemetryContext, createUniqueNamespace, dumpObj, eventOff, eventOn, generateW3CId, getDocument, getExceptionName, getHistory, getLocation, getWindow, hasHistory, hasWindow, isFunction, isNullOrUndefined, isString, isUndefined, mergeEvtNamespace, objDefineAccessors, objForEachKey, safeGetCookieMgr, strUndefined, throwError } from "@microsoft/applicationinsights-core-js";
import { _DYN_ADD_TELEMETRY_INITIA15, _DYN_AUTO_TRACK_PAGE_VISI1, _DYN_COLUMN_NUMBER, _DYN_CORE, _DYN_DATA_TYPE, _DYN_DIAG_LOG, _DYN_DISABLE_EXCEPTION_TR0, _DYN_DISABLE_FLUSH_ON_BEF7, _DYN_ENABLE_AUTO_ROUTE_TR6, _DYN_ENABLE_UNHANDLED_PRO3, _DYN_ENVELOPE_TYPE, _DYN_ERROR, _DYN_ERROR_SRC, _DYN_EXCEPTION, _DYN_HREF, _DYN_IS_BROWSER_LINK_TRAC5, _DYN_IS_STORAGE_USE_DISAB4, _DYN_LENGTH, _DYN_LINE_NUMBER, _DYN_MESSAGE, _DYN_NAME_PREFIX, _DYN_OVERRIDE_PAGE_VIEW_D2, _DYN_POPULATE_PAGE_VIEW_P12, _DYN_SAMPLING_PERCENTAGE, _DYN_SEND_EXCEPTION_INTER13, _DYN_SEND_PAGE_VIEW_INTER10, _DYN_SEND_PAGE_VIEW_PERFO11, _DYN_TO_STRING, _DYN_TRACK, _DYN_TRACK_PAGE_VIEW, _DYN_TRACK_PREVIOUS_PAGE_9, _DYN__CREATE_AUTO_EXCEPTI14, _DYN__ONERROR } from "../__DynamicConstants";
import { PageViewManager } from "./Telemetry/PageViewManager";
import { PageViewPerformanceManager } from "./Telemetry/PageViewPerformanceManager";
import { PageVisitTimeManager } from "./Telemetry/PageVisitTimeManager";
import { Timing } from "./Timing";
var strEvent = "event";
function _dispatchEvent(target, evnt) {
    if (target && target.dispatchEvent && evnt) {
        target.dispatchEvent(evnt);
    }
}
function _getReason(error) {
    if (error && error.reason) {
        var reason = error.reason;
        if (!isString(reason) && isFunction(reason[_DYN_TO_STRING /* @min:%2etoString */])) {
            return reason[_DYN_TO_STRING /* @min:%2etoString */]();
        }
        return dumpObj(reason);
    }
    // Pass the original object down which will eventually get evaluated for any message or description
    return error || "";
}
var MinMilliSeconds = 60000;
function _configMilliseconds(value, defValue) {
    value = value || defValue;
    if (value < MinMilliSeconds) {
        value = MinMilliSeconds;
    }
    return value;
}
function _getDefaultConfig(config) {
    if (!config) {
        config = {};
    }
    // set default values
    config.sessionRenewalMs = _configMilliseconds(config.sessionRenewalMs, 30 * 60 * 1000);
    config.sessionExpirationMs = _configMilliseconds(config.sessionExpirationMs, 24 * 60 * 60 * 1000);
    config[_DYN_DISABLE_EXCEPTION_TR0 /* @min:%2edisableExceptionTracking */] = stringToBoolOrDefault(config[_DYN_DISABLE_EXCEPTION_TR0 /* @min:%2edisableExceptionTracking */]);
    config[_DYN_AUTO_TRACK_PAGE_VISI1 /* @min:%2eautoTrackPageVisitTime */] = stringToBoolOrDefault(config[_DYN_AUTO_TRACK_PAGE_VISI1 /* @min:%2eautoTrackPageVisitTime */]);
    config[_DYN_OVERRIDE_PAGE_VIEW_D2 /* @min:%2eoverridePageViewDuration */] = stringToBoolOrDefault(config[_DYN_OVERRIDE_PAGE_VIEW_D2 /* @min:%2eoverridePageViewDuration */]);
    config[_DYN_ENABLE_UNHANDLED_PRO3 /* @min:%2eenableUnhandledPromiseRejectionTracking */] = stringToBoolOrDefault(config[_DYN_ENABLE_UNHANDLED_PRO3 /* @min:%2eenableUnhandledPromiseRejectionTracking */]);
    if (isNaN(config[_DYN_SAMPLING_PERCENTAGE /* @min:%2esamplingPercentage */]) || config[_DYN_SAMPLING_PERCENTAGE /* @min:%2esamplingPercentage */] <= 0 || config[_DYN_SAMPLING_PERCENTAGE /* @min:%2esamplingPercentage */] >= 100) {
        config[_DYN_SAMPLING_PERCENTAGE /* @min:%2esamplingPercentage */] = 100;
    }
    config[_DYN_IS_STORAGE_USE_DISAB4 /* @min:%2eisStorageUseDisabled */] = stringToBoolOrDefault(config[_DYN_IS_STORAGE_USE_DISAB4 /* @min:%2eisStorageUseDisabled */]);
    config[_DYN_IS_BROWSER_LINK_TRAC5 /* @min:%2eisBrowserLinkTrackingEnabled */] = stringToBoolOrDefault(config[_DYN_IS_BROWSER_LINK_TRAC5 /* @min:%2eisBrowserLinkTrackingEnabled */]);
    config[_DYN_ENABLE_AUTO_ROUTE_TR6 /* @min:%2eenableAutoRouteTracking */] = stringToBoolOrDefault(config[_DYN_ENABLE_AUTO_ROUTE_TR6 /* @min:%2eenableAutoRouteTracking */]);
    config[_DYN_NAME_PREFIX /* @min:%2enamePrefix */] = config[_DYN_NAME_PREFIX /* @min:%2enamePrefix */] || "";
    config.enableDebug = stringToBoolOrDefault(config.enableDebug);
    config[_DYN_DISABLE_FLUSH_ON_BEF7 /* @min:%2edisableFlushOnBeforeUnload */] = stringToBoolOrDefault(config[_DYN_DISABLE_FLUSH_ON_BEF7 /* @min:%2edisableFlushOnBeforeUnload */]);
    config.disableFlushOnUnload = stringToBoolOrDefault(config.disableFlushOnUnload, config[_DYN_DISABLE_FLUSH_ON_BEF7 /* @min:%2edisableFlushOnBeforeUnload */]);
    return config;
}
function _updateStorageUsage(extConfig) {
    // Not resetting the storage usage as someone may have manually called utlDisableStorage, so this will only
    // reset based if the configuration option is provided
    if (!isUndefined(extConfig[_DYN_IS_STORAGE_USE_DISAB4 /* @min:%2eisStorageUseDisabled */])) {
        if (extConfig[_DYN_IS_STORAGE_USE_DISAB4 /* @min:%2eisStorageUseDisabled */]) {
            utlDisableStorage();
        }
        else {
            utlEnableStorage();
        }
    }
}
var AnalyticsPlugin = /** @class */ (function (_super) {
    __extends(AnalyticsPlugin, _super);
    function AnalyticsPlugin() {
        var _this = _super.call(this) || this;
        _this.identifier = AnalyticsPluginIdentifier; // do not change name or priority
        _this.priority = 180; // take from reserved priority range 100- 200
        _this.autoRoutePVDelay = 500; // ms; Time to wait after a route change before triggering a pageview to allow DOM changes to take place
        var _eventTracking;
        var _pageTracking;
        var _pageViewManager;
        var _pageViewPerformanceManager;
        var _pageVisitTimeManager;
        var _preInitTelemetryInitializers;
        var _isBrowserLinkTrackingEnabled;
        var _browserLinkInitializerAdded;
        var _enableAutoRouteTracking;
        var _historyListenerAdded;
        var _disableExceptionTracking;
        var _autoExceptionInstrumented;
        var _enableUnhandledPromiseRejectionTracking;
        var _autoUnhandledPromiseInstrumented;
        // Counts number of trackAjax invocations.
        // By default we only monitor X ajax call per view to avoid too much load.
        // Default value is set in config.
        // This counter keeps increasing even after the limit is reached.
        var _trackAjaxAttempts = 0;
        // array with max length of 2 that store current url and previous url for SPA page route change trackPageview use.
        var _prevUri; // Assigned in the constructor
        var _currUri;
        var _evtNamespace;
        dynamicProto(AnalyticsPlugin, _this, function (_self, _base) {
            var _addHook = _base._addHook;
            _initDefaults();
            _self.getCookieMgr = function () {
                return safeGetCookieMgr(_self[_DYN_CORE /* @min:%2ecore */]);
            };
            _self.processTelemetry = function (env, itemCtx) {
                _self.processNext(env, itemCtx);
            };
            _self.trackEvent = function (event, customProperties) {
                try {
                    var telemetryItem = createTelemetryItem(event, EventTelemetry[_DYN_DATA_TYPE /* @min:%2edataType */], EventTelemetry[_DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], _self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), customProperties);
                    _self[_DYN_CORE /* @min:%2ecore */][_DYN_TRACK /* @min:%2etrack */](telemetryItem);
                }
                catch (e) {
                    _throwInternal(2 /* eLoggingSeverity.WARNING */, 39 /* _eInternalMessageId.TrackTraceFailed */, "trackTrace failed, trace will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * Start timing an extended event. Call `stopTrackEvent` to log the event when it ends.
             * @param   name    A string that identifies this event uniquely within the document.
             */
            _self.startTrackEvent = function (name) {
                try {
                    _eventTracking.start(name);
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 29 /* _eInternalMessageId.StartTrackEventFailed */, "startTrackEvent failed, event will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * Log an extended event that you started timing with `startTrackEvent`.
             * @param   name    The string you used to identify this event in `startTrackEvent`.
             * @param   properties  map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
             * @param   measurements    map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
             */
            _self.stopTrackEvent = function (name, properties, measurements) {
                try {
                    _eventTracking.stop(name, undefined, properties, measurements);
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 30 /* _eInternalMessageId.StopTrackEventFailed */, "stopTrackEvent failed, event will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * @description Log a diagnostic message
             * @param {ITraceTelemetry} trace
             * @param ICustomProperties.
             * @memberof ApplicationInsights
             */
            _self.trackTrace = function (trace, customProperties) {
                try {
                    var telemetryItem = createTelemetryItem(trace, Trace[_DYN_DATA_TYPE /* @min:%2edataType */], Trace[_DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], _self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), customProperties);
                    _self[_DYN_CORE /* @min:%2ecore */][_DYN_TRACK /* @min:%2etrack */](telemetryItem);
                }
                catch (e) {
                    _throwInternal(2 /* eLoggingSeverity.WARNING */, 39 /* _eInternalMessageId.TrackTraceFailed */, "trackTrace failed, trace will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * @description Log a numeric value that is not associated with a specific event. Typically
             * used to send regular reports of performance indicators. To send single measurement, just
             * use the name and average fields of {@link IMetricTelemetry}. If you take measurements
             * frequently, you can reduce the telemetry bandwidth by aggregating multiple measurements
             * and sending the resulting average at intervals
             * @param {IMetricTelemetry} metric input object argument. Only name and average are mandatory.
             * @param {{[key: string]: any}} customProperties additional data used to filter metrics in the
             * portal. Defaults to empty.
             * @memberof ApplicationInsights
             */
            _self.trackMetric = function (metric, customProperties) {
                try {
                    var telemetryItem = createTelemetryItem(metric, Metric[_DYN_DATA_TYPE /* @min:%2edataType */], Metric[_DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], _self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), customProperties);
                    _self[_DYN_CORE /* @min:%2ecore */][_DYN_TRACK /* @min:%2etrack */](telemetryItem);
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 36 /* _eInternalMessageId.TrackMetricFailed */, "trackMetric failed, metric will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * Logs that a page or other item was viewed.
             * @param IPageViewTelemetry The string you used as the name in startTrackPage. Defaults to the document title.
             * @param customProperties Additional data used to filter events and metrics. Defaults to empty.
             * If a user wants to provide duration for pageLoad, it'll have to be in pageView.properties.duration
             */
            _self[_DYN_TRACK_PAGE_VIEW /* @min:%2etrackPageView */] = function (pageView, customProperties) {
                try {
                    var inPv = pageView || {};
                    _pageViewManager[_DYN_TRACK_PAGE_VIEW /* @min:%2etrackPageView */](inPv, __assign(__assign(__assign({}, inPv.properties), inPv.measurements), customProperties));
                    if (_self.config[_DYN_AUTO_TRACK_PAGE_VISI1 /* @min:%2eautoTrackPageVisitTime */]) {
                        _pageVisitTimeManager[_DYN_TRACK_PREVIOUS_PAGE_9 /* @min:%2etrackPreviousPageVisit */](inPv.name, inPv.uri);
                    }
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 37 /* _eInternalMessageId.TrackPVFailed */, "trackPageView failed, page view will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * Create a page view telemetry item and send it to the SDK pipeline through the core.track API
             * @param pageView Page view item to be sent
             * @param properties Custom properties (Part C) that a user can add to the telemetry item
             * @param systemProperties System level properties (Part A) that a user can add to the telemetry item
             */
            _self[_DYN_SEND_PAGE_VIEW_INTER10 /* @min:%2esendPageViewInternal */] = function (pageView, properties, systemProperties) {
                var doc = getDocument();
                if (doc) {
                    pageView.refUri = pageView.refUri === undefined ? doc.referrer : pageView.refUri;
                }
                var telemetryItem = createTelemetryItem(pageView, PageView[_DYN_DATA_TYPE /* @min:%2edataType */], PageView[_DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], _self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), properties, systemProperties);
                _self[_DYN_CORE /* @min:%2ecore */][_DYN_TRACK /* @min:%2etrack */](telemetryItem);
                // reset ajaxes counter
                _trackAjaxAttempts = 0;
            };
            /**
             * @ignore INTERNAL ONLY
             * @param pageViewPerformance
             * @param properties
             */
            _self[_DYN_SEND_PAGE_VIEW_PERFO11 /* @min:%2esendPageViewPerformanceInternal */] = function (pageViewPerformance, properties, systemProperties) {
                var telemetryItem = createTelemetryItem(pageViewPerformance, PageViewPerformance[_DYN_DATA_TYPE /* @min:%2edataType */], PageViewPerformance[_DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], _self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), properties, systemProperties);
                _self[_DYN_CORE /* @min:%2ecore */][_DYN_TRACK /* @min:%2etrack */](telemetryItem);
            };
            /**
             * Send browser performance metrics.
             * @param pageViewPerformance
             * @param customProperties
             */
            _self.trackPageViewPerformance = function (pageViewPerformance, customProperties) {
                var inPvp = pageViewPerformance || {};
                try {
                    _pageViewPerformanceManager[_DYN_POPULATE_PAGE_VIEW_P12 /* @min:%2epopulatePageViewPerformanceEvent */](inPvp);
                    _self[_DYN_SEND_PAGE_VIEW_PERFO11 /* @min:%2esendPageViewPerformanceInternal */](inPvp, customProperties);
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 37 /* _eInternalMessageId.TrackPVFailed */, "trackPageViewPerformance failed, page view will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * Starts the timer for tracking a page load time. Use this instead of `trackPageView` if you want to control when the page view timer starts and stops,
             * but don't want to calculate the duration yourself. This method doesn't send any telemetry. Call `stopTrackPage` to log the end of the page view
             * and send the event.
             * @param name A string that idenfities this item, unique within this HTML document. Defaults to the document title.
             */
            _self.startTrackPage = function (name) {
                try {
                    if (typeof name !== "string") {
                        var doc = getDocument();
                        name = doc && doc.title || "";
                    }
                    _pageTracking.start(name);
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 31 /* _eInternalMessageId.StartTrackFailed */, "startTrackPage failed, page view may not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * Stops the timer that was started by calling `startTrackPage` and sends the pageview load time telemetry with the specified properties and measurements.
             * The duration of the page view will be the time between calling `startTrackPage` and `stopTrackPage`.
             * @param   name  The string you used as the name in startTrackPage. Defaults to the document title.
             * @param   url   String - a relative or absolute URL that identifies the page or other item. Defaults to the window location.
             * @param   properties  map[string, string] - additional data used to filter pages and metrics in the portal. Defaults to empty.
             * @param   measurements    map[string, number] - metrics associated with this page, displayed in Metrics Explorer on the portal. Defaults to empty.
             */
            _self.stopTrackPage = function (name, url, properties, measurement) {
                try {
                    if (typeof name !== "string") {
                        var doc = getDocument();
                        name = doc && doc.title || "";
                    }
                    if (typeof url !== "string") {
                        var loc = getLocation();
                        url = loc && loc[_DYN_HREF /* @min:%2ehref */] || "";
                    }
                    _pageTracking.stop(name, url, properties, measurement);
                    if (_self.config[_DYN_AUTO_TRACK_PAGE_VISI1 /* @min:%2eautoTrackPageVisitTime */]) {
                        _pageVisitTimeManager[_DYN_TRACK_PREVIOUS_PAGE_9 /* @min:%2etrackPreviousPageVisit */](name, url);
                    }
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 32 /* _eInternalMessageId.StopTrackFailed */, "stopTrackPage failed, page view will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
            * @ignore INTERNAL ONLY
            * @param exception
            * @param properties
            * @param systemProperties
            */
            _self[_DYN_SEND_EXCEPTION_INTER13 /* @min:%2esendExceptionInternal */] = function (exception, customProperties, systemProperties) {
                var theError = exception[_DYN_EXCEPTION /* @min:%2eexception */] || exception[_DYN_ERROR /* @min:%2eerror */] || new Error(strNotSpecified);
                var exceptionPartB = new Exception(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), theError, exception.properties || customProperties, exception.measurements, exception.severityLevel, exception.id).toInterface();
                var telemetryItem = createTelemetryItem(exceptionPartB, Exception[_DYN_DATA_TYPE /* @min:%2edataType */], Exception[_DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], _self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), customProperties, systemProperties);
                _self[_DYN_CORE /* @min:%2ecore */][_DYN_TRACK /* @min:%2etrack */](telemetryItem);
            };
            /**
             * Log an exception you have caught.
             *
             * @param {IExceptionTelemetry} exception   Object which contains exception to be sent
             * @param {{[key: string]: any}} customProperties   Additional data used to filter pages and metrics in the portal. Defaults to empty.
             *
             * Any property of type double will be considered a measurement, and will be treated by Application Insights as a metric.
             * @memberof ApplicationInsights
             */
            _self.trackException = function (exception, customProperties) {
                if (exception && !exception[_DYN_EXCEPTION /* @min:%2eexception */] && exception[_DYN_ERROR /* @min:%2eerror */]) {
                    exception[_DYN_EXCEPTION /* @min:%2eexception */] = exception[_DYN_ERROR /* @min:%2eerror */];
                }
                try {
                    _self[_DYN_SEND_EXCEPTION_INTER13 /* @min:%2esendExceptionInternal */](exception, customProperties);
                }
                catch (e) {
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 35 /* _eInternalMessageId.TrackExceptionFailed */, "trackException failed, exception will not be collected: " + getExceptionName(e), { exception: dumpObj(e) });
                }
            };
            /**
             * @description Custom error handler for Application Insights Analytics
             * @param {IAutoExceptionTelemetry} exception
             * @memberof ApplicationInsights
             */
            _self[_DYN__ONERROR /* @min:%2e_onerror */] = function (exception) {
                var error = exception && exception[_DYN_ERROR /* @min:%2eerror */];
                var evt = exception && exception.evt;
                try {
                    if (!evt) {
                        var _window = getWindow();
                        if (_window) {
                            evt = _window[strEvent];
                        }
                    }
                    var url = (exception && exception.url) || (getDocument() || {}).URL;
                    // If no error source is provided assume the default window.onerror handler
                    var errorSrc = exception[_DYN_ERROR_SRC /* @min:%2eerrorSrc */] || "window.onerror@" + url + ":" + (exception[_DYN_LINE_NUMBER /* @min:%2elineNumber */] || 0) + ":" + (exception[_DYN_COLUMN_NUMBER /* @min:%2ecolumnNumber */] || 0);
                    var properties = {
                        errorSrc: errorSrc,
                        url: url,
                        lineNumber: exception[_DYN_LINE_NUMBER /* @min:%2elineNumber */] || 0,
                        columnNumber: exception[_DYN_COLUMN_NUMBER /* @min:%2ecolumnNumber */] || 0,
                        message: exception[_DYN_MESSAGE /* @min:%2emessage */]
                    };
                    if (isCrossOriginError(exception.message, exception.url, exception.lineNumber, exception.columnNumber, exception[_DYN_ERROR /* @min:%2eerror */])) {
                        _sendCORSException(Exception[_DYN__CREATE_AUTO_EXCEPTI14 /* @min:%2eCreateAutoException */]("Script error: The browser's same-origin policy prevents us from getting the details of this exception. Consider using the 'crossorigin' attribute.", url, exception[_DYN_LINE_NUMBER /* @min:%2elineNumber */] || 0, exception[_DYN_COLUMN_NUMBER /* @min:%2ecolumnNumber */] || 0, error, evt, null, errorSrc), properties);
                    }
                    else {
                        if (!exception[_DYN_ERROR_SRC /* @min:%2eerrorSrc */]) {
                            exception[_DYN_ERROR_SRC /* @min:%2eerrorSrc */] = errorSrc;
                        }
                        _self.trackException({ exception: exception, severityLevel: 3 /* eSeverityLevel.Error */ }, properties);
                    }
                }
                catch (e) {
                    var errorString = error ? (error.name + ", " + error[_DYN_MESSAGE /* @min:%2emessage */]) : "null";
                    _throwInternal(1 /* eLoggingSeverity.CRITICAL */, 11 /* _eInternalMessageId.ExceptionWhileLoggingError */, "_onError threw exception while logging error, error will not be collected: "
                        + getExceptionName(e), { exception: dumpObj(e), errorString: errorString });
                }
            };
            _self[_DYN_ADD_TELEMETRY_INITIA15 /* @min:%2eaddTelemetryInitializer */] = function (telemetryInitializer) {
                if (_self[_DYN_CORE /* @min:%2ecore */]) {
                    // Just add to the core
                    return _self[_DYN_CORE /* @min:%2ecore */][_DYN_ADD_TELEMETRY_INITIA15 /* @min:%2eaddTelemetryInitializer */](telemetryInitializer);
                }
                // Handle "pre-initialization" telemetry initializers (for backward compatibility)
                if (!_preInitTelemetryInitializers) {
                    _preInitTelemetryInitializers = [];
                }
                _preInitTelemetryInitializers.push(telemetryInitializer);
            };
            _self.initialize = function (config, core, extensions, pluginChain) {
                if (_self.isInitialized()) {
                    return;
                }
                if (isNullOrUndefined(core)) {
                    throwError("Error initializing");
                }
                _base.initialize(config, core, extensions, pluginChain);
                try {
                    _evtNamespace = mergeEvtNamespace(createUniqueNamespace(_self.identifier), core.evtNamespace && core.evtNamespace());
                    if (_preInitTelemetryInitializers) {
                        arrForEach(_preInitTelemetryInitializers, function (initializer) {
                            core[_DYN_ADD_TELEMETRY_INITIA15 /* @min:%2eaddTelemetryInitializer */](initializer);
                        });
                        _preInitTelemetryInitializers = null;
                    }
                    var extConfig = _populateDefaults(config);
                    _updateStorageUsage(extConfig);
                    _pageViewPerformanceManager = new PageViewPerformanceManager(_self[_DYN_CORE /* @min:%2ecore */]);
                    _pageViewManager = new PageViewManager(_this, extConfig[_DYN_OVERRIDE_PAGE_VIEW_D2 /* @min:%2eoverridePageViewDuration */], _self[_DYN_CORE /* @min:%2ecore */], _pageViewPerformanceManager);
                    _pageVisitTimeManager = new PageVisitTimeManager(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), function (pageName, pageUrl, pageVisitTime) { return trackPageVisitTime(pageName, pageUrl, pageVisitTime); });
                    _updateBrowserLinkTracking(extConfig, config);
                    _eventTracking = new Timing(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), "trackEvent");
                    _eventTracking.action =
                        function (name, url, duration, properties, measurements) {
                            if (!properties) {
                                properties = {};
                            }
                            if (!measurements) {
                                measurements = {};
                            }
                            properties.duration = duration[_DYN_TO_STRING /* @min:%2etoString */]();
                            _self.trackEvent({ name: name, properties: properties, measurements: measurements });
                        };
                    // initialize page view timing
                    _pageTracking = new Timing(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), "trackPageView");
                    _pageTracking.action = function (name, url, duration, properties, measurements) {
                        // duration must be a custom property in order for the collector to extract it
                        if (isNullOrUndefined(properties)) {
                            properties = {};
                        }
                        properties.duration = duration[_DYN_TO_STRING /* @min:%2etoString */]();
                        var pageViewItem = {
                            name: name,
                            uri: url,
                            properties: properties,
                            measurements: measurements
                        };
                        _self[_DYN_SEND_PAGE_VIEW_INTER10 /* @min:%2esendPageViewInternal */](pageViewItem, properties);
                    };
                    if (hasWindow()) {
                        _updateExceptionTracking(extConfig);
                        _updateLocationChange(extConfig);
                    }
                }
                catch (e) {
                    // resetting the initialized state because of failure
                    _self.setInitialized(false);
                    throw e;
                }
            };
            _self._doTeardown = function (unloadCtx, unloadState) {
                _pageViewManager && _pageViewManager.teardown(unloadCtx, unloadState);
                // Just register to remove all events associated with this namespace
                eventOff(window, null, null, _evtNamespace);
                _initDefaults();
            };
            function _populateDefaults(config) {
                var ctx = createProcessTelemetryContext(null, config, _self[_DYN_CORE /* @min:%2ecore */]);
                var identifier = _self.identifier;
                // load default values if specified
                var defaults = _getDefaultConfig(config);
                var extConfig = _self.config = ctx.getExtCfg(identifier);
                if (defaults !== undefined) {
                    objForEachKey(defaults, function (field, value) {
                        // for each unspecified field, set the default value
                        extConfig[field] = ctx.getConfig(identifier, field, value);
                        if (extConfig[field] === undefined) {
                            extConfig = value;
                        }
                    });
                }
                return extConfig;
            }
            function _updateBrowserLinkTracking(extConfig, config) {
                _isBrowserLinkTrackingEnabled = extConfig[_DYN_IS_BROWSER_LINK_TRAC5 /* @min:%2eisBrowserLinkTrackingEnabled */] || config[_DYN_IS_BROWSER_LINK_TRAC5 /* @min:%2eisBrowserLinkTrackingEnabled */];
                _addDefaultTelemetryInitializers();
            }
            /**
             * Log a page visit time
             * @param    pageName    Name of page
             * @param    pageVisitDuration Duration of visit to the page in milleseconds
             */
            function trackPageVisitTime(pageName, pageUrl, pageVisitTime) {
                var properties = { PageName: pageName, PageUrl: pageUrl };
                _self.trackMetric({
                    name: "PageVisitTime",
                    average: pageVisitTime,
                    max: pageVisitTime,
                    min: pageVisitTime,
                    sampleCount: 1
                }, properties);
            }
            function _addDefaultTelemetryInitializers() {
                if (!_browserLinkInitializerAdded && _isBrowserLinkTrackingEnabled) {
                    var browserLinkPaths_1 = ["/browserLinkSignalR/", "/__browserLink/"];
                    var dropBrowserLinkRequests = function (envelope) {
                        if (_isBrowserLinkTrackingEnabled && envelope.baseType === RemoteDependencyData[_DYN_DATA_TYPE /* @min:%2edataType */]) {
                            var remoteData = envelope.baseData;
                            if (remoteData) {
                                for (var i = 0; i < browserLinkPaths_1[_DYN_LENGTH /* @min:%2elength */]; i++) {
                                    if (remoteData.target && remoteData.target.indexOf(browserLinkPaths_1[i]) >= 0) {
                                        return false;
                                    }
                                }
                            }
                        }
                        return true;
                    };
                    _self[_DYN_ADD_TELEMETRY_INITIA15 /* @min:%2eaddTelemetryInitializer */](dropBrowserLinkRequests);
                    _browserLinkInitializerAdded = true;
                }
            }
            function _sendCORSException(exception, properties) {
                var telemetryItem = createTelemetryItem(exception, Exception[_DYN_DATA_TYPE /* @min:%2edataType */], Exception[_DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], _self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), properties);
                _self[_DYN_CORE /* @min:%2ecore */][_DYN_TRACK /* @min:%2etrack */](telemetryItem);
            }
            function _updateExceptionTracking(extConfig) {
                var _window = getWindow();
                var locn = getLocation(true);
                _disableExceptionTracking = extConfig[_DYN_DISABLE_EXCEPTION_TR0 /* @min:%2edisableExceptionTracking */];
                if (!_disableExceptionTracking && !_autoExceptionInstrumented && !extConfig.autoExceptionInstrumented) {
                    // We want to enable exception auto collection and it has not been done so yet
                    _addHook(InstrumentEvent(_window, "onerror", {
                        ns: _evtNamespace,
                        rsp: function (callDetails, message, url, lineNumber, columnNumber, error) {
                            if (!_disableExceptionTracking && callDetails.rslt !== true) {
                                _self[_DYN__ONERROR /* @min:%2e_onerror */](Exception[_DYN__CREATE_AUTO_EXCEPTI14 /* @min:%2eCreateAutoException */](message, url, lineNumber, columnNumber, error, callDetails.evt));
                            }
                        }
                    }, false));
                    _autoExceptionInstrumented = true;
                }
                _addUnhandledPromiseRejectionTracking(extConfig, _window, locn);
            }
            function _updateLocationChange(extConfig) {
                var win = getWindow();
                var locn = getLocation(true);
                _enableAutoRouteTracking = extConfig[_DYN_ENABLE_AUTO_ROUTE_TR6 /* @min:%2eenableAutoRouteTracking */] === true;
                /**
                 * Create a custom "locationchange" event which is triggered each time the history object is changed
                 */
                if (win && _enableAutoRouteTracking && hasHistory()) {
                    var _history = getHistory();
                    if (isFunction(_history.pushState) && isFunction(_history.replaceState) && typeof Event !== strUndefined) {
                        _addHistoryListener(extConfig, win, _history, locn);
                    }
                }
            }
            function _getDistributedTraceCtx() {
                var distributedTraceCtx = null;
                if (_self[_DYN_CORE /* @min:%2ecore */] && _self[_DYN_CORE /* @min:%2ecore */].getTraceCtx) {
                    distributedTraceCtx = _self[_DYN_CORE /* @min:%2ecore */].getTraceCtx(false);
                }
                if (!distributedTraceCtx) {
                    // Fallback when using an older Core and PropertiesPlugin
                    var properties = _self[_DYN_CORE /* @min:%2ecore */].getPlugin(PropertiesPluginIdentifier);
                    if (properties) {
                        var context = properties.plugin.context;
                        if (context) {
                            distributedTraceCtx = createDistributedTraceContextFromTrace(context.telemetryTrace);
                        }
                    }
                }
                return distributedTraceCtx;
            }
            /**
             * Create a custom "locationchange" event which is triggered each time the history object is changed
             */
            function _addHistoryListener(extConfig, win, history, locn) {
                var namePrefix = extConfig[_DYN_NAME_PREFIX /* @min:%2enamePrefix */] || "";
                function _popstateHandler() {
                    if (_enableAutoRouteTracking) {
                        _dispatchEvent(win, createDomEvent(namePrefix + "locationchange"));
                    }
                }
                function _locationChangeHandler() {
                    // We always track the changes (if the handler is installed) to handle the feature being disabled between location changes
                    if (_currUri) {
                        _prevUri = _currUri;
                        _currUri = locn && locn[_DYN_HREF /* @min:%2ehref */] || "";
                    }
                    else {
                        _currUri = locn && locn[_DYN_HREF /* @min:%2ehref */] || "";
                    }
                    if (_enableAutoRouteTracking) {
                        var distributedTraceCtx = _getDistributedTraceCtx();
                        if (distributedTraceCtx) {
                            distributedTraceCtx.setTraceId(generateW3CId());
                            var traceLocationName = "_unknown_";
                            if (locn && locn.pathname) {
                                traceLocationName = locn.pathname + (locn.hash || "");
                            }
                            // This populates the ai.operation.name which has a maximum size of 1024 so we need to sanitize it
                            distributedTraceCtx.setName(dataSanitizeString(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), traceLocationName));
                        }
                        setTimeout((function (uri) {
                            // todo: override start time so that it is not affected by autoRoutePVDelay
                            _self[_DYN_TRACK_PAGE_VIEW /* @min:%2etrackPageView */]({ refUri: uri, properties: { duration: 0 } }); // SPA route change loading durations are undefined, so send 0
                        }).bind(this, _prevUri), _self.autoRoutePVDelay);
                    }
                }
                if (!_historyListenerAdded) {
                    _addHook(InstrumentEvent(history, "pushState", {
                        ns: _evtNamespace,
                        rsp: function () {
                            if (_enableAutoRouteTracking) {
                                _dispatchEvent(win, createDomEvent(namePrefix + "pushState"));
                                _dispatchEvent(win, createDomEvent(namePrefix + "locationchange"));
                            }
                        }
                    }, true));
                    _addHook(InstrumentEvent(history, "replaceState", {
                        ns: _evtNamespace,
                        rsp: function () {
                            if (_enableAutoRouteTracking) {
                                _dispatchEvent(win, createDomEvent(namePrefix + "replaceState"));
                                _dispatchEvent(win, createDomEvent(namePrefix + "locationchange"));
                            }
                        }
                    }, true));
                    eventOn(win, namePrefix + "popstate", _popstateHandler, _evtNamespace);
                    eventOn(win, namePrefix + "locationchange", _locationChangeHandler, _evtNamespace);
                    _historyListenerAdded = true;
                }
            }
            function _addUnhandledPromiseRejectionTracking(extConfig, _window, _location) {
                _enableUnhandledPromiseRejectionTracking = extConfig[_DYN_ENABLE_UNHANDLED_PRO3 /* @min:%2eenableUnhandledPromiseRejectionTracking */] === true;
                if (_enableUnhandledPromiseRejectionTracking && !_autoUnhandledPromiseInstrumented) {
                    // We want to enable exception auto collection and it has not been done so yet
                    _addHook(InstrumentEvent(_window, "onunhandledrejection", {
                        ns: _evtNamespace,
                        rsp: function (callDetails, error) {
                            if (_enableUnhandledPromiseRejectionTracking && callDetails.rslt !== true) { // handled could be typeof function
                                _self[_DYN__ONERROR /* @min:%2e_onerror */](Exception[_DYN__CREATE_AUTO_EXCEPTI14 /* @min:%2eCreateAutoException */](_getReason(error), _location ? _location[_DYN_HREF /* @min:%2ehref */] : "", 0, 0, error, callDetails.evt));
                            }
                        }
                    }, false));
                    _autoUnhandledPromiseInstrumented = true;
                    extConfig.autoUnhandledPromiseInstrumented = _autoUnhandledPromiseInstrumented;
                }
            }
            /**
             * This method will throw exceptions in debug mode or attempt to log the error as a console warning.
             * @param severity {eLoggingSeverity} - The severity of the log message
             * @param message {_InternalLogMessage} - The log message.
             */
            function _throwInternal(severity, msgId, msg, properties, isUserAct) {
                _self[_DYN_DIAG_LOG /* @min:%2ediagLog */]().throwInternal(severity, msgId, msg, properties, isUserAct);
            }
            function _initDefaults() {
                _eventTracking = null;
                _pageTracking = null;
                _pageViewManager = null;
                _pageViewPerformanceManager = null;
                _pageVisitTimeManager = null;
                _preInitTelemetryInitializers = null;
                _isBrowserLinkTrackingEnabled = false;
                _browserLinkInitializerAdded = false;
                _enableAutoRouteTracking = false;
                _historyListenerAdded = false;
                _disableExceptionTracking = false;
                _autoExceptionInstrumented = false;
                _enableUnhandledPromiseRejectionTracking = false;
                _autoUnhandledPromiseInstrumented = false;
                // Counts number of trackAjax invocations.
                // By default we only monitor X ajax call per view to avoid too much load.
                // Default value is set in config.
                // This counter keeps increasing even after the limit is reached.
                _trackAjaxAttempts = 0;
                // array with max length of 2 that store current url and previous url for SPA page route change trackPageview use.
                var location = getLocation(true);
                _prevUri = location && location[_DYN_HREF /* @min:%2ehref */] || "";
                _currUri = null;
                _evtNamespace = null;
            }
            // For backward compatibility
            objDefineAccessors(_self, "_pageViewManager", function () { return _pageViewManager; });
            objDefineAccessors(_self, "_pageViewPerformanceManager", function () { return _pageViewPerformanceManager; });
            objDefineAccessors(_self, "_pageVisitTimeManager", function () { return _pageVisitTimeManager; });
            objDefineAccessors(_self, "_evtNamespace", function () { return "." + _evtNamespace; });
        });
        return _this;
    }
// Removed Stub for AnalyticsPlugin.prototype.getCookieMgr.
// Removed Stub for AnalyticsPlugin.prototype.processTelemetry.
// Removed Stub for AnalyticsPlugin.prototype.trackEvent.
// Removed Stub for AnalyticsPlugin.prototype.startTrackEvent.
// Removed Stub for AnalyticsPlugin.prototype.stopTrackEvent.
// Removed Stub for AnalyticsPlugin.prototype.trackTrace.
// Removed Stub for AnalyticsPlugin.prototype.trackMetric.
// Removed Stub for AnalyticsPlugin.prototype.trackPageView.
// Removed Stub for AnalyticsPlugin.prototype.sendPageViewInternal.
// Removed Stub for AnalyticsPlugin.prototype.sendPageViewPerformanceInternal.
// Removed Stub for AnalyticsPlugin.prototype.trackPageViewPerformance.
// Removed Stub for AnalyticsPlugin.prototype.startTrackPage.
// Removed Stub for AnalyticsPlugin.prototype.stopTrackPage.
// Removed Stub for AnalyticsPlugin.prototype.sendExceptionInternal.
// Removed Stub for AnalyticsPlugin.prototype.trackException.
// Removed Stub for AnalyticsPlugin.prototype._onerror.
// Removed Stub for AnalyticsPlugin.prototype.addTelemetryInitializer.
// Removed Stub for AnalyticsPlugin.prototype.initialize.
    AnalyticsPlugin.Version = '2.8.9'; // Not currently used anywhere
    AnalyticsPlugin.getDefaultConfig = _getDefaultConfig;
    return AnalyticsPlugin;
}(BaseTelemetryPlugin));
export { AnalyticsPlugin };
//# sourceMappingURL=AnalyticsPlugin.js.map