{"version":3,"sources":["container/SequentialContainer/Deque.js","../../src/container/SequentialContainer/Deque.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_RandomIterator","obj","__esModule","DequeIterator","RandomIterator","copy","this","_node","_size","_getElementByPos","_setElementByPos","iteratorType","Deque","SequentialContainer","constructor","container","_bucketSize","super","_first","_curFirst","_last","_curLast","_bucketNum","_map","_length","size","length","RangeError","Math","max","ceil","i","push","Array","needBucketNum","self","forEach","element","pushBack","bind","getElementByPos","setElementByPos","_reAllocate","newMap","addBucketNum","_getElementIndex","pos","offset","offsetRemainder","curNodePointerIndex","curNodeBucketIndex","clear","begin","end","rBegin","rEnd","front","back","popBack","pushFront","popFront","insert","num","arr","cut","eraseElementByPos","el","eraseElementByValue","eraseElementByIterator","iter","next","find","reverse","l","r","tmp","unique","index","pre","cur","sort","cmp","shrinkToFit","callback","Symbol","iterator","_default"],"mappings":"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","file":"Deque.js","sourcesContent":["import SequentialContainer from './Base';\nimport { RandomIterator } from \"./Base/RandomIterator\";\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nclass DequeIterator extends RandomIterator {\n    copy() {\n        return new DequeIterator(this._node, this._size, this._getElementByPos, this._setElementByPos, this.iteratorType);\n    }\n}\nclass Deque extends SequentialContainer {\n    constructor(container = [], _bucketSize = (1 << 12)) {\n        super();\n        /**\n         * @internal\n         */\n        this._first = 0;\n        /**\n         * @internal\n         */\n        this._curFirst = 0;\n        /**\n         * @internal\n         */\n        this._last = 0;\n        /**\n         * @internal\n         */\n        this._curLast = 0;\n        /**\n         * @internal\n         */\n        this._bucketNum = 0;\n        /**\n         * @internal\n         */\n        this._map = [];\n        let _length;\n        if ('size' in container) {\n            if (typeof container.size === 'number') {\n                _length = container.size;\n            }\n            else {\n                _length = container.size();\n            }\n        }\n        else if ('length' in container) {\n            _length = container.length;\n        }\n        else {\n            throw new RangeError('Can\\'t get container\\'s size!');\n        }\n        this._bucketSize = _bucketSize;\n        this._bucketNum = Math.max(Math.ceil(_length / this._bucketSize), 1);\n        for (let i = 0; i < this._bucketNum; ++i) {\n            this._map.push(new Array(this._bucketSize));\n        }\n        const needBucketNum = Math.ceil(_length / this._bucketSize);\n        this._first = this._last = (this._bucketNum >> 1) - (needBucketNum >> 1);\n        this._curFirst = this._curLast = (this._bucketSize - _length % this._bucketSize) >> 1;\n        const self = this;\n        container.forEach(function (element) {\n            self.pushBack(element);\n        });\n        this.size = this.size.bind(this);\n        this.getElementByPos = this.getElementByPos.bind(this);\n        this.setElementByPos = this.setElementByPos.bind(this);\n    }\n    /**\n     * @description Growth the Deque.\n     * @internal\n     */\n    _reAllocate() {\n        const newMap = [];\n        const addBucketNum = Math.max(this._bucketNum >> 1, 1);\n        for (let i = 0; i < addBucketNum; ++i) {\n            newMap[i] = new Array(this._bucketSize);\n        }\n        for (let i = this._first; i < this._bucketNum; ++i) {\n            newMap[newMap.length] = this._map[i];\n        }\n        for (let i = 0; i < this._last; ++i) {\n            newMap[newMap.length] = this._map[i];\n        }\n        newMap[newMap.length] = [...this._map[this._last]];\n        this._first = addBucketNum;\n        this._last = newMap.length - 1;\n        for (let i = 0; i < addBucketNum; ++i) {\n            newMap[newMap.length] = new Array(this._bucketSize);\n        }\n        this._map = newMap;\n        this._bucketNum = newMap.length;\n    }\n    /**\n     * @description Get the bucket position of the element and the pointer position by index.\n     * @param pos - The element's index.\n     * @internal\n     */\n    _getElementIndex(pos) {\n        const offset = this._curFirst + pos + 1;\n        const offsetRemainder = offset % this._bucketSize;\n        let curNodePointerIndex = offsetRemainder - 1;\n        let curNodeBucketIndex = this._first + (offset - offsetRemainder) / this._bucketSize;\n        if (offsetRemainder === 0)\n            curNodeBucketIndex -= 1;\n        curNodeBucketIndex %= this._bucketNum;\n        if (curNodePointerIndex < 0)\n            curNodePointerIndex += this._bucketSize;\n        return { curNodeBucketIndex, curNodePointerIndex };\n    }\n    clear() {\n        this._map = [[]];\n        this._bucketNum = 1;\n        this._first = this._last = this._length = 0;\n        this._curFirst = this._curLast = this._bucketSize >> 1;\n    }\n    begin() {\n        return new DequeIterator(0, this.size, this.getElementByPos, this.setElementByPos);\n    }\n    end() {\n        return new DequeIterator(this._length, this.size, this.getElementByPos, this.setElementByPos);\n    }\n    rBegin() {\n        return new DequeIterator(this._length - 1, this.size, this.getElementByPos, this.setElementByPos, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new DequeIterator(-1, this.size, this.getElementByPos, this.setElementByPos, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        return this._map[this._first][this._curFirst];\n    }\n    back() {\n        return this._map[this._last][this._curLast];\n    }\n    pushBack(element) {\n        if (this._length) {\n            if (this._curLast < this._bucketSize - 1) {\n                this._curLast += 1;\n            }\n            else if (this._last < this._bucketNum - 1) {\n                this._last += 1;\n                this._curLast = 0;\n            }\n            else {\n                this._last = 0;\n                this._curLast = 0;\n            }\n            if (this._last === this._first &&\n                this._curLast === this._curFirst)\n                this._reAllocate();\n        }\n        this._length += 1;\n        this._map[this._last][this._curLast] = element;\n        return this._length;\n    }\n    popBack() {\n        if (this._length === 0)\n            return;\n        const value = this._map[this._last][this._curLast];\n        delete this._map[this._last][this._curLast];\n        if (this._length !== 1) {\n            if (this._curLast > 0) {\n                this._curLast -= 1;\n            }\n            else if (this._last > 0) {\n                this._last -= 1;\n                this._curLast = this._bucketSize - 1;\n            }\n            else {\n                this._last = this._bucketNum - 1;\n                this._curLast = this._bucketSize - 1;\n            }\n        }\n        this._length -= 1;\n        return value;\n    }\n    /**\n     * @description Push the element to the front.\n     * @param element - The element you want to push.\n     * @returns The size of queue after pushing.\n     */\n    pushFront(element) {\n        if (this._length) {\n            if (this._curFirst > 0) {\n                this._curFirst -= 1;\n            }\n            else if (this._first > 0) {\n                this._first -= 1;\n                this._curFirst = this._bucketSize - 1;\n            }\n            else {\n                this._first = this._bucketNum - 1;\n                this._curFirst = this._bucketSize - 1;\n            }\n            if (this._first === this._last &&\n                this._curFirst === this._curLast)\n                this._reAllocate();\n        }\n        this._length += 1;\n        this._map[this._first][this._curFirst] = element;\n        return this._length;\n    }\n    /**\n     * @description Remove the _first element.\n     * @returns The element you popped.\n     */\n    popFront() {\n        if (this._length === 0)\n            return;\n        const value = this._map[this._first][this._curFirst];\n        delete this._map[this._first][this._curFirst];\n        if (this._length !== 1) {\n            if (this._curFirst < this._bucketSize - 1) {\n                this._curFirst += 1;\n            }\n            else if (this._first < this._bucketNum - 1) {\n                this._first += 1;\n                this._curFirst = 0;\n            }\n            else {\n                this._first = 0;\n                this._curFirst = 0;\n            }\n        }\n        this._length -= 1;\n        return value;\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const { curNodeBucketIndex, curNodePointerIndex } = this._getElementIndex(pos);\n        return this._map[curNodeBucketIndex][curNodePointerIndex];\n    }\n    setElementByPos(pos, element) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const { curNodeBucketIndex, curNodePointerIndex } = this._getElementIndex(pos);\n        this._map[curNodeBucketIndex][curNodePointerIndex] = element;\n    }\n    insert(pos, element, num = 1) {\n        if (pos < 0 || pos > this._length) {\n            throw new RangeError();\n        }\n        if (pos === 0) {\n            while (num--)\n                this.pushFront(element);\n        }\n        else if (pos === this._length) {\n            while (num--)\n                this.pushBack(element);\n        }\n        else {\n            const arr = [];\n            for (let i = pos; i < this._length; ++i) {\n                arr.push(this.getElementByPos(i));\n            }\n            this.cut(pos - 1);\n            for (let i = 0; i < num; ++i)\n                this.pushBack(element);\n            for (let i = 0; i < arr.length; ++i)\n                this.pushBack(arr[i]);\n        }\n        return this._length;\n    }\n    /**\n     * @description Remove all elements after the specified position (excluding the specified position).\n     * @param pos - The previous position of the first removed element.\n     * @returns The size of the container after cutting.\n     * @example\n     * deque.cut(1); // Then deque's size will be 2. deque -> [0, 1]\n     */\n    cut(pos) {\n        if (pos < 0) {\n            this.clear();\n            return 0;\n        }\n        const { curNodeBucketIndex, curNodePointerIndex } = this._getElementIndex(pos);\n        this._last = curNodeBucketIndex;\n        this._curLast = curNodePointerIndex;\n        this._length = pos + 1;\n        return this._length;\n    }\n    eraseElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        if (pos === 0)\n            this.popFront();\n        else if (pos === this._length - 1)\n            this.popBack();\n        else {\n            const arr = [];\n            for (let i = pos + 1; i < this._length; ++i) {\n                arr.push(this.getElementByPos(i));\n            }\n            this.cut(pos);\n            this.popBack();\n            const self = this;\n            arr.forEach(function (el) {\n                self.pushBack(el);\n            });\n        }\n        return this._length;\n    }\n    eraseElementByValue(value) {\n        if (this._length === 0)\n            return 0;\n        const arr = [];\n        for (let i = 0; i < this._length; ++i) {\n            const element = this.getElementByPos(i);\n            if (element !== value)\n                arr.push(element);\n        }\n        const _length = arr.length;\n        for (let i = 0; i < _length; ++i)\n            this.setElementByPos(i, arr[i]);\n        return this.cut(_length - 1);\n    }\n    eraseElementByIterator(iter) {\n        const _node = iter._node;\n        this.eraseElementByPos(_node);\n        iter = iter.next();\n        return iter;\n    }\n    find(element) {\n        for (let i = 0; i < this._length; ++i) {\n            if (this.getElementByPos(i) === element) {\n                return new DequeIterator(i, this.size, this.getElementByPos, this.setElementByPos);\n            }\n        }\n        return this.end();\n    }\n    reverse() {\n        let l = 0;\n        let r = this._length - 1;\n        while (l < r) {\n            const tmp = this.getElementByPos(l);\n            this.setElementByPos(l, this.getElementByPos(r));\n            this.setElementByPos(r, tmp);\n            l += 1;\n            r -= 1;\n        }\n    }\n    unique() {\n        if (this._length <= 1) {\n            return this._length;\n        }\n        let index = 1;\n        let pre = this.getElementByPos(0);\n        for (let i = 1; i < this._length; ++i) {\n            const cur = this.getElementByPos(i);\n            if (cur !== pre) {\n                pre = cur;\n                this.setElementByPos(index++, cur);\n            }\n        }\n        while (this._length > index)\n            this.popBack();\n        return this._length;\n    }\n    sort(cmp) {\n        const arr = [];\n        for (let i = 0; i < this._length; ++i) {\n            arr.push(this.getElementByPos(i));\n        }\n        arr.sort(cmp);\n        for (let i = 0; i < this._length; ++i)\n            this.setElementByPos(i, arr[i]);\n    }\n    /**\n     * @description Remove as much useless space as possible.\n     */\n    shrinkToFit() {\n        if (this._length === 0)\n            return;\n        const arr = [];\n        this.forEach(function (el) {\n            arr.push(el);\n        });\n        this._bucketNum = Math.max(Math.ceil(this._length / this._bucketSize), 1);\n        this._length = this._first = this._last = this._curFirst = this._curLast = 0;\n        this._map = [];\n        for (let i = 0; i < this._bucketNum; ++i) {\n            this._map.push(new Array(this._bucketSize));\n        }\n        for (let i = 0; i < arr.length; ++i)\n            this.pushBack(arr[i]);\n    }\n    forEach(callback) {\n        for (let i = 0; i < this._length; ++i) {\n            callback(this.getElementByPos(i), i, this);\n        }\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            for (let i = 0; i < this._length; ++i) {\n                yield this.getElementByPos(i);\n            }\n        }.bind(this)();\n    }\n}\nexport default Deque;\n","import SequentialContainer from './Base';\nimport { IteratorType, initContainer } from '@/container/ContainerBase';\nimport { RandomIterator } from '@/container/SequentialContainer/Base/RandomIterator';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\n\nclass DequeIterator<T> extends RandomIterator<T> {\n  copy() {\n    return new DequeIterator(\n      this._node,\n      this._size,\n      this._getElementByPos,\n      this._setElementByPos,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: DequeIterator<T>): boolean;\n}\n\nexport type { DequeIterator };\n\nclass Deque<T> extends SequentialContainer<T> {\n  /**\n   * @internal\n   */\n  private _first = 0;\n  /**\n   * @internal\n   */\n  private _curFirst = 0;\n  /**\n   * @internal\n   */\n  private _last = 0;\n  /**\n   * @internal\n   */\n  private _curLast = 0;\n  /**\n   * @internal\n   */\n  private _bucketNum = 0;\n  /**\n   * @internal\n   */\n  private readonly _bucketSize: number;\n  /**\n   * @internal\n   */\n  private _map: T[][] = [];\n  constructor(container: initContainer<T> = [], _bucketSize = (1 << 12)) {\n    super();\n    let _length;\n    if ('size' in container) {\n      if (typeof container.size === 'number') {\n        _length = container.size;\n      } else {\n        _length = container.size();\n      }\n    } else if ('length' in container) {\n      _length = container.length;\n    } else {\n      throw new RangeError('Can\\'t get container\\'s size!');\n    }\n    this._bucketSize = _bucketSize;\n    this._bucketNum = Math.max(Math.ceil(_length / this._bucketSize), 1);\n    for (let i = 0; i < this._bucketNum; ++i) {\n      this._map.push(new Array(this._bucketSize));\n    }\n    const needBucketNum = Math.ceil(_length / this._bucketSize);\n    this._first = this._last = (this._bucketNum >> 1) - (needBucketNum >> 1);\n    this._curFirst = this._curLast = (this._bucketSize - _length % this._bucketSize) >> 1;\n    const self = this;\n    container.forEach(function (element) {\n      self.pushBack(element);\n    });\n    this.size = this.size.bind(this);\n    this.getElementByPos = this.getElementByPos.bind(this);\n    this.setElementByPos = this.setElementByPos.bind(this);\n  }\n  /**\n   * @description Growth the Deque.\n   * @internal\n   */\n  private _reAllocate() {\n    const newMap = [];\n    const addBucketNum = Math.max(this._bucketNum >> 1, 1);\n    for (let i = 0; i < addBucketNum; ++i) {\n      newMap[i] = new Array(this._bucketSize);\n    }\n    for (let i = this._first; i < this._bucketNum; ++i) {\n      newMap[newMap.length] = this._map[i];\n    }\n    for (let i = 0; i < this._last; ++i) {\n      newMap[newMap.length] = this._map[i];\n    }\n    newMap[newMap.length] = [...this._map[this._last]];\n    this._first = addBucketNum;\n    this._last = newMap.length - 1;\n    for (let i = 0; i < addBucketNum; ++i) {\n      newMap[newMap.length] = new Array(this._bucketSize);\n    }\n    this._map = newMap;\n    this._bucketNum = newMap.length;\n  }\n  /**\n   * @description Get the bucket position of the element and the pointer position by index.\n   * @param pos - The element's index.\n   * @internal\n   */\n  private _getElementIndex(pos: number) {\n    const offset = this._curFirst + pos + 1;\n    const offsetRemainder = offset % this._bucketSize;\n    let curNodePointerIndex = offsetRemainder - 1;\n    let curNodeBucketIndex = this._first + (offset - offsetRemainder) / this._bucketSize;\n    if (offsetRemainder === 0) curNodeBucketIndex -= 1;\n    curNodeBucketIndex %= this._bucketNum;\n    if (curNodePointerIndex < 0) curNodePointerIndex += this._bucketSize;\n    return { curNodeBucketIndex, curNodePointerIndex };\n  }\n  clear() {\n    this._map = [[]];\n    this._bucketNum = 1;\n    this._first = this._last = this._length = 0;\n    this._curFirst = this._curLast = this._bucketSize >> 1;\n  }\n  begin() {\n    return new DequeIterator<T>(\n      0,\n      this.size,\n      this.getElementByPos,\n      this.setElementByPos\n    );\n  }\n  end() {\n    return new DequeIterator(\n      this._length,\n      this.size,\n      this.getElementByPos,\n      this.setElementByPos\n    );\n  }\n  rBegin() {\n    return new DequeIterator(\n      this._length - 1,\n      this.size,\n      this.getElementByPos,\n      this.setElementByPos,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new DequeIterator(\n      -1,\n      this.size,\n      this.getElementByPos,\n      this.setElementByPos,\n      IteratorType.REVERSE\n    );\n  }\n  front(): T | undefined {\n    return this._map[this._first][this._curFirst];\n  }\n  back(): T | undefined {\n    return this._map[this._last][this._curLast];\n  }\n  pushBack(element: T) {\n    if (this._length) {\n      if (this._curLast < this._bucketSize - 1) {\n        this._curLast += 1;\n      } else if (this._last < this._bucketNum - 1) {\n        this._last += 1;\n        this._curLast = 0;\n      } else {\n        this._last = 0;\n        this._curLast = 0;\n      }\n      if (\n        this._last === this._first &&\n        this._curLast === this._curFirst\n      ) this._reAllocate();\n    }\n    this._length += 1;\n    this._map[this._last][this._curLast] = element;\n    return this._length;\n  }\n  popBack() {\n    if (this._length === 0) return;\n    const value = this._map[this._last][this._curLast];\n    delete this._map[this._last][this._curLast];\n    if (this._length !== 1) {\n      if (this._curLast > 0) {\n        this._curLast -= 1;\n      } else if (this._last > 0) {\n        this._last -= 1;\n        this._curLast = this._bucketSize - 1;\n      } else {\n        this._last = this._bucketNum - 1;\n        this._curLast = this._bucketSize - 1;\n      }\n    }\n    this._length -= 1;\n    return value;\n  }\n  /**\n   * @description Push the element to the front.\n   * @param element - The element you want to push.\n   * @returns The size of queue after pushing.\n   */\n  pushFront(element: T) {\n    if (this._length) {\n      if (this._curFirst > 0) {\n        this._curFirst -= 1;\n      } else if (this._first > 0) {\n        this._first -= 1;\n        this._curFirst = this._bucketSize - 1;\n      } else {\n        this._first = this._bucketNum - 1;\n        this._curFirst = this._bucketSize - 1;\n      }\n      if (\n        this._first === this._last &&\n        this._curFirst === this._curLast\n      ) this._reAllocate();\n    }\n    this._length += 1;\n    this._map[this._first][this._curFirst] = element;\n    return this._length;\n  }\n  /**\n   * @description Remove the _first element.\n   * @returns The element you popped.\n   */\n  popFront() {\n    if (this._length === 0) return;\n    const value = this._map[this._first][this._curFirst];\n    delete this._map[this._first][this._curFirst];\n    if (this._length !== 1) {\n      if (this._curFirst < this._bucketSize - 1) {\n        this._curFirst += 1;\n      } else if (this._first < this._bucketNum - 1) {\n        this._first += 1;\n        this._curFirst = 0;\n      } else {\n        this._first = 0;\n        this._curFirst = 0;\n      }\n    }\n    this._length -= 1;\n    return value;\n  }\n  getElementByPos(pos: number): T {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const {\n      curNodeBucketIndex,\n      curNodePointerIndex\n    } = this._getElementIndex(pos);\n    return this._map[curNodeBucketIndex][curNodePointerIndex]!;\n  }\n  setElementByPos(pos: number, element: T) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const {\n      curNodeBucketIndex,\n      curNodePointerIndex\n    } = this._getElementIndex(pos);\n    this._map[curNodeBucketIndex][curNodePointerIndex] = element;\n  }\n  insert(pos: number, element: T, num = 1) {\n    $checkWithinAccessParams!(pos, 0, this._length);\n    if (pos === 0) {\n      while (num--) this.pushFront(element);\n    } else if (pos === this._length) {\n      while (num--) this.pushBack(element);\n    } else {\n      const arr: T[] = [];\n      for (let i = pos; i < this._length; ++i) {\n        arr.push(this.getElementByPos(i));\n      }\n      this.cut(pos - 1);\n      for (let i = 0; i < num; ++i) this.pushBack(element);\n      for (let i = 0; i < arr.length; ++i) this.pushBack(arr[i]);\n    }\n    return this._length;\n  }\n  /**\n   * @description Remove all elements after the specified position (excluding the specified position).\n   * @param pos - The previous position of the first removed element.\n   * @returns The size of the container after cutting.\n   * @example\n   * deque.cut(1); // Then deque's size will be 2. deque -> [0, 1]\n   */\n  cut(pos: number) {\n    if (pos < 0) {\n      this.clear();\n      return 0;\n    }\n    const {\n      curNodeBucketIndex,\n      curNodePointerIndex\n    } = this._getElementIndex(pos);\n    this._last = curNodeBucketIndex;\n    this._curLast = curNodePointerIndex;\n    this._length = pos + 1;\n    return this._length;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    if (pos === 0) this.popFront();\n    else if (pos === this._length - 1) this.popBack();\n    else {\n      const arr = [];\n      for (let i = pos + 1; i < this._length; ++i) {\n        arr.push(this.getElementByPos(i));\n      }\n      this.cut(pos);\n      this.popBack();\n      const self = this;\n      arr.forEach(function (el) {\n        self.pushBack(el);\n      });\n    }\n    return this._length;\n  }\n  eraseElementByValue(value: T) {\n    if (this._length === 0) return 0;\n    const arr: T[] = [];\n    for (let i = 0; i < this._length; ++i) {\n      const element = this.getElementByPos(i);\n      if (element !== value) arr.push(element);\n    }\n    const _length = arr.length;\n    for (let i = 0; i < _length; ++i) this.setElementByPos(i, arr[i]);\n    return this.cut(_length - 1);\n  }\n  eraseElementByIterator(iter: DequeIterator<T>) {\n    const _node = iter._node;\n    this.eraseElementByPos(_node);\n    iter = iter.next();\n    return iter;\n  }\n  find(element: T) {\n    for (let i = 0; i < this._length; ++i) {\n      if (this.getElementByPos(i) === element) {\n        return new DequeIterator(\n          i,\n          this.size,\n          this.getElementByPos,\n          this.setElementByPos\n        );\n      }\n    }\n    return this.end();\n  }\n  reverse() {\n    let l = 0; let r = this._length - 1;\n    while (l < r) {\n      const tmp = this.getElementByPos(l);\n      this.setElementByPos(l, this.getElementByPos(r));\n      this.setElementByPos(r, tmp);\n      l += 1;\n      r -= 1;\n    }\n  }\n  unique() {\n    if (this._length <= 1) {\n      return this._length;\n    }\n    let index = 1;\n    let pre = this.getElementByPos(0);\n    for (let i = 1; i < this._length; ++i) {\n      const cur = this.getElementByPos(i);\n      if (cur !== pre) {\n        pre = cur;\n        this.setElementByPos(index++, cur);\n      }\n    }\n    while (this._length > index) this.popBack();\n    return this._length;\n  }\n  sort(cmp?: (x: T, y: T) => number) {\n    const arr: T[] = [];\n    for (let i = 0; i < this._length; ++i) {\n      arr.push(this.getElementByPos(i));\n    }\n    arr.sort(cmp);\n    for (let i = 0; i < this._length; ++i) this.setElementByPos(i, arr[i]);\n  }\n  /**\n   * @description Remove as much useless space as possible.\n   */\n  shrinkToFit() {\n    if (this._length === 0) return;\n    const arr: T[] = [];\n    this.forEach(function (el) {\n      arr.push(el);\n    });\n    this._bucketNum = Math.max(Math.ceil(this._length / this._bucketSize), 1);\n    this._length = this._first = this._last = this._curFirst = this._curLast = 0;\n    this._map = [];\n    for (let i = 0; i < this._bucketNum; ++i) {\n      this._map.push(new Array(this._bucketSize));\n    }\n    for (let i = 0; i < arr.length; ++i) this.pushBack(arr[i]);\n  }\n  forEach(callback: (element: T, index: number, deque: Deque<T>) => void) {\n    for (let i = 0; i < this._length; ++i) {\n      callback(this.getElementByPos(i), i, this);\n    }\n  }\n  [Symbol.iterator]() {\n    return function * (this: Deque<T>) {\n      for (let i = 0; i < this._length; ++i) {\n        yield this.getElementByPos(i);\n      }\n    }.bind(this)();\n  }\n}\n\nexport default Deque;\n"]}