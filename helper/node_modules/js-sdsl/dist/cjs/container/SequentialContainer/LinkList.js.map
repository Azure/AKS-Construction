{"version":3,"sources":["container/SequentialContainer/LinkList.js","../../src/container/SequentialContainer/LinkList.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_ContainerBase","_throwError","obj","__esModule","LinkListIterator","ContainerIterator","constructor","_node","_header","iteratorType","super","this","pre","_pre","throwIteratorAccessError","next","_next","pointer","_value","newValue","copy","LinkList","SequentialContainer","container","_head","_tail","self","forEach","el","pushBack","_eraseNode","node","L","B","_length","_insertNode","clear","begin","end","rBegin","rEnd","front","back","getElementByPos","pos","RangeError","curNode","eraseElementByPos","eraseElementByValue","eraseElementByIterator","iter","element","popBack","pushFront","popFront","setElementByPos","insert","num","i","find","reverse","pHead","pTail","cnt","tmp","unique","tmpNode","sort","cmp","arr","push","merge","list","callback","index","Symbol","iterator","bind","_default"],"mappings":"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","file":"LinkList.js","sourcesContent":["import SequentialContainer from './Base';\nimport { ContainerIterator } from \"../ContainerBase\";\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass LinkListIterator extends ContainerIterator {\n    /**\n     * @internal\n     */\n    constructor(_node, _header, iteratorType) {\n        super(iteratorType);\n        this._node = _node;\n        this._header = _header;\n        if (this.iteratorType === 0 /* IteratorType.NORMAL */) {\n            this.pre = function () {\n                if (this._node._pre === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._pre;\n                return this;\n            };\n            this.next = function () {\n                if (this._node === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._next;\n                return this;\n            };\n        }\n        else {\n            this.pre = function () {\n                if (this._node._next === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._next;\n                return this;\n            };\n            this.next = function () {\n                if (this._node === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._pre;\n                return this;\n            };\n        }\n    }\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        return this._node._value;\n    }\n    set pointer(newValue) {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        this._node._value = newValue;\n    }\n    copy() {\n        return new LinkListIterator(this._node, this._header, this.iteratorType);\n    }\n}\nclass LinkList extends SequentialContainer {\n    constructor(container = []) {\n        super();\n        this._header = {};\n        this._head = this._tail = this._header._pre = this._header._next = this._header;\n        const self = this;\n        container.forEach(function (el) {\n            self.pushBack(el);\n        });\n    }\n    /**\n     * @internal\n     */\n    _eraseNode(node) {\n        const { _pre, _next } = node;\n        _pre._next = _next;\n        _next._pre = _pre;\n        if (node === this._head) {\n            this._head = _next;\n        }\n        if (node === this._tail) {\n            this._tail = _pre;\n        }\n        this._length -= 1;\n    }\n    /**\n     * @internal\n     */\n    _insertNode(value, pre) {\n        const next = pre._next;\n        const node = {\n            _value: value,\n            _pre: pre,\n            _next: next\n        };\n        pre._next = node;\n        next._pre = node;\n        if (pre === this._header) {\n            this._head = node;\n        }\n        if (next === this._header) {\n            this._tail = node;\n        }\n        this._length += 1;\n    }\n    clear() {\n        this._length = 0;\n        this._head = this._tail = this._header._pre = this._header._next = this._header;\n    }\n    begin() {\n        return new LinkListIterator(this._head, this._header);\n    }\n    end() {\n        return new LinkListIterator(this._header, this._header);\n    }\n    rBegin() {\n        return new LinkListIterator(this._tail, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new LinkListIterator(this._header, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        return this._head._value;\n    }\n    back() {\n        return this._tail._value;\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let curNode = this._head;\n        while (pos--) {\n            curNode = curNode._next;\n        }\n        return curNode._value;\n    }\n    eraseElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let curNode = this._head;\n        while (pos--) {\n            curNode = curNode._next;\n        }\n        this._eraseNode(curNode);\n        return this._length;\n    }\n    eraseElementByValue(_value) {\n        let curNode = this._head;\n        while (curNode !== this._header) {\n            if (curNode._value === _value) {\n                this._eraseNode(curNode);\n            }\n            curNode = curNode._next;\n        }\n        return this._length;\n    }\n    eraseElementByIterator(iter) {\n        const node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        iter = iter.next();\n        this._eraseNode(node);\n        return iter;\n    }\n    pushBack(element) {\n        this._insertNode(element, this._tail);\n        return this._length;\n    }\n    popBack() {\n        if (this._length === 0)\n            return;\n        const value = this._tail._value;\n        this._eraseNode(this._tail);\n        return value;\n    }\n    /**\n     * @description Push an element to the front.\n     * @param element - The element you want to push.\n     * @returns The size of queue after pushing.\n     */\n    pushFront(element) {\n        this._insertNode(element, this._header);\n        return this._length;\n    }\n    /**\n     * @description Removes the first element.\n     * @returns The element you popped.\n     */\n    popFront() {\n        if (this._length === 0)\n            return;\n        const value = this._head._value;\n        this._eraseNode(this._head);\n        return value;\n    }\n    setElementByPos(pos, element) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let curNode = this._head;\n        while (pos--) {\n            curNode = curNode._next;\n        }\n        curNode._value = element;\n    }\n    insert(pos, element, num = 1) {\n        if (pos < 0 || pos > this._length) {\n            throw new RangeError();\n        }\n        if (num <= 0)\n            return this._length;\n        if (pos === 0) {\n            while (num--)\n                this.pushFront(element);\n        }\n        else if (pos === this._length) {\n            while (num--)\n                this.pushBack(element);\n        }\n        else {\n            let curNode = this._head;\n            for (let i = 1; i < pos; ++i) {\n                curNode = curNode._next;\n            }\n            const next = curNode._next;\n            this._length += num;\n            while (num--) {\n                curNode._next = {\n                    _value: element,\n                    _pre: curNode\n                };\n                curNode._next._pre = curNode;\n                curNode = curNode._next;\n            }\n            curNode._next = next;\n            next._pre = curNode;\n        }\n        return this._length;\n    }\n    find(element) {\n        let curNode = this._head;\n        while (curNode !== this._header) {\n            if (curNode._value === element) {\n                return new LinkListIterator(curNode, this._header);\n            }\n            curNode = curNode._next;\n        }\n        return this.end();\n    }\n    reverse() {\n        if (this._length <= 1)\n            return;\n        let pHead = this._head;\n        let pTail = this._tail;\n        let cnt = 0;\n        while ((cnt << 1) < this._length) {\n            const tmp = pHead._value;\n            pHead._value = pTail._value;\n            pTail._value = tmp;\n            pHead = pHead._next;\n            pTail = pTail._pre;\n            cnt += 1;\n        }\n    }\n    unique() {\n        if (this._length <= 1) {\n            return this._length;\n        }\n        let curNode = this._head;\n        while (curNode !== this._header) {\n            let tmpNode = curNode;\n            while (tmpNode._next !== this._header &&\n                tmpNode._value === tmpNode._next._value) {\n                tmpNode = tmpNode._next;\n                this._length -= 1;\n            }\n            curNode._next = tmpNode._next;\n            curNode._next._pre = curNode;\n            curNode = curNode._next;\n        }\n        return this._length;\n    }\n    sort(cmp) {\n        if (this._length <= 1)\n            return;\n        const arr = [];\n        this.forEach(function (el) {\n            arr.push(el);\n        });\n        arr.sort(cmp);\n        let curNode = this._head;\n        arr.forEach(function (element) {\n            curNode._value = element;\n            curNode = curNode._next;\n        });\n    }\n    /**\n     * @description Merges two sorted lists.\n     * @param list - The other list you want to merge (must be sorted).\n     * @returns The size of list after merging.\n     * @example\n     * const linkA = new LinkList([1, 3, 5]);\n     * const linkB = new LinkList([2, 4, 6]);\n     * linkA.merge(linkB);  // [1, 2, 3, 4, 5];\n     */\n    merge(list) {\n        const self = this;\n        if (this._length === 0) {\n            list.forEach(function (el) {\n                self.pushBack(el);\n            });\n        }\n        else {\n            let curNode = this._head;\n            list.forEach(function (el) {\n                while (curNode !== self._header &&\n                    curNode._value <= el) {\n                    curNode = curNode._next;\n                }\n                self._insertNode(el, curNode._pre);\n            });\n        }\n        return this._length;\n    }\n    forEach(callback) {\n        let curNode = this._head;\n        let index = 0;\n        while (curNode !== this._header) {\n            callback(curNode._value, index++, this);\n            curNode = curNode._next;\n        }\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            if (this._length === 0)\n                return;\n            let curNode = this._head;\n            while (curNode !== this._header) {\n                yield curNode._value;\n                curNode = curNode._next;\n            }\n        }.bind(this)();\n    }\n}\nexport default LinkList;\n","import SequentialContainer from './Base';\nimport { ContainerIterator, initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\ntype LinkNode<T> = {\n  _value: T;\n  _pre: LinkNode<T>;\n  _next: LinkNode<T>;\n}\n\nclass LinkListIterator<T> extends ContainerIterator<T> {\n  /**\n   * @internal\n   */\n  _node: LinkNode<T>;\n  /**\n   * @internal\n   */\n  private readonly _header: LinkNode<T>;\n  /**\n   * @internal\n   */\n  constructor(\n    _node: LinkNode<T>,\n    _header: LinkNode<T>,\n    iteratorType?: IteratorType\n  ) {\n    super(iteratorType);\n    this._node = _node;\n    this._header = _header;\n    if (this.iteratorType === IteratorType.NORMAL) {\n      this.pre = function () {\n        if (this._node._pre === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre;\n        return this;\n      };\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next;\n        return this;\n      };\n    } else {\n      this.pre = function () {\n        if (this._node._next === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next;\n        return this;\n      };\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre;\n        return this;\n      };\n    }\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    return this._node._value;\n  }\n  set pointer(newValue: T) {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    this._node._value = newValue;\n  }\n  copy() {\n    return new LinkListIterator(\n      this._node,\n      this._header,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: LinkListIterator<T>): boolean;\n  // @ts-ignore\n  pre(): this;\n  // @ts-ignore\n  next(): this;\n}\n\nexport type { LinkListIterator };\n\nclass LinkList<T> extends SequentialContainer<T> {\n  /**\n   * @internal\n   */\n  private _head: LinkNode<T>;\n  /**\n   * @internal\n   */\n  private _tail: LinkNode<T>;\n  /**\n   * @internal\n   */\n  private readonly _header: LinkNode<T>;\n  constructor(container: initContainer<T> = []) {\n    super();\n    this._header = <LinkNode<T>>{};\n    this._head = this._tail = this._header._pre = this._header._next = this._header;\n    const self = this;\n    container.forEach(function (el) {\n      self.pushBack(el);\n    });\n  }\n  /**\n   * @internal\n   */\n  private _eraseNode(node: LinkNode<T>) {\n    const { _pre, _next } = node;\n    _pre._next = _next;\n    _next._pre = _pre;\n    if (node === this._head) {\n      this._head = _next;\n    }\n    if (node === this._tail) {\n      this._tail = _pre;\n    }\n    this._length -= 1;\n  }\n  /**\n   * @internal\n   */\n  private _insertNode(value: T, pre: LinkNode<T>) {\n    const next = pre._next;\n    const node = {\n      _value: value,\n      _pre: pre,\n      _next: next\n    };\n    pre._next = node;\n    next._pre = node;\n    if (pre === this._header) {\n      this._head = node;\n    }\n    if (next === this._header) {\n      this._tail = node;\n    }\n    this._length += 1;\n  }\n  clear() {\n    this._length = 0;\n    this._head = this._tail = this._header._pre = this._header._next = this._header;\n  }\n  begin() {\n    return new LinkListIterator(this._head, this._header);\n  }\n  end() {\n    return new LinkListIterator(this._header, this._header);\n  }\n  rBegin() {\n    return new LinkListIterator(this._tail, this._header, IteratorType.REVERSE);\n  }\n  rEnd() {\n    return new LinkListIterator(this._header, this._header, IteratorType.REVERSE);\n  }\n  front(): T | undefined {\n    return this._head._value;\n  }\n  back(): T | undefined {\n    return this._tail._value;\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let curNode = this._head;\n    while (pos--) {\n      curNode = curNode._next;\n    }\n    return curNode._value;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let curNode = this._head;\n    while (pos--) {\n      curNode = curNode._next;\n    }\n    this._eraseNode(curNode);\n    return this._length;\n  }\n  eraseElementByValue(_value: T) {\n    let curNode = this._head;\n    while (curNode !== this._header) {\n      if (curNode._value === _value) {\n        this._eraseNode(curNode);\n      }\n      curNode = curNode._next;\n    }\n    return this._length;\n  }\n  eraseElementByIterator(iter: LinkListIterator<T>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    iter = iter.next();\n    this._eraseNode(node);\n    return iter;\n  }\n  pushBack(element: T) {\n    this._insertNode(element, this._tail);\n    return this._length;\n  }\n  popBack() {\n    if (this._length === 0) return;\n    const value = this._tail._value;\n    this._eraseNode(this._tail);\n    return value;\n  }\n  /**\n   * @description Push an element to the front.\n   * @param element - The element you want to push.\n   * @returns The size of queue after pushing.\n   */\n  pushFront(element: T) {\n    this._insertNode(element, this._header);\n    return this._length;\n  }\n  /**\n   * @description Removes the first element.\n   * @returns The element you popped.\n   */\n  popFront() {\n    if (this._length === 0) return;\n    const value = this._head._value;\n    this._eraseNode(this._head);\n    return value;\n  }\n  setElementByPos(pos: number, element: T) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let curNode = this._head;\n    while (pos--) {\n      curNode = curNode._next;\n    }\n    curNode._value = element;\n  }\n  insert(pos: number, element: T, num = 1) {\n    $checkWithinAccessParams!(pos, 0, this._length);\n    if (num <= 0) return this._length;\n    if (pos === 0) {\n      while (num--) this.pushFront(element);\n    } else if (pos === this._length) {\n      while (num--) this.pushBack(element);\n    } else {\n      let curNode = this._head;\n      for (let i = 1; i < pos; ++i) {\n        curNode = curNode._next;\n      }\n      const next = curNode._next;\n      this._length += num;\n      while (num--) {\n        curNode._next = <LinkNode<T>>{\n          _value: element,\n          _pre: curNode\n        };\n        curNode._next._pre = curNode;\n        curNode = curNode._next;\n      }\n      curNode._next = next;\n      next._pre = curNode;\n    }\n    return this._length;\n  }\n  find(element: T) {\n    let curNode = this._head;\n    while (curNode !== this._header) {\n      if (curNode._value === element) {\n        return new LinkListIterator(curNode, this._header);\n      }\n      curNode = curNode._next;\n    }\n    return this.end();\n  }\n  reverse() {\n    if (this._length <= 1) return;\n    let pHead = this._head;\n    let pTail = this._tail;\n    let cnt = 0;\n    while ((cnt << 1) < this._length) {\n      const tmp = pHead._value;\n      pHead._value = pTail._value;\n      pTail._value = tmp;\n      pHead = pHead._next;\n      pTail = pTail._pre;\n      cnt += 1;\n    }\n  }\n  unique() {\n    if (this._length <= 1) {\n      return this._length;\n    }\n    let curNode = this._head;\n    while (curNode !== this._header) {\n      let tmpNode = curNode;\n      while (\n        tmpNode._next !== this._header &&\n        tmpNode._value === tmpNode._next._value\n      ) {\n        tmpNode = tmpNode._next;\n        this._length -= 1;\n      }\n      curNode._next = tmpNode._next;\n      curNode._next._pre = curNode;\n      curNode = curNode._next;\n    }\n    return this._length;\n  }\n  sort(cmp?: (x: T, y: T) => number) {\n    if (this._length <= 1) return;\n    const arr: T[] = [];\n    this.forEach(function (el) {\n      arr.push(el);\n    });\n    arr.sort(cmp);\n    let curNode: LinkNode<T> = this._head;\n    arr.forEach(function (element) {\n      curNode._value = element;\n      curNode = curNode._next;\n    });\n  }\n  /**\n   * @description Merges two sorted lists.\n   * @param list - The other list you want to merge (must be sorted).\n   * @returns The size of list after merging.\n   * @example\n   * const linkA = new LinkList([1, 3, 5]);\n   * const linkB = new LinkList([2, 4, 6]);\n   * linkA.merge(linkB);  // [1, 2, 3, 4, 5];\n   */\n  merge(list: LinkList<T>) {\n    const self = this;\n    if (this._length === 0) {\n      list.forEach(function (el) {\n        self.pushBack(el);\n      });\n    } else {\n      let curNode = this._head;\n      list.forEach(function (el) {\n        while (\n          curNode !== self._header &&\n          curNode._value <= el\n        ) {\n          curNode = curNode._next;\n        }\n        self._insertNode(el, curNode._pre);\n      });\n    }\n    return this._length;\n  }\n  forEach(callback: (element: T, index: number, list: LinkList<T>) => void) {\n    let curNode = this._head;\n    let index = 0;\n    while (curNode !== this._header) {\n      callback(curNode._value, index++, this);\n      curNode = curNode._next;\n    }\n  }\n  [Symbol.iterator]() {\n    return function * (this: LinkList<T>) {\n      if (this._length === 0) return;\n      let curNode = this._head;\n      while (curNode !== this._header) {\n        yield curNode._value;\n        curNode = curNode._next;\n      }\n    }.bind(this)();\n  }\n}\n\nexport default LinkList;\n"]}