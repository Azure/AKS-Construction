{"version":3,"sources":["container/HashContainer/HashMap.js","../../src/container/HashContainer/HashMap.ts"],"names":["Object","defineProperty","exports","value","default","_Base","require","_checkObject","_interopRequireDefault","_throwError","obj","__esModule","HashMapIterator","HashContainerIterator","pointer","this","_node","_header","throwIteratorAccessError","self","Proxy","get","_","props","_key","_value","set","newValue","TypeError","copy","iteratorType","HashMap","HashContainer","constructor","container","super","forEach","el","setElement","begin","_head","end","rBegin","_tail","rEnd","front","_length","back","key","isObject","_set","getElementByKey","undefined","checkObject","index","HASH_TAG","_objMap","node","_originMap","getElementByPos","pos","RangeError","_next","find","_findElementNode","callback","Symbol","iterator","bind","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACJvB,IAAAC,QAAAC,QAAA;;AACA,IAAAC,eAAAC,uBAAAF,QAAA;;AAEA,IAAAG,cAAAH,QAAA;;AAA8D,SAAAE,uBAAAE;IAAA,OAAAA,KAAAA,EAAAC,IAAAD,IAAA;QAAAN,SAAAM;;AAAA;;AAE9D,MAAME,wBAA8BC,MAAAA;IAC9BC;QACF,IAAIC,KAAKC,MAAUD,KAAKE,GAAS;aAC/B,GAAAC,YAAAA;ADDE;QCGJ,MAAMC,IAAOJ;QACb,OAAO,IAAIK,MAAuB,IAAI;YACpCC,IAAIC,GAAGC;gBACL,IAAIA,MAAU,KAAK,OAAOJ,EAAKH,EAAMQ,QAChC,IAAID,MAAU,KAAK,OAAOJ,EAAKH,EAAMS;ADCtC;YCCNC,IAAIJ,GAAGC,GAAYI;gBACjB,IAAIJ,MAAU,KAAK;oBACjB,MAAM,IAAIK,UAAU;ADCd;gBCCRT,EAAKH,EAAMS,IAASE;gBACpB,OAAO;ADCH;;AAER;ICCFE;QACE,OAAO,IAAIjB,gBAAgBG,KAAKC,GAAOD,KAAKE,GAASF,KAAKe;ADC1D;;;ACOJ,MAAMC,gBAAsBC,MAAAA;IAC1BC,YAAYC,IAAmC;QAC7CC;QACA,MAAMhB,IAAOJ;QACbmB,EAAUE,SAAQ,SAAUC;YAC1BlB,EAAKmB,WAAWD,EAAG,IAAIA,EAAG;ADJxB;AACJ;ICMFE;QACE,OAAO,IAAI3B,gBAAgBG,KAAKyB,GAAOzB,KAAKE;ADJ5C;ICMFwB;QACE,OAAO,IAAI7B,gBAAgBG,KAAKE,GAASF,KAAKE;ADJ9C;ICMFyB;QACE,OAAO,IAAI9B,gBAAgBG,KAAK4B,GAAO5B,KAAKE,GAAO;ADJnD;ICMF2B;QACE,OAAO,IAAIhC,gBAAgBG,KAAKE,GAASF,KAAKE,GAAO;ADJrD;ICMF4B;QACE,IAAI9B,KAAK+B,MAAY,GAAG;QACxB,OAAe,EAAC/B,KAAKyB,EAAMhB,GAAMT,KAAKyB,EAAMf;ADH5C;ICKFsB;QACE,IAAIhC,KAAK+B,MAAY,GAAG;QACxB,OAAe,EAAC/B,KAAK4B,EAAMnB,GAAMT,KAAK4B,EAAMlB;ADF5C;ICYFa,WAAWU,GAAQ7C,GAAU8C;QAC3B,OAAOlC,KAAKmC,EAAKF,GAAK7C,GAAO8C;ADF7B;ICmBFE,gBAAgBH,GAAQC;QACtB,IAAIA,MAAaG,WAAWH,KAAW,GAAAI,aAAAA,SAAYL;QACnD,IAAIC,GAAU;YACZ,MAAMK,IAA0CN,EAAKjC,KAAKwC;YAC1D,OAAOD,MAAUF,YAAYrC,KAAKyC,EAAQF,GAAO7B,IAAS2B;ADDxD;QCGJ,MAAMK,IAAO1C,KAAK2C,EAA4BV;QAC9C,OAAOS,IAAOA,EAAKhC,IAAS2B;ADD5B;ICGFO,gBAAgBC;QDDV,ICEsBA,IAAG,KAAHA,IAAQ7C,KAAK+B,IAAO,GA7F7B;YAAE,MAAU,IAAIe;AD6F7B;QCCJ,IAAIJ,IAAO1C,KAAKyB;QAChB,OAAOoB,KAAO;YACZH,IAAOA,EAAKK;ADCV;QCCJ,OAAe,EAACL,EAAKjC,GAAMiC,EAAKhC;ADChC;ICCFsC,KAAKf,GAAQC;QACX,MAAMQ,IAAO1C,KAAKiD,EAAiBhB,GAAKC;QACxC,OAAO,IAAIrC,gBAAgB6C,GAAM1C,KAAKE;ADCtC;ICCFmB,QAAQ6B;QACN,IAAIX,IAAQ;QACZ,IAAIG,IAAO1C,KAAKyB;QAChB,OAAOiB,MAAS1C,KAAKE,GAAS;YAC5BgD,EAAiB,EAACR,EAAKjC,GAAMiC,EAAKhC,KAAS6B,KAASvC;YACpD0C,IAAOA,EAAKK;ADCV;AACJ;ICCF,CAACI,OAAOC;QACN,OAAO;YACL,IAAIV,IAAO1C,KAAKyB;YAChB,OAAOiB,MAAS1C,KAAKE,GAAS;sBACd,EAACwC,EAAKjC,GAAMiC,EAAKhC;gBAC/BgC,IAAOA,EAAKK;ADCR;AACJ,UCAFM,KAAKrD,KANA;ADOP;;;ACCH,IAAAsD,WAEctC;;AAAO7B,QAAAE,UAAAiE","file":"HashMap.js","sourcesContent":["import { HashContainer, HashContainerIterator } from \"./Base\";\nimport checkObject from \"../../utils/checkObject\";\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass HashMapIterator extends HashContainerIterator {\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        const self = this;\n        return new Proxy([], {\n            get(_, props) {\n                if (props === '0')\n                    return self._node._key;\n                else if (props === '1')\n                    return self._node._value;\n            },\n            set(_, props, newValue) {\n                if (props !== '1') {\n                    throw new TypeError('props must be 1');\n                }\n                self._node._value = newValue;\n                return true;\n            }\n        });\n    }\n    copy() {\n        return new HashMapIterator(this._node, this._header, this.iteratorType);\n    }\n}\nclass HashMap extends HashContainer {\n    constructor(container = []) {\n        super();\n        const self = this;\n        container.forEach(function (el) {\n            self.setElement(el[0], el[1]);\n        });\n    }\n    begin() {\n        return new HashMapIterator(this._head, this._header);\n    }\n    end() {\n        return new HashMapIterator(this._header, this._header);\n    }\n    rBegin() {\n        return new HashMapIterator(this._tail, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new HashMapIterator(this._header, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        if (this._length === 0)\n            return;\n        return [this._head._key, this._head._value];\n    }\n    back() {\n        if (this._length === 0)\n            return;\n        return [this._tail._key, this._tail._value];\n    }\n    /**\n     * @description Insert a key-value pair or set value by the given key.\n     * @param key - The key want to insert.\n     * @param value - The value want to set.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @returns The size of container after setting.\n     */\n    setElement(key, value, isObject) {\n        return this._set(key, value, isObject);\n    }\n    /**\n     * @description Check key if exist in container.\n     * @param key - The element you want to search.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @returns An iterator pointing to the element if found, or super end if not found.\n     */\n    /**\n     * @description Get the value of the element of the specified key.\n     * @param key - The key want to search.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @example\n     * const val = container.getElementByKey(1);\n     */\n    getElementByKey(key, isObject) {\n        if (isObject === undefined)\n            isObject = checkObject(key);\n        if (isObject) {\n            const index = key[this.HASH_TAG];\n            return index !== undefined ? this._objMap[index]._value : undefined;\n        }\n        const node = this._originMap[key];\n        return node ? node._value : undefined;\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let node = this._head;\n        while (pos--) {\n            node = node._next;\n        }\n        return [node._key, node._value];\n    }\n    find(key, isObject) {\n        const node = this._findElementNode(key, isObject);\n        return new HashMapIterator(node, this._header);\n    }\n    forEach(callback) {\n        let index = 0;\n        let node = this._head;\n        while (node !== this._header) {\n            callback([node._key, node._value], index++, this);\n            node = node._next;\n        }\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            let node = this._head;\n            while (node !== this._header) {\n                yield [node._key, node._value];\n                node = node._next;\n            }\n        }.bind(this)();\n    }\n}\nexport default HashMap;\n","import { initContainer, IteratorType } from '@/container/ContainerBase';\nimport { HashContainer, HashContainerIterator } from '@/container/HashContainer/Base';\nimport checkObject from '@/utils/checkObject';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass HashMapIterator<K, V> extends HashContainerIterator<K, V> {\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy(<[K, V]><unknown>[], {\n      get(_, props: '0' | '1') {\n        if (props === '0') return self._node._key;\n        else if (props === '1') return self._node._value;\n      },\n      set(_, props: '1', newValue: V) {\n        if (props !== '1') {\n          throw new TypeError('props must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new HashMapIterator(this._node, this._header, this.iteratorType);\n  }\n  // @ts-ignore\n  equals(iter: HashMapIterator<K, V>): boolean;\n}\n\nexport type { HashMapIterator };\n\nclass HashMap<K, V> extends HashContainer<K, V> {\n  constructor(container: initContainer<[K, V]> = []) {\n    super();\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new HashMapIterator(this._head, this._header);\n  }\n  end() {\n    return new HashMapIterator(this._header, this._header);\n  }\n  rBegin() {\n    return new HashMapIterator(this._tail, this._header, IteratorType.REVERSE);\n  }\n  rEnd() {\n    return new HashMapIterator(this._header, this._header, IteratorType.REVERSE);\n  }\n  front() {\n    if (this._length === 0) return;\n    return <[K, V]>[this._head._key, this._head._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    return <[K, V]>[this._tail._key, this._tail._value];\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @returns The size of container after setting.\n   */\n  setElement(key: K, value: V, isObject?: boolean) {\n    return this._set(key, value, isObject);\n  }\n  /**\n   * @description Check key if exist in container.\n   * @param key - The element you want to search.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @returns An iterator pointing to the element if found, or super end if not found.\n   */\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The key want to search.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key: K, isObject?: boolean) {\n    if (isObject === undefined) isObject = checkObject(key);\n    if (isObject) {\n      const index = (<Record<symbol, number>><unknown>key)[this.HASH_TAG];\n      return index !== undefined ? this._objMap[index]._value : undefined;\n    }\n    const node = this._originMap[<string><unknown>key];\n    return node ? node._value : undefined;\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let node = this._head;\n    while (pos--) {\n      node = node._next;\n    }\n    return <[K, V]>[node._key, node._value];\n  }\n  find(key: K, isObject?: boolean) {\n    const node = this._findElementNode(key, isObject);\n    return new HashMapIterator(node, this._header);\n  }\n  forEach(callback: (element: [K, V], index: number, hashMap: HashMap<K, V>) => void) {\n    let index = 0;\n    let node = this._head;\n    while (node !== this._header) {\n      callback(<[K, V]>[node._key, node._value], index++, this);\n      node = node._next;\n    }\n  }\n  [Symbol.iterator]() {\n    return function * (this: HashMap<K, V>) {\n      let node = this._head;\n      while (node !== this._header) {\n        yield <[K, V]>[node._key, node._value];\n        node = node._next;\n      }\n    }.bind(this)();\n  }\n}\n\nexport default HashMap;\n"]}