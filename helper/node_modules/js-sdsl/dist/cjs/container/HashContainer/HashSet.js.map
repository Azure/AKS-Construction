{"version":3,"sources":["container/HashContainer/HashSet.js","../../src/container/HashContainer/HashSet.ts"],"names":["Object","defineProperty","exports","value","default","_Base","require","_throwError","HashSetIterator","HashContainerIterator","pointer","this","_node","_header","throwIteratorAccessError","_key","copy","iteratorType","HashSet","HashContainer","constructor","container","super","self","forEach","el","insert","begin","_head","end","rBegin","_tail","rEnd","front","back","key","isObject","_set","undefined","getElementByPos","pos","_length","RangeError","node","_next","find","_findElementNode","callback","index","Symbol","iterator","bind","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACJvB,IAAAC,QAAAC,QAAA;;AAEA,IAAAC,cAAAD,QAAA;;AAEA,MAAME,wBAA8BC,MAAAA;IAC9BC;QACF,IAAIC,KAAKC,MAAUD,KAAKE,GAAS;aAC/B,GAAAC,YAAAA;ADDE;QCGJ,OAAOH,KAAKC,EAAMG;ADDlB;ICGFC;QACE,OAAO,IAAIR,gBAAgBG,KAAKC,GAAOD,KAAKE,GAASF,KAAKM;ADD1D;;;ACSJ,MAAMC,gBAAmBC,MAAAA;IACvBC,YAAYC,IAA8B;QACxCC;QACA,MAAMC,IAAOZ;QACbU,EAAUG,SAAQ,SAAUC;YAC1BF,EAAKG,OAAOD;ADNV;AACJ;ICQFE;QACE,OAAO,IAAInB,gBAAgBG,KAAKiB,GAAOjB,KAAKE;ADN5C;ICQFgB;QACE,OAAO,IAAIrB,gBAAgBG,KAAKE,GAASF,KAAKE;ADN9C;ICQFiB;QACE,OAAO,IAAItB,gBAAgBG,KAAKoB,GAAOpB,KAAKE,GAAO;ADNnD;ICQFmB;QACE,OAAO,IAAIxB,gBAAgBG,KAAKE,GAASF,KAAKE,GAAO;ADNrD;ICQFoB;QACE,OAAOtB,KAAKiB,EAAMb;ADNlB;ICQFmB;QACE,OAAOvB,KAAKoB,EAAMhB;ADNlB;ICeFW,OAAOS,GAAQC;QACb,OAAOzB,KAAK0B,EAAKF,GAAKG,WAAWF;ADNjC;ICQFG,gBAAgBC;QDNV,ICOsBA,IAAG,KAAHA,IAAQ7B,KAAK8B,IAAO,GApDhD;YAAE,MAAU,IACVC;AD8CI;QCMJ,IAAIC,IAAOhC,KAAKiB;QAChB,OAAOY,KAAO;YACZG,IAAOA,EAAKC;ADJV;QCMJ,OAAOD,EAAK5B;ADJZ;ICaF8B,KAAKV,GAAQC;QACX,MAAMO,IAAOhC,KAAKmC,EAAiBX,GAAKC;QACxC,OAAO,IAAI5B,gBAAgBmC,GAAMhC,KAAKE;ADJtC;ICMFW,QAAQuB;QACN,IAAIC,IAAQ;QACZ,IAAIL,IAAOhC,KAAKiB;QAChB,OAAOe,MAAShC,KAAKE,GAAS;YAC5BkC,EAASJ,EAAK5B,GAAMiC,KAASrC;YAC7BgC,IAAOA,EAAKC;ADJV;AACJ;ICMF,CAACK,OAAOC;QACN,OAAO;YACL,IAAIP,IAAOhC,KAAKiB;YAChB,OAAOe,MAAShC,KAAKE,GAAS;sBACtB8B,EAAK5B;gBACX4B,IAAOA,EAAKC;ADJR;AACJ,UCKFO,KAAKxC,KANA;ADEP;;;ACMH,IAAAyC,WAEclC;;AAAOhB,QAAAE,UAAAgD","file":"HashSet.js","sourcesContent":["import { HashContainer, HashContainerIterator } from \"./Base\";\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass HashSetIterator extends HashContainerIterator {\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        return this._node._key;\n    }\n    copy() {\n        return new HashSetIterator(this._node, this._header, this.iteratorType);\n    }\n}\nclass HashSet extends HashContainer {\n    constructor(container = []) {\n        super();\n        const self = this;\n        container.forEach(function (el) {\n            self.insert(el);\n        });\n    }\n    begin() {\n        return new HashSetIterator(this._head, this._header);\n    }\n    end() {\n        return new HashSetIterator(this._header, this._header);\n    }\n    rBegin() {\n        return new HashSetIterator(this._tail, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new HashSetIterator(this._header, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        return this._head._key;\n    }\n    back() {\n        return this._tail._key;\n    }\n    /**\n     * @description Insert element to set.\n     * @param key - The key want to insert.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @returns The size of container after inserting.\n     */\n    insert(key, isObject) {\n        return this._set(key, undefined, isObject);\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let node = this._head;\n        while (pos--) {\n            node = node._next;\n        }\n        return node._key;\n    }\n    /**\n     * @description Check key if exist in container.\n     * @param key - The element you want to search.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @returns An iterator pointing to the element if found, or super end if not found.\n     */\n    find(key, isObject) {\n        const node = this._findElementNode(key, isObject);\n        return new HashSetIterator(node, this._header);\n    }\n    forEach(callback) {\n        let index = 0;\n        let node = this._head;\n        while (node !== this._header) {\n            callback(node._key, index++, this);\n            node = node._next;\n        }\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            let node = this._head;\n            while (node !== this._header) {\n                yield node._key;\n                node = node._next;\n            }\n        }.bind(this)();\n    }\n}\nexport default HashSet;\n","import { initContainer, IteratorType } from '@/container/ContainerBase';\nimport { HashContainer, HashContainerIterator } from '@/container/HashContainer/Base';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass HashSetIterator<K, V> extends HashContainerIterator<K, V> {\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    return this._node._key;\n  }\n  copy() {\n    return new HashSetIterator(this._node, this._header, this.iteratorType);\n  }\n  // @ts-ignore\n  equals(iter: HashSetIterator<K, V>): boolean;\n}\n\nexport type { HashSetIterator };\n\nclass HashSet<K> extends HashContainer<K, undefined> {\n  constructor(container: initContainer<K> = []) {\n    super();\n    const self = this;\n    container.forEach(function (el) {\n      self.insert(el);\n    });\n  }\n  begin() {\n    return new HashSetIterator(this._head, this._header);\n  }\n  end() {\n    return new HashSetIterator(this._header, this._header);\n  }\n  rBegin() {\n    return new HashSetIterator(this._tail, this._header, IteratorType.REVERSE);\n  }\n  rEnd() {\n    return new HashSetIterator(this._header, this._header, IteratorType.REVERSE);\n  }\n  front(): K | undefined {\n    return this._head._key;\n  }\n  back(): K | undefined {\n    return this._tail._key;\n  }\n  /**\n   * @description Insert element to set.\n   * @param key - The key want to insert.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @returns The size of container after inserting.\n   */\n  insert(key: K, isObject?: boolean) {\n    return this._set(key, undefined, isObject);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let node = this._head;\n    while (pos--) {\n      node = node._next;\n    }\n    return node._key;\n  }\n  /**\n   * @description Check key if exist in container.\n   * @param key - The element you want to search.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @returns An iterator pointing to the element if found, or super end if not found.\n   */\n  find(key: K, isObject?: boolean) {\n    const node = this._findElementNode(key, isObject);\n    return new HashSetIterator(node, this._header);\n  }\n  forEach(callback: (element: K, index: number, container: HashSet<K>) => void) {\n    let index = 0;\n    let node = this._head;\n    while (node !== this._header) {\n      callback(node._key, index++, this);\n      node = node._next;\n    }\n  }\n  [Symbol.iterator]() {\n    return function * (this: HashSet<K>) {\n      let node = this._head;\n      while (node !== this._header) {\n        yield node._key;\n        node = node._next;\n      }\n    }.bind(this)();\n  }\n}\n\nexport default HashSet;\n"]}