{"version":3,"sources":["container/TreeContainer/Base/TreeIterator.js","../../src/container/TreeContainer/Base/TreeIterator.ts"],"names":["Object","defineProperty","exports","value","default","_ContainerBase","require","_throwError","TreeIterator","ContainerIterator","constructor","_node","_header","iteratorType","super","this","pre","_left","throwIteratorAccessError","_pre","next","_next","_right","index","root","_parent","_subTreeSize","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACHvB,IAAAC,iBAAAC,QAAA;;AACA,IAAAC,cAAAD,QAAA;;AAEA,MAAeE,qBAA2BC,eAAAA;IAYxCC,YACEC,GACAC,GACAC;QAEAC,MAAMD;QACNE,KAAKJ,IAAQA;QACbI,KAAKH,IAAUA;QAEf,IAAIG,KAAKF,iBAAY,GAA0B;YAC7CE,KAAKC,MAAM;gBACT,IAAID,KAAKJ,MAAUI,KAAKH,EAAQK,GAAO;qBACrC,GAAAC,YAAAA;ADfM;gBCiBRH,KAAKJ,IAAQI,KAAKJ,EAAMQ;gBACxB,OAAOJ;ADfH;YCkBNA,KAAKK,OAAO;gBACV,IAAIL,KAAKJ,MAAUI,KAAKH,GAAS;qBAC/B,GAAAM,YAAAA;ADhBM;gBCkBRH,KAAKJ,IAAQI,KAAKJ,EAAMU;gBACxB,OAAON;ADhBH;AACJ,eCiBG;YACLA,KAAKC,MAAM;gBACT,IAAID,KAAKJ,MAAUI,KAAKH,EAAQU,GAAQ;qBACtC,GAAAJ,YAAAA;ADfM;gBCiBRH,KAAKJ,IAAQI,KAAKJ,EAAMU;gBACxB,OAAON;ADfH;YCkBNA,KAAKK,OAAO;gBACV,IAAIL,KAAKJ,MAAUI,KAAKH,GAAS;qBAC/B,GAAAM,YAAAA;ADhBM;gBCkBRH,KAAKJ,IAAQI,KAAKJ,EAAMQ;gBACxB,OAAOJ;ADhBH;AACJ;AACJ;IC2BEQ;QACF,IAAIZ,IAAQI,KAAKJ;QACjB,MAAMa,IAAOT,KAAKH,EAAQa;QAC1B,IAAId,MAAUI,KAAKH,GAAS;YAC1B,IAAIY,GAAM;gBACR,OAAOA,EAAKE,KAAe;ADhBvB;YCkBN,OAAO;ADhBL;QCkBJ,IAAIH,IAAQ;QACZ,IAAIZ,EAAMM,GAAO;YACfM,KAAUZ,EAAMM,EAAoCS;ADhBlD;QCkBJ,OAAOf,MAAUa,GAAM;YACrB,MAAMC,IAAUd,EAAMc;YACtB,IAAId,MAAUc,EAAQH,GAAQ;gBAC5BC,KAAS;gBACT,IAAIE,EAAQR,GAAO;oBACjBM,KAAUE,EAAQR,EAAoCS;ADhBhD;AACJ;YCkBNf,IAAQc;ADhBN;QCkBJ,OAAOF;ADhBP;;;ACsBH,IAAAI,WAEcnB;;AAAYN,QAAAE,UAAAuB","file":"TreeIterator.js","sourcesContent":["import { ContainerIterator } from \"../../ContainerBase\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nclass TreeIterator extends ContainerIterator {\n    /**\n     * @internal\n     */\n    constructor(_node, _header, iteratorType) {\n        super(iteratorType);\n        this._node = _node;\n        this._header = _header;\n        if (this.iteratorType === 0 /* IteratorType.NORMAL */) {\n            this.pre = function () {\n                if (this._node === this._header._left) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._pre();\n                return this;\n            };\n            this.next = function () {\n                if (this._node === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._next();\n                return this;\n            };\n        }\n        else {\n            this.pre = function () {\n                if (this._node === this._header._right) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._next();\n                return this;\n            };\n            this.next = function () {\n                if (this._node === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._pre();\n                return this;\n            };\n        }\n    }\n    /**\n     * @description Get the sequential index of the iterator in the tree container.<br/>\n     *              <strong>Note:</strong>\n     *              This function only takes effect when the specified tree container `enableIndex = true`.\n     * @returns The index subscript of the node in the tree.\n     * @example\n     * const st = new OrderedSet([1, 2, 3], true);\n     * console.log(st.begin().next().index);  // 1\n     */\n    get index() {\n        let _node = this._node;\n        const root = this._header._parent;\n        if (_node === this._header) {\n            if (root) {\n                return root._subTreeSize - 1;\n            }\n            return 0;\n        }\n        let index = 0;\n        if (_node._left) {\n            index += _node._left._subTreeSize;\n        }\n        while (_node !== root) {\n            const _parent = _node._parent;\n            if (_node === _parent._right) {\n                index += 1;\n                if (_parent._left) {\n                    index += _parent._left._subTreeSize;\n                }\n            }\n            _node = _parent;\n        }\n        return index;\n    }\n}\nexport default TreeIterator;\n","import { TreeNode } from './TreeNode';\nimport type { TreeNodeEnableIndex } from './TreeNode';\nimport { ContainerIterator, IteratorType } from '@/container/ContainerBase';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeIterator<K, V> extends ContainerIterator<K | [K, V]> {\n  /**\n   * @internal\n   */\n  _node: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  constructor(\n    _node: TreeNode<K, V>,\n    _header: TreeNode<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(iteratorType);\n    this._node = _node;\n    this._header = _header;\n\n    if (this.iteratorType === IteratorType.NORMAL) {\n      this.pre = function () {\n        if (this._node === this._header._left) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n    } else {\n      this.pre = function () {\n        if (this._node === this._header._right) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next();\n        return this;\n      };\n\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre();\n        return this;\n      };\n    }\n  }\n  /**\n   * @description Get the sequential index of the iterator in the tree container.<br/>\n   *              <strong>Note:</strong>\n   *              This function only takes effect when the specified tree container `enableIndex = true`.\n   * @returns The index subscript of the node in the tree.\n   * @example\n   * const st = new OrderedSet([1, 2, 3], true);\n   * console.log(st.begin().next().index);  // 1\n   */\n  get index() {\n    let _node = this._node as TreeNodeEnableIndex<K, V>;\n    const root = this._header._parent as TreeNodeEnableIndex<K, V>;\n    if (_node === this._header) {\n      if (root) {\n        return root._subTreeSize - 1;\n      }\n      return 0;\n    }\n    let index = 0;\n    if (_node._left) {\n      index += (_node._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    while (_node !== root) {\n      const _parent = _node._parent as TreeNodeEnableIndex<K, V>;\n      if (_node === _parent._right) {\n        index += 1;\n        if (_parent._left) {\n          index += (_parent._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n        }\n      }\n      _node = _parent;\n    }\n    return index;\n  }\n  // @ts-ignore\n  pre(): this;\n  // @ts-ignore\n  next(): this;\n}\n\nexport default TreeIterator;\n"]}