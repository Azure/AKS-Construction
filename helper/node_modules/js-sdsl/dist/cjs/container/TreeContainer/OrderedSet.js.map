{"version":3,"sources":["container/TreeContainer/OrderedSet.js","../../src/container/TreeContainer/OrderedSet.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_TreeIterator","_throwError","obj","__esModule","OrderedSetIterator","TreeIterator","pointer","this","_node","_header","throwIteratorAccessError","_key","copy","iteratorType","OrderedSet","TreeContainer","constructor","container","cmp","enableIndex","super","self","forEach","el","insert","X","curNode","undefined","_iterationFunc","_left","_right","begin","end","rBegin","rEnd","front","back","key","hint","_set","find","element","_findElementNode","_root","lowerBound","resNode","_lowerBound","upperBound","_upperBound","reverseLowerBound","_reverseLowerBound","reverseUpperBound","_reverseUpperBound","union","other","_length","Symbol","iterator","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACLvB,IAAAC,QAAAC,uBAAAC,QAAA;;AACA,IAAAC,gBAAAF,uBAAAC,QAAA;;AAGA,IAAAE,cAAAF,QAAA;;AAA8D,SAAAD,uBAAAI;IAAA,OAAAA,KAAAA,EAAAC,IAAAD,IAAA;QAAAN,SAAAM;;AAAA;;AAE9D,MAAME,2BAA8BC,cAAAA;IAC9BC;QACF,IAAIC,KAAKC,MAAUD,KAAKE,GAAS;aAC/B,GAAAC,YAAAA;ADFE;QCIJ,OAAOH,KAAKC,EAAMG;ADFlB;ICIFC;QACE,OAAO,IAAIR,mBAAmBG,KAAKC,GAAOD,KAAKE,GAASF,KAAKM;ADF7D;;;ACUJ,MAAMC,mBAAsBC,MAAAA;IAW1BC,YACEC,IAA8B,IAC9BC,GACAC;QAEAC,MAAMF,GAAKC;QACX,MAAME,IAAOd;QACbU,EAAUK,SAAQ,SAAUC;YAC1BF,EAAKG,OAAOD;ADXV;AACJ;ICgBME,IACNC;QAEA,IAAIA,MAAYC,WAAW;eACnBpB,KAAKqB,EAAeF,EAAQG;cAC9BH,EAAQf;eACNJ,KAAKqB,EAAeF,EAAQI;ADZpC;ICcFC;QACE,OAAO,IAAI3B,mBACTG,KAAKE,EAAQoB,KAAStB,KAAKE,GAC3BF,KAAKE;ADdP;ICiBFuB;QACE,OAAO,IAAI5B,mBAAmBG,KAAKE,GAASF,KAAKE;ADfjD;ICiBFwB;QACE,OAAO,IAAI7B,mBACTG,KAAKE,EAAQqB,KAAUvB,KAAKE,GAC5BF,KAAKE,GAAO;ADjBd;ICqBFyB;QACE,OAAO,IAAI9B,mBAAmBG,KAAKE,GAASF,KAAKE,GAAO;ADnBxD;ICqBF0B;QACE,OAAO5B,KAAKE,EAAQoB,IAAQtB,KAAKE,EAAQoB,EAAMlB,IAAOgB;ADnBtD;ICqBFS;QACE,OAAO7B,KAAKE,EAAQqB,IAASvB,KAAKE,EAAQqB,EAAOnB,IAAOgB;ADnBxD;ICgCFH,OAAOa,GAAQC;QACb,OAAO/B,KAAKgC,EAAKF,GAAKV,WAAWW;ADnBjC;ICqBFE,KAAKC;QACH,MAAMf,IAAUnB,KAAKmC,EAAiBnC,KAAKoC,IAAOF;QAClD,OAAO,IAAIrC,mBAAmBsB,GAASnB,KAAKE;ADnB5C;ICqBFmC,WAAWP;QACT,MAAMQ,IAAUtC,KAAKuC,EAAYvC,KAAKoC,IAAON;QAC7C,OAAO,IAAIjC,mBAAmByC,GAAStC,KAAKE;ADnB5C;ICqBFsC,WAAWV;QACT,MAAMQ,IAAUtC,KAAKyC,GAAYzC,KAAKoC,IAAON;QAC7C,OAAO,IAAIjC,mBAAmByC,GAAStC,KAAKE;ADnB5C;ICqBFwC,kBAAkBZ;QAChB,MAAMQ,IAAUtC,KAAK2C,GAAmB3C,KAAKoC,IAAON;QACpD,OAAO,IAAIjC,mBAAmByC,GAAStC,KAAKE;ADnB5C;ICqBF0C,kBAAkBd;QAChB,MAAMQ,IAAUtC,KAAK6C,GAAmB7C,KAAKoC,IAAON;QACpD,OAAO,IAAIjC,mBAAmByC,GAAStC,KAAKE;ADnB5C;ICqBF4C,MAAMC;QACJ,MAAMjC,IAAOd;QACb+C,EAAMhC,SAAQ,SAAUC;YACtBF,EAAKG,OAAOD;ADnBV;QCqBJ,OAAOhB,KAAKgD;ADnBZ;ICqBF,CAACC,OAAOC;QACN,OAAOlD,KAAKqB,EAAerB,KAAKoC;ADnBhC;;;AC2BH,IAAAe,WAEc5C;;AAAUpB,QAAAE,UAAA8D","file":"OrderedSet.js","sourcesContent":["import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass OrderedSetIterator extends TreeIterator {\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        return this._node._key;\n    }\n    copy() {\n        return new OrderedSetIterator(this._node, this._header, this.iteratorType);\n    }\n}\nclass OrderedSet extends TreeContainer {\n    /**\n     * @param container - The initialization container.\n     * @param cmp - The compare function.\n     * @param enableIndex - Whether to enable iterator indexing function.\n     * @example\n     * new OrderedSet();\n     * new OrderedSet([0, 1, 2]);\n     * new OrderedSet([0, 1, 2], (x, y) => x - y);\n     * new OrderedSet([0, 1, 2], (x, y) => x - y, true);\n     */\n    constructor(container = [], cmp, enableIndex) {\n        super(cmp, enableIndex);\n        const self = this;\n        container.forEach(function (el) {\n            self.insert(el);\n        });\n    }\n    /**\n     * @internal\n     */\n    *_iterationFunc(curNode) {\n        if (curNode === undefined)\n            return;\n        yield* this._iterationFunc(curNode._left);\n        yield curNode._key;\n        yield* this._iterationFunc(curNode._right);\n    }\n    begin() {\n        return new OrderedSetIterator(this._header._left || this._header, this._header);\n    }\n    end() {\n        return new OrderedSetIterator(this._header, this._header);\n    }\n    rBegin() {\n        return new OrderedSetIterator(this._header._right || this._header, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new OrderedSetIterator(this._header, this._header, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        return this._header._left ? this._header._left._key : undefined;\n    }\n    back() {\n        return this._header._right ? this._header._right._key : undefined;\n    }\n    /**\n     * @description Insert element to set.\n     * @param key - The key want to insert.\n     * @param hint - You can give an iterator hint to improve insertion efficiency.\n     * @return The size of container after setting.\n     * @example\n     * const st = new OrderedSet([2, 4, 5]);\n     * const iter = st.begin();\n     * st.insert(1);\n     * st.insert(3, iter);  // give a hint will be faster.\n     */\n    insert(key, hint) {\n        return this._set(key, undefined, hint);\n    }\n    find(element) {\n        const curNode = this._findElementNode(this._root, element);\n        return new OrderedSetIterator(curNode, this._header);\n    }\n    lowerBound(key) {\n        const resNode = this._lowerBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header);\n    }\n    upperBound(key) {\n        const resNode = this._upperBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header);\n    }\n    reverseLowerBound(key) {\n        const resNode = this._reverseLowerBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header);\n    }\n    reverseUpperBound(key) {\n        const resNode = this._reverseUpperBound(this._root, key);\n        return new OrderedSetIterator(resNode, this._header);\n    }\n    union(other) {\n        const self = this;\n        other.forEach(function (el) {\n            self.insert(el);\n        });\n        return this._length;\n    }\n    [Symbol.iterator]() {\n        return this._iterationFunc(this._root);\n    }\n}\nexport default OrderedSet;\n","import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { TreeNode } from './Base/TreeNode';\nimport { initContainer, IteratorType } from '@/container/ContainerBase';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass OrderedSetIterator<K> extends TreeIterator<K, undefined> {\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    return this._node._key!;\n  }\n  copy() {\n    return new OrderedSetIterator(this._node, this._header, this.iteratorType);\n  }\n  // @ts-ignore\n  equals(iter: OrderedSetIterator<K>): boolean;\n}\n\nexport type { OrderedSetIterator };\n\nclass OrderedSet<K> extends TreeContainer<K, undefined> {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedSet();\n   * new OrderedSet([0, 1, 2]);\n   * new OrderedSet([0, 1, 2], (x, y) => x - y);\n   * new OrderedSet([0, 1, 2], (x, y) => x - y, true);\n   */\n  constructor(\n    container: initContainer<K> = [],\n    cmp?: (x: K, y: K) => number,\n    enableIndex?: boolean\n  ) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.insert(el);\n    });\n  }\n  /**\n   * @internal\n   */\n  private * _iterationFunc(\n    curNode: TreeNode<K, undefined> | undefined\n  ): Generator<K, void> {\n    if (curNode === undefined) return;\n    yield * this._iterationFunc(curNode._left);\n    yield curNode._key!;\n    yield * this._iterationFunc(curNode._right);\n  }\n  begin() {\n    return new OrderedSetIterator(\n      this._header._left || this._header,\n      this._header\n    );\n  }\n  end() {\n    return new OrderedSetIterator(this._header, this._header);\n  }\n  rBegin() {\n    return new OrderedSetIterator(\n      this._header._right || this._header,\n      this._header,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new OrderedSetIterator(this._header, this._header, IteratorType.REVERSE);\n  }\n  front() {\n    return this._header._left ? this._header._left._key : undefined;\n  }\n  back() {\n    return this._header._right ? this._header._right._key : undefined;\n  }\n  /**\n   * @description Insert element to set.\n   * @param key - The key want to insert.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const st = new OrderedSet([2, 4, 5]);\n   * const iter = st.begin();\n   * st.insert(1);\n   * st.insert(3, iter);  // give a hint will be faster.\n   */\n  insert(key: K, hint?: OrderedSetIterator<K>) {\n    return this._set(key, undefined, hint);\n  }\n  find(element: K) {\n    const curNode = this._findElementNode(this._root, element);\n    return new OrderedSetIterator(curNode, this._header);\n  }\n  lowerBound(key: K) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedSetIterator(resNode, this._header);\n  }\n  upperBound(key: K) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedSetIterator(resNode, this._header);\n  }\n  reverseLowerBound(key: K) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedSetIterator(resNode, this._header);\n  }\n  reverseUpperBound(key: K) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedSetIterator(resNode, this._header);\n  }\n  union(other: OrderedSet<K>) {\n    const self = this;\n    other.forEach(function (el) {\n      self.insert(el);\n    });\n    return this._length;\n  }\n  [Symbol.iterator]() {\n    return this._iterationFunc(this._root);\n  }\n  // @ts-ignore\n  eraseElementByIterator(iter: OrderedSetIterator<K>): OrderedSetIterator<K>;\n  // @ts-ignore\n  forEach(callback: (element: K, index: number, tree: OrderedSet<K>) => void): void;\n  // @ts-ignore\n  getElementByPos(pos: number): K;\n}\n\nexport default OrderedSet;\n"]}