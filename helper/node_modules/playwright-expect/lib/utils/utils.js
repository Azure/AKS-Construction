"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorMessage = exports.formatText = exports.getText = exports.getValue = exports.getElements = exports.getElementHandle = void 0;
const constants_1 = require("./constants");
async function getElementHandle(element, options) {
    var _a, _b;
    if (Array.isArray(element)) {
        const [page, selector] = element;
        const elementHandle = await page.waitForSelector(selector, {
            state: (_a = options === null || options === void 0 ? void 0 : options.state) !== null && _a !== void 0 ? _a : 'visible',
            timeout: (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT,
        });
        if (elementHandle)
            return elementHandle;
    }
    else if (element.constructor.name === 'ElementHandle') {
        return element;
    }
    else if (element instanceof Promise) {
        return element;
    }
    return null;
}
exports.getElementHandle = getElementHandle;
async function getElements(elements) {
    let elementHandles;
    if (Array.isArray(elements) && elements[0].constructor.name === 'Page' && typeof elements[1] === 'string') {
        const [page, selector] = elements;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        elementHandles = await page.$$(selector);
    }
    else if (elements instanceof Promise) {
        elementHandles = await elements;
        return elementHandles;
    }
    else {
        elementHandles = elements;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return elementHandles;
}
exports.getElements = getElements;
async function getValue(elementHandle) {
    const value = await elementHandle.evaluate((input) => input.value);
    return value;
}
exports.getValue = getValue;
async function getText(elementHandle, textMethod = 'textContent') {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    if (elementHandle)
        return elementHandle[textMethod !== null && textMethod !== void 0 ? textMethod : 'textContent']();
    throw new Error(`Couldn't get text from the ${elementHandle} element`);
}
exports.getText = getText;
function formatText(text, { ignoreCase = false, trim = false }) {
    if (trim) {
        return text.trim();
    }
    if (ignoreCase) {
        return text.toLowerCase();
    }
    return text;
}
exports.formatText = formatText;
const getErrorMessage = ({ expand, isNot, promise, utils }, matcher, expected, received) => {
    let message;
    if (isNot) {
        message = `Expected: not ${utils.printExpected(expected)}`;
    }
    else if (typeof expected === 'boolean') {
        message = `Expected: ${utils.printExpected(expected)} to be ${utils.printReceived(received)}`;
    }
    else {
        message = `${utils.printDiffOrStringify(expected, received, 'Expected', 'Received', expand)}`;
    }
    return `${utils.matcherHint(matcher, undefined, undefined, { isNot, promise })}\n\n${message}`;
};
exports.getErrorMessage = getErrorMessage;
