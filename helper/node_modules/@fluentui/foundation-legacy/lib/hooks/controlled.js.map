{"version":3,"file":"controlled.js","sourceRoot":"../src/","sources":["hooks/controlled.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAO/B;;;;;;;;GAQG;AACH,MAAM,UAAU,kBAAkB,CAChC,KAAuB,EACvB,QAAe,EACf,OAA8D;IAE9D,IAAI,YAAuC,CAAC;IAC5C,IAAI,OAAO,EAAE;QACX,IAAI,OAAO,CAAC,eAAe,IAAI,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,SAAS,EAAE;YAC3E,yGAAyG;YACzG,YAAY,GAAI,KAAK,CAAC,OAAO,CAAC,eAAe,CAA8B,CAAC;SAC7E;aAAM;YACL,YAAY,GAAG,OAAO,IAAI,OAAO,CAAC,gBAAgB,CAAC;SACpD;KACF;IAEK,IAAA,KAAoB,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,EAA/C,KAAK,QAAA,EAAE,QAAQ,QAAgC,CAAC;IAEvD,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;QACjC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;KACpC;SAAM;QACL,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;KAC1B;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,yBAAyB,CACvC,KAAuB,EACvB,QAAe,EACf,YAA2B;IAE3B,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;QACjC,OAAO,KAAK,CAAC,QAAQ,CAAC,CAAC;KACxB;SAAM;QACL,OAAO,YAAY,CAAC;KACrB;AACH,CAAC","sourcesContent":["import * as React from 'react';\n\nexport interface IControlledStateOptions<TProps, TProp extends keyof TProps, TDefaultProp extends keyof TProps> {\n  defaultPropValue?: TProps[TProp];\n  defaultPropName?: TDefaultProp;\n}\n\n/**\n * Controlled state helper that gives priority to props value. Useful for components that have props with both\n * controlled and uncontrolled modes. Any props values will override state, but will not update internal state.\n * If prop is defined and then later undefined, state will revert to its previous value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param options - Options. defaultPropValue is only used if defaultPropName (or its value) is undefined.\n */\nexport function useControlledState<TProps, TProp extends keyof TProps, TDefaultProp extends keyof TProps>(\n  props: Readonly<TProps>,\n  propName: TProp,\n  options?: IControlledStateOptions<TProps, TProp, TDefaultProp>,\n): [TProps[TProp] | undefined, React.Dispatch<React.SetStateAction<TProps[TProp]>>] {\n  let defaultValue: TProps[TProp] | undefined;\n  if (options) {\n    if (options.defaultPropName && props[options.defaultPropName] !== undefined) {\n      // No easy way to coerce TProps[TDefaultProp] to match TProps[TProp] in generic typings, so cast it here.\n      defaultValue = (props[options.defaultPropName] as unknown) as TProps[TProp];\n    } else {\n      defaultValue = options && options.defaultPropValue;\n    }\n  }\n\n  const [state, setState] = React.useState(defaultValue);\n\n  if (props[propName] !== undefined) {\n    return [props[propName], setState];\n  } else {\n    return [state, setState];\n  }\n}\n\n/**\n * Simple controlled helper that gives priority to props value and falls back to derived value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param derivedValue - Derived value. Returned when controlled value is not present.\n */\nexport function getControlledDerivedProps<TProps, TProp extends keyof TProps>(\n  props: Readonly<TProps>,\n  propName: TProp,\n  derivedValue: TProps[TProp],\n): TProps[TProp] {\n  if (props[propName] !== undefined) {\n    return props[propName];\n  } else {\n    return derivedValue;\n  }\n}\n"]}