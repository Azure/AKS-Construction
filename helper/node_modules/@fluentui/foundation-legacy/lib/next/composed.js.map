{"version":3,"file":"composed.js","sourceRoot":"../src/","sources":["next/composed.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { concatStyleSets, IStyleSet, ITheme } from '@fluentui/style-utilities';\nimport { Customizations, CustomizerContext, ICustomizerContext } from '@fluentui/utilities';\nimport { createFactory, getSlots } from '../slots';\nimport { assign } from '../utilities';\nimport {\n  ICustomizationProps,\n  IStyleableComponentProps,\n  IStylesFunctionOrObject,\n  IToken,\n  ITokenFunction,\n} from '../IComponent';\nimport { IComponentOptions, IPartialSlotComponent, IRecompositionComponentOptions, ISlotComponent } from './IComponent';\nimport { IDefaultSlotProps, ValidProps, ISlottableProps, ISlotCreator, ISlotDefinition } from '../ISlots';\nimport { IFoundationComponent } from './ISlots';\n\ninterface IClassNamesMapNode {\n  className?: string;\n  map: IClassNamesMap;\n}\n\ninterface IClassNamesMap {\n  [key: string]: IClassNamesMapNode;\n}\n\nconst memoizedClassNamesMap: IClassNamesMap = {};\n\n/**\n * Assembles a higher order component based on the following: styles, theme, view, and state.\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call\n * the view prop.\n *\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n *\n * State component is optional. If state is not provided, created component is essentially a functional\n * stateless component.\n *\n * @param options - component Component options. See IComponentOptions for more detail.\n */\nexport function composed<\n  TComponentProps extends ValidProps & ISlottableProps<TComponentSlots>,\n  TTokens,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TViewProps extends TComponentProps = TComponentProps,\n  TComponentSlots = {},\n  TStatics = {}\n>(\n  options: IComponentOptions<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics>,\n): IFoundationComponent<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics> & TStatics;\n\n/**\n * Recomposes a functional component based on a base component and the following set of options: styles, theme, view,\n * and state. Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call\n * the view prop.\n *\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n *\n * State component is optional. If state is not provided, created component is essentially a functional\n * stateless component.\n *\n * @param baseComponent - base component to recompose\n * @param options - component Component recomposition options. See IComponentOptions for more detail.\n */\nexport function composed<\n  TComponentProps extends ValidProps & ISlottableProps<TComponentSlots>,\n  TTokens,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TViewProps extends TComponentProps = TComponentProps,\n  TComponentSlots = {},\n  TStatics = {}\n>(\n  baseComponent: React.FunctionComponent,\n  options: IRecompositionComponentOptions<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics>,\n): IFoundationComponent<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics> & TStatics;\n\n/**\n * Assembles a higher order component based on a set of options or recomposes a functional component based on a\n * base component and the a set of options. This set of options is comprised by: styles, theme, view, and state.\n *\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call\n * the view prop.\n *\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n *\n * State component is optional. If state is not provided, created component is essentially a functional\n * stateless component.\n *\n * @param baseComponentOrOptions - base component to recompose or component Component options to compose an HOC.\n * See IComponentOptions for more detail.\n * @param recompositionOptions - component Component recomposition options. See IComponentOptions for more detail.\n */\nexport function composed<\n  TComponentProps extends ValidProps & ISlottableProps<TComponentSlots>,\n  TTokens,\n  TStyleSet extends IStyleSet<TStyleSet>,\n  TViewProps extends TComponentProps = TComponentProps,\n  TComponentSlots = {},\n  TStatics = {}\n>(\n  baseComponentOrOptions:\n    | IFoundationComponent<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics>\n    | IComponentOptions<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics> = {},\n  recompositionOptions?: IRecompositionComponentOptions<\n    TComponentProps,\n    TTokens,\n    TStyleSet,\n    TViewProps,\n    TComponentSlots,\n    TStatics\n  >,\n): IFoundationComponent<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics> & TStatics {\n  // Check if we are composing or recomposing.\n  let options: IComponentOptions<TComponentProps, TTokens, TStyleSet, TViewProps, TComponentSlots, TStatics>;\n  if (typeof baseComponentOrOptions === 'function' && baseComponentOrOptions.__options) {\n    const baseComponentOptions = baseComponentOrOptions.__options;\n    const recompositionSlots = recompositionOptions ? recompositionOptions.slots : undefined;\n\n    options = {\n      ...baseComponentOptions,\n      ...recompositionOptions,\n      slots: props => ({\n        ...resolveSlots(baseComponentOptions.slots, props),\n        ...resolveSlots(recompositionSlots, props),\n      }),\n    };\n  } else {\n    options = baseComponentOrOptions;\n  }\n\n  const { factoryOptions = {}, view } = options;\n  const { defaultProp } = factoryOptions;\n\n  const ResultComponent: IFoundationComponent<\n    TComponentProps,\n    TTokens,\n    TStyleSet,\n    TViewProps,\n    TComponentSlots,\n    TStatics\n  > = (\n    componentProps: TViewProps &\n      IStyleableComponentProps<TViewProps, TTokens, TStyleSet> & { children?: React.ReactNode },\n  ) => {\n    const settings: ICustomizationProps<TViewProps, TTokens, TStyleSet> = _getCustomizations(\n      options.displayName,\n      React.useContext(CustomizerContext),\n      options.fields,\n    );\n\n    const stateReducer = options.state;\n\n    if (stateReducer) {\n      // Don't assume state will return all props, so spread useState result over component props.\n      componentProps = {\n        ...componentProps,\n        ...stateReducer(componentProps),\n      };\n    }\n\n    const theme = componentProps.theme || settings.theme;\n    const tokens = _resolveTokens(componentProps, theme, options.tokens, settings.tokens, componentProps.tokens) as any;\n    let styles;\n\n    const finalStyles: { [key: string]: string | undefined } = {};\n\n    // We get the entry in the memoized classNamesMap for the current component or create one if it doesn't exist.\n    const displayName = options.displayName;\n\n    // If no displayName has been specified, then do not use caching.\n    if (displayName) {\n      if (!memoizedClassNamesMap.hasOwnProperty(displayName)) {\n        memoizedClassNamesMap[displayName] = { map: {} };\n      }\n\n      let current = memoizedClassNamesMap[displayName];\n\n      // Memoize based on the tokens definition.\n      const tokenKeys = Object.keys(tokens).sort();\n      for (const key of tokenKeys) {\n        let nextToken = tokens[key];\n        if (nextToken === undefined) {\n          nextToken = '__undefined__';\n        }\n        if (!current.map.hasOwnProperty(nextToken)) {\n          current.map[nextToken] = { map: {} };\n        }\n        current = current.map[nextToken];\n      }\n\n      // Memoize the slots so we only have to get Object.keys once.\n      let slots = (memoizedClassNamesMap[displayName] as any).slots;\n      let defaultStyles;\n      if (!slots) {\n        defaultStyles = _resolveStyles(componentProps, theme, tokens, options.styles, settings.styles);\n        (memoizedClassNamesMap[displayName] as any).slots = Object.keys(defaultStyles);\n        slots = (memoizedClassNamesMap[displayName] as any).slots;\n      }\n\n      // Memoize based on the base styling of the component (i.e. without user specified props).\n      for (const key of slots) {\n        if (!current.map.hasOwnProperty(key)) {\n          // Get default styles once if we didn't get them before.\n          if (!defaultStyles) {\n            defaultStyles = _resolveStyles(componentProps, theme, tokens, options.styles, settings.styles);\n          }\n          current.map[key] = { className: mergeStyles(defaultStyles[key]), map: {} };\n        }\n        finalStyles[key] = current.map[key].className;\n      }\n\n      if (componentProps.styles) {\n        const userStyles: any =\n          typeof componentProps.styles === 'function'\n            ? componentProps.styles(componentProps as TViewProps, theme, tokens)\n            : componentProps.styles;\n        styles = concatStyleSets(styles, userStyles);\n        if (userStyles) {\n          const userStyleKeys = Object.keys(userStyles);\n          for (const key of userStyleKeys) {\n            if (finalStyles.hasOwnProperty(key)) {\n              finalStyles[key] = mergeStyles([current.map[key].className], userStyles[key]);\n            } else {\n              finalStyles[key] = mergeStyles(userStyles[key]);\n            }\n          }\n        }\n      }\n    } else {\n      styles = _resolveStyles(componentProps, theme, tokens, options.styles, settings.styles, componentProps.styles);\n    }\n\n    const viewProps = {\n      ...componentProps,\n      styles,\n      tokens,\n      _defaultStyles: displayName ? finalStyles : styles,\n    } as TViewProps & IDefaultSlotProps<any>;\n\n    if (!options.slots) {\n      throw new Error(`Component ${options.displayName || (view && view.name) || ''} is missing slot definitions.`);\n    }\n\n    const Slots =\n      typeof options.slots === 'function'\n        ? getSlots(viewProps, options.slots(viewProps))\n        : getSlots(viewProps, options.slots);\n\n    return view ? view(viewProps, Slots) : null;\n  };\n\n  ResultComponent.displayName = options.displayName || (view && view.name);\n\n  // If a shorthand prop is defined, create a factory for the component.\n  // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\n  //       Need to weigh creating default factories on component creation vs. memoizing them on use in slots.tsx.\n  if (defaultProp) {\n    (ResultComponent as ISlotCreator<TComponentProps, any>).create = createFactory(ResultComponent, { defaultProp });\n  }\n\n  ResultComponent.__options = options;\n\n  assign(ResultComponent, options.statics);\n\n  // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\n  return ResultComponent as IFoundationComponent<\n    TComponentProps,\n    TTokens,\n    TStyleSet,\n    TViewProps,\n    TComponentSlots,\n    TStatics\n  > &\n    TStatics;\n}\n\n/**\n * Resolve the passed slots as a function or an object.\n *\n * @param slots - Slots that need to be resolved as a function or an object.\n * @param data - Data to pass to resolve if the first argument was a function.\n */\nexport function resolveSlots<TComponentProps extends ISlottableProps<TComponentSlots>, TComponentSlots>(\n  slots:\n    | IPartialSlotComponent<TComponentProps, TComponentSlots>\n    | ISlotComponent<TComponentProps, TComponentSlots>\n    | undefined,\n  data: TComponentProps,\n): ISlotDefinition<Required<TComponentSlots>> {\n  const resolvedSlots = slots ? (typeof slots === 'function' ? slots(data) : slots) : {};\n  return resolvedSlots as ISlotDefinition<Required<TComponentSlots>>;\n}\n\n/**\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\n */\nfunction _resolveStyles<TProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  props: TProps,\n  theme: ITheme,\n  tokens: TTokens,\n  ...allStyles: (IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined)[]\n): ReturnType<typeof concatStyleSets> {\n  return concatStyleSets(\n    ...allStyles.map((styles: IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined) =>\n      typeof styles === 'function' ? styles(props, theme, tokens) : styles,\n    ),\n  );\n}\n\n/**\n * Resolve all tokens functions with props flatten results along with all tokens objects.\n */\nfunction _resolveTokens<TViewProps, TTokens>(\n  props: TViewProps,\n  theme: ITheme,\n  ...allTokens: (IToken<TViewProps, TTokens> | false | null | undefined)[]\n): TTokens {\n  const tokens = {};\n\n  for (let currentTokens of allTokens) {\n    if (currentTokens) {\n      // TODO: why is this cast needed? TS seems to think there is a (TToken | Function) union from somewhere.\n      currentTokens =\n        typeof currentTokens === 'function'\n          ? (currentTokens as ITokenFunction<TViewProps, TTokens>)(props, theme)\n          : currentTokens;\n\n      if (Array.isArray(currentTokens)) {\n        currentTokens = _resolveTokens(props, theme, ...currentTokens);\n      }\n\n      assign(tokens, currentTokens);\n    }\n  }\n\n  return tokens as TTokens;\n}\n\n/**\n * Helper function for calling Customizations.getSettings falling back to default fields.\n *\n * @param displayName Displayable name for component.\n * @param context React context passed to component containing contextual settings.\n * @param fields Optional list of properties to grab from global store and context.\n */\nfunction _getCustomizations<TViewProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\n  displayName: string | undefined,\n  context: ICustomizerContext,\n  fields?: string[],\n): ICustomizationProps<TViewProps, TTokens, TStyleSet> {\n  // TODO: do we want field props? should fields be part of IComponent and used here?\n  // TODO: should we centrally define DefaultFields? (not exported from styling)\n  // TODO: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\n  const DefaultFields = ['theme', 'styles', 'tokens'];\n  return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\n}\n"]}