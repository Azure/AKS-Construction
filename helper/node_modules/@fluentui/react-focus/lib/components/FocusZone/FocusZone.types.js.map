{"version":3,"file":"FocusZone.types.js","sourceRoot":"../src/","sources":["components/FocusZone/FocusZone.types.ts"],"names":[],"mappings":"AAkRA;;GAEG;AACH,MAAM,CAAC,IAAM,yBAAyB,GAAG;IACvC,6BAA6B;IAC7B,IAAI,EAAE,CAAM;IAEZ,oCAAoC;IACpC,GAAG,EAAE,CAAM;IAEX,gDAAgD;IAChD,SAAS,EAAE,CAAM;CAClB,CAAC;AAOF;;GAEG;AACH,MAAM,CAAN,IAAY,kBAeX;AAfD,WAAY,kBAAkB;IAC5B,oCAAoC;IACpC,mEAAY,CAAA;IAEZ,uCAAuC;IACvC,uEAAc,CAAA;IAEd,2BAA2B;IAC3B,6EAAiB,CAAA;IAEjB;;;OAGG;IACH,mEAAY,CAAA;AACd,CAAC,EAfW,kBAAkB,KAAlB,kBAAkB,QAe7B","sourcesContent":["import * as React from 'react';\nimport type { IRefObject, Point } from '@fluentui/utilities';\n\n/**\n * FocusZone component class interface.\n * {@docCategory FocusZone}\n */\nexport interface IFocusZone {\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focus(forceIntoFirstElement?: boolean, bypassHiddenElements?: boolean): boolean;\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusLast(): boolean;\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param childElement - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusElement(childElement?: HTMLElement, forceAlignment?: boolean): boolean;\n\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference, rather\n   * than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  setFocusAlignment(point: Point): void;\n}\n\n/**\n * FocusZone component props.\n * {@docCategory FocusZone}\n */\nexport interface IFocusZoneProps extends React.HTMLAttributes<HTMLElement> {\n  /**\n   * Optional callback to access the IFocusZone interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<IFocusZone>;\n\n  /**\n   * Optional callback to access the root DOM element.\n   * @deprecated Temporary solution which will be replaced with ref in the V8 release.\n   */\n  elementRef?: React.Ref<HTMLElement>;\n\n  /**\n   * Additional class name to provide on the root element, in addition to the ms-FocusZone class.\n   */\n  className?: string;\n\n  /**\n   * Defines which arrows to react to.\n   * @defaultvalue FocusZoneDirection.bidirectional\n   */\n  direction?: FocusZoneDirection;\n\n  /**\n   * Optionally defines the initial tabbable element inside the FocusZone.\n   * If a string is passed then it is treated as a selector for identifying the initial tabbable element.\n   * If a function is passed then it uses the root element as a parameter to return the initial tabbable element.\n   */\n  defaultTabbableElement?: string | ((root: HTMLElement) => HTMLElement);\n\n  /**\n   * Optionally provide a selector for identifying the initial active element.\n   * @deprecated Use `defaultTabbableElement` instead.\n   */\n  defaultActiveElement?: string;\n\n  /**\n   * Determines if a default tabbable element should be force focused on FocusZone mount.\n   * @default false\n   */\n  shouldFocusOnMount?: boolean;\n\n  /**\n   * If set, the FocusZone will not be tabbable and keyboard navigation will be disabled.\n   * This does not affect disabled attribute of any child.\n   */\n  disabled?: boolean;\n\n  /**\n   * Element type the root element will use. Default is \"div\".\n   * @deprecated Use `as` instead.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  elementType?: any /* TODO should be `keyof React.ReactHTML`, tracking with https://github.com/Microsoft/TypeScript/issues/30050 */;\n\n  /**\n   * A component that should be used as the root element of the FocusZone component.\n   */\n  as?: React.ElementType;\n\n  /**\n   * If set, will cycle to the beginning of the targets once the user navigates to the\n   * next target while at the end, and to the end when navigate to the previous at the beginning.\n   */\n  isCircularNavigation?: boolean;\n\n  /**\n   * If provided, this callback will be executed on keypresses to determine if the user\n   * intends to navigate into the inner zone. Returning true will ask the first inner zone to\n   * set focus.\n   * @deprecated Use `shouldEnterInnerZone` instead.\n   */\n  isInnerZoneKeystroke?: (ev: React.KeyboardEvent<HTMLElement>) => boolean;\n\n  /**\n   * Callback function that will be executed on keypresses to determine if the user intends to navigate into\n   * the inner (nested) zone. Returning true will ask the first inner zone to set focus.\n   */\n  shouldEnterInnerZone?: (ev: React.KeyboardEvent<HTMLElement>) => boolean;\n\n  /**\n   * Sets the aria-labelledby attribute.\n   * @deprecated Directly use the `aria-labelledby` attribute instead\n   */\n  ariaLabelledBy?: string;\n\n  /**\n   * Sets the aria-describedby attribute.\n   * @deprecated Directly use the `aria-describedby` attribute instead\n   */\n  ariaDescribedBy?: string;\n\n  /**\n   * Callback for when one of immediate children elements gets active by getting focused\n   * or by having one of its respective children elements focused.\n   */\n  onActiveElementChanged?: (element?: HTMLElement, ev?: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * @deprecated Div props provided to the FocusZone will be mixed into the root element.\n   * Deprecated at v1.12.1.\n   */\n  rootProps?: React.HTMLAttributes<HTMLDivElement>;\n\n  /**\n   * Callback method for determining if focus should indeed be set on the given element.\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus should be set to the given element, false to avoid setting focus.\n   * @deprecated Use `shouldReceiveFocus` instead.\n   */\n  onBeforeFocus?: (childElement?: HTMLElement) => boolean;\n\n  /**\n   * Callback method for determining if focus should indeed be set on the given element.\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus should be set to the given element, false to avoid setting focus.\n   */\n  shouldReceiveFocus?: (childElement?: HTMLElement) => boolean;\n\n  /** Allows focus to park on root when focus is in the `FocusZone` at render time. */\n  allowFocusRoot?: boolean;\n\n  /**\n   * Allows tab key to be handled to tab through a list of items in the focus zone,\n   * an unfortunate side effect is that users will not be able to tab out of the focus zone\n   * and have to hit escape or some other key.\n   * @deprecated Use `handleTabKey` instead.\n   *\n   */\n  allowTabKey?: boolean;\n\n  /**\n   * Allows tab key to be handled to tab through a list of items in the focus zone,\n   * an unfortunate side effect is that users will not be able to tab out of the focus zone\n   * and have to hit escape or some other key.\n   */\n  handleTabKey?: FocusZoneTabbableElements;\n\n  /**\n   * If true and FocusZone's root element (container) receives focus, the focus will land either on the\n   * defaultTabbableElement (if set) or on the first tabbable element of this FocusZone.\n   * Usually a case for nested focus zones, when the nested focus zone's container is a focusable element.\n   */\n  shouldFocusInnerElementWhenReceivedFocus?: boolean;\n\n  /**\n   * If true and TAB key is not handled by FocusZone, resets current active element to null value.\n   * For example, when roving index is not desirable and focus should always reset to the default tabbable element.\n   */\n  shouldResetActiveElementWhenTabFromZone?: boolean;\n\n  /**\n   * Determines whether the FocusZone will walk up the DOM trying to invoke click callbacks on focusable elements on\n   * Enter and Space keydowns to ensure accessibility for tags that don't guarantee this behavior.\n   * @defaultvalue true\n   */\n  shouldRaiseClicks?: boolean;\n\n  /**\n   * Relates to `shouldRaiseClicks`.\n   * Allows the click event raising for the \"Enter\" key to be set independently from `shouldRaiseClicks`.\n   * Inherits the value of `shouldRaiseClicks` if not set explicitly.\n   */\n  shouldRaiseClicksOnEnter?: boolean;\n\n  /**\n   * Relates to `shouldRaiseClicks`.\n   * Allows the click event raising for the \"Space\" key to be set independently from `shouldRaiseClicks`.\n   * Inherits the value of `shouldRaiseClicks` if not set explicitly.\n   */\n  shouldRaiseClicksOnSpace?: boolean;\n\n  /**\n   * A callback method to determine if an input or textarea element should lose focus on arrow keys\n   *  @param inputElement - The input or textarea element which is to lose focus.\n   *  @returns True if input element should loose focus or false otherwise.\n   */\n  shouldInputLoseFocusOnArrowKey?: (inputElement: HTMLInputElement | HTMLTextAreaElement) => boolean;\n\n  /**\n   * Determines whether to disable the paging support for Page Up and Page Down keyboard scenarios.\n   * @defaultvalue false\n   */\n  pagingSupportDisabled?: boolean;\n\n  /**\n   * Determines whether to check for data-no-horizontal-wrap or data-no-vertical-wrap attributes\n   * when determining how to move focus\n   * @defaultvalue false\n   */\n  checkForNoWrap?: boolean;\n\n  /**\n   * Whether the FocusZone should allow focus events to propagate past the FocusZone.\n   * @deprecated Use `stopFocusPropagation` instead.\n   */\n  doNotAllowFocusEventToPropagate?: boolean;\n\n  /**\n   * Whether the FocusZone should allow focus events to propagate past the FocusZone.\n   */\n  stopFocusPropagation?: boolean;\n\n  /**\n   * Callback to notify creators that focus has been set on the FocusZone\n   * @deprecated Use `onFocus` instead.\n   */\n  onFocusNotification?: () => void;\n\n  /**\n   * Callback called when \"focus\" event triggered in FocusZone.\n   * @param event - React's original FocusEvent.\n   */\n  onFocus?: (event: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * If true, FocusZone prevents the default behavior of Keyboard events when changing focus between elements.\n   * @defaultvalue false\n   */\n  preventDefaultWhenHandled?: boolean;\n\n  /**\n   * If true, prevents the FocusZone from attempting to restore the focus to the inner element when the focus is on the\n   * root element after componentDidUpdate.\n   * @defaultvalue false\n   */\n  preventFocusRestoration?: boolean;\n}\n/**\n * {@docCategory FocusZone}\n */\nexport const FocusZoneTabbableElements = {\n  /** Tabbing is not allowed */\n  none: 0 as 0,\n\n  /** All tabbing action is allowed */\n  all: 1 as 1,\n\n  /** Tabbing is allowed only on input elements */\n  inputOnly: 2 as 2,\n};\n\n/**\n * {@docCategory FocusZone}\n */\nexport type FocusZoneTabbableElements = typeof FocusZoneTabbableElements[keyof typeof FocusZoneTabbableElements];\n\n/**\n * {@docCategory FocusZone}\n */\nexport enum FocusZoneDirection {\n  /** Only react to up/down arrows. */\n  vertical = 0,\n\n  /** Only react to left/right arrows. */\n  horizontal = 1,\n\n  /** React to all arrows. */\n  bidirectional = 2,\n\n  /**\n   * React to all arrows. Navigate next item in DOM on right/down arrow keys and previous - left/up arrow keys.\n   * Right and Left arrow keys are swapped in RTL mode.\n   */\n  domOrder = 3,\n}\n"]}