{"version":3,"file":"timeMath.js","sourceRoot":"../src/","sources":["timeMath/timeMath.ts"],"names":[],"mappings":";;;;IAEA;;;;;OAKG;IACI,IAAM,UAAU,GAAG,UAAC,IAAU,EAAE,OAAe;QACpD,IAAM,MAAM,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;QACxC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,GAAG,OAAO,GAAG,6BAAa,CAAC,gBAAgB,GAAG,6BAAa,CAAC,kBAAkB,CAAC,CAAC;QAC/G,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;IAJW,QAAA,UAAU,cAIrB;IAEF;;;;;;OAMG;IACI,IAAM,qBAAqB,GAAG,UAAC,IAAU,EAAE,UAAkB;QAClE,IAAM,MAAM,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;QACxC,IAAI,MAAM,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;QACjC,IAAI,6BAAa,CAAC,gBAAgB,GAAG,UAAU,EAAE;YAC/C,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SACtB;aAAM;YACL,IAAM,KAAK,GAAG,6BAAa,CAAC,gBAAgB,GAAG,UAAU,CAAC;YAC1D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,EAAE,EAAE;gBAC/B,IAAI,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,MAAM,IAAI,UAAU,GAAG,CAAC,EAAE;oBAC7D,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;oBACxB,MAAM;iBACP;aACF;YACD,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;SAC3B;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;IAhBW,QAAA,qBAAqB,yBAgBhC;IAEF;;;;;;OAMG;IACI,IAAM,wBAAwB,GAAG,UAAC,SAAkB,EAAE,QAAc,EAAE,YAAoB;QACzF,IAAA,KACJ,6BAAa,CAAC,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,EAD/C,aAAa,QAAA,EAAE,eAAe,QAAA,EAAE,eAAe,QAAA,EAAE,UAAU,QACZ,CAAC;QAEzD,IAAI,KAAK,GAAG,CAAC,aAAa,CAAC;QAC3B,IAAM,OAAO,GAAG,CAAC,eAAe,CAAC;QACjC,IAAM,OAAO,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;QAEvD,IAAI,SAAS,IAAI,UAAU,EAAE;YAC3B,IAAI,UAAU,CAAC,WAAW,EAAE,KAAK,IAAI,IAAI,KAAK,KAAK,6BAAa,CAAC,oBAAoB,EAAE;gBACrF,KAAK,IAAI,6BAAa,CAAC,oBAAoB,CAAC;aAC7C;iBAAM,IAAI,UAAU,CAAC,WAAW,EAAE,KAAK,IAAI,IAAI,KAAK,KAAK,6BAAa,CAAC,oBAAoB,EAAE;gBAC5F,KAAK,IAAI,6BAAa,CAAC,oBAAoB,CAAC;aAC7C;SACF;QAED,IAAI,WAAW,CAAC;QAChB,IAAI,QAAQ,CAAC,QAAQ,EAAE,GAAG,KAAK,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,KAAK,IAAI,QAAQ,CAAC,UAAU,EAAE,GAAG,OAAO,CAAC,EAAE;YACrG,WAAW,GAAG,6BAAa,CAAC,aAAa,GAAG,QAAQ,CAAC,QAAQ,EAAE,GAAG,KAAK,CAAC;SACzE;aAAM;YACL,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,EAAE,GAAG,KAAK,CAAC,CAAC;SACrD;QAED,IAAM,MAAM,GACV,6BAAa,CAAC,kBAAkB,GAAG,6BAAa,CAAC,gBAAgB,GAAG,WAAW,GAAG,6BAAa,CAAC,kBAAkB;YAClH,OAAO,GAAG,6BAAa,CAAC,kBAAkB,CAAC;QAE7C,IAAM,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC;QACnD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QACzB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAEzB,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IAhCW,QAAA,wBAAwB,4BAgCnC","sourcesContent":["import { TimeConstants } from '../dateValues/timeConstants';\n\n/**\n * Returns a date offset from the given date by the specified number of minutes.\n * @param date - The origin date\n * @param minutes - The number of minutes to offset. 'minutes' can be negative.\n * @returns A new Date object offset from the origin date by the given number of minutes\n */\nexport const addMinutes = (date: Date, minutes: number): Date => {\n  const result = new Date(date.getTime());\n  result.setTime(result.getTime() + minutes * TimeConstants.MinutesInOneHour * TimeConstants.MillisecondsIn1Sec);\n  return result;\n};\n\n/**\n * Rounds the date's minute up to the next available increment. For example, if `date` has time 1:21\n * and `increments` is 5, the resulting time will be 1:25.\n * @param date - Date to ceil minutes\n * @param increments - Time increments\n * @returns Date with ceiled minute\n */\nexport const ceilMinuteToIncrement = (date: Date, increments: number) => {\n  const result = new Date(date.getTime());\n  let minute = result.getMinutes();\n  if (TimeConstants.MinutesInOneHour % increments) {\n    result.setMinutes(0);\n  } else {\n    const times = TimeConstants.MinutesInOneHour / increments;\n    for (let i = 1; i <= times; i++) {\n      if (minute > increments * (i - 1) && minute <= increments * i) {\n        minute = increments * i;\n        break;\n      }\n    }\n    result.setMinutes(minute);\n  }\n  return result;\n};\n\n/**\n * Returns a date object from the selected time.\n * @param useHour12 - If the time picker uses 12 or 24 hour formatting\n * @param baseDate - The baseline date to calculate the offset of the selected time\n * @param selectedTime - A string representing the user selected time\n * @returns A new date object offset from the baseDate using the selected time.\n */\nexport const getDateFromTimeSelection = (useHour12: boolean, baseDate: Date, selectedTime: string): Date => {\n  const [, selectedHours, selectedMinutes, selectedSeconds, selectedAp] =\n    TimeConstants.TimeFormatRegex.exec(selectedTime) || [];\n\n  let hours = +selectedHours;\n  const minutes = +selectedMinutes;\n  const seconds = selectedSeconds ? +selectedSeconds : 0;\n\n  if (useHour12 && selectedAp) {\n    if (selectedAp.toLowerCase() === 'pm' && hours !== TimeConstants.OffsetTo24HourFormat) {\n      hours += TimeConstants.OffsetTo24HourFormat;\n    } else if (selectedAp.toLowerCase() === 'am' && hours === TimeConstants.OffsetTo24HourFormat) {\n      hours -= TimeConstants.OffsetTo24HourFormat;\n    }\n  }\n\n  let hoursOffset;\n  if (baseDate.getHours() > hours || (baseDate.getHours() === hours && baseDate.getMinutes() > minutes)) {\n    hoursOffset = TimeConstants.HoursInOneDay - baseDate.getHours() + hours;\n  } else {\n    hoursOffset = Math.abs(baseDate.getHours() - hours);\n  }\n\n  const offset =\n    TimeConstants.MillisecondsIn1Sec * TimeConstants.MinutesInOneHour * hoursOffset * TimeConstants.SecondsInOneMinute +\n    seconds * TimeConstants.MillisecondsIn1Sec;\n\n  const date = new Date(baseDate.getTime() + offset);\n  date.setMinutes(minutes);\n  date.setSeconds(seconds);\n\n  return date;\n};\n"]}