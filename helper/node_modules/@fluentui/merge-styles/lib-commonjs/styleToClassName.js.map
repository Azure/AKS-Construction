{"version":3,"file":"styleToClassName.js","sourceRoot":"../src/","sources":["styleToClassName.ts"],"names":[],"mappings":"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","sourcesContent":["import { IStyle } from './IStyle';\nimport { IRawStyle } from './IRawStyle';\n\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nimport { IStyleOptions } from './IStyleOptions';\nimport { tokenizeWithParentheses } from './tokenizeWithParentheses';\n\nconst DISPLAY_NAME = 'displayName';\n\ntype IDictionary = { [key: string]: any };\n\ninterface IRuleSet {\n  __order: string[];\n  [key: string]: IDictionary;\n}\n\nfunction getDisplayName(rules?: { [key: string]: IRawStyle }): string | undefined {\n  const rootStyle: IStyle = rules && rules['&'];\n\n  return rootStyle ? (rootStyle as IRawStyle).displayName : undefined;\n}\n\nconst globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n\ntype ReplacementInfo = [number, number, string];\n\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\nfunction expandCommaSeparatedGlobals(selectorWithGlobals: string): string {\n  // We the selector does not have a :global() we can shortcut\n  if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n    return selectorWithGlobals;\n  }\n\n  const replacementInfo: ReplacementInfo[] = [];\n\n  const findGlobal = /\\:global\\((.+?)\\)/g;\n  let match = null;\n  // Create a result list for global selectors so we can replace them.\n  while ((match = findGlobal.exec(selectorWithGlobals))) {\n    // Only if the found selector is a comma separated list we'll process it.\n    if (match[1].indexOf(',') > -1) {\n      replacementInfo.push([\n        match.index,\n        match.index + match[0].length,\n        // Wrap each of the found selectors in :global()\n        match[1]\n          .split(',')\n          .map((v: string) => `:global(${v.trim()})`)\n          .join(', '),\n      ]);\n    }\n  }\n\n  // Replace the found selectors with their wrapped variants in reverse order\n  return replacementInfo\n    .reverse()\n    .reduce((selector: string, [matchIndex, matchEndIndex, replacement]: ReplacementInfo) => {\n      const prefix = selector.slice(0, matchIndex);\n      const suffix = selector.slice(matchEndIndex);\n\n      return prefix + replacement + suffix;\n    }, selectorWithGlobals);\n}\n\nfunction expandSelector(newSelector: string, currentSelector: string): string {\n  if (newSelector.indexOf(':global(') >= 0) {\n    return newSelector.replace(globalSelectorRegExp, '$1');\n  } else if (newSelector.indexOf(':') === 0) {\n    return currentSelector + newSelector;\n  } else if (newSelector.indexOf('&') < 0) {\n    return currentSelector + ' ' + newSelector;\n  }\n\n  return newSelector;\n}\n\nfunction extractSelector(currentSelector: string, rules: IRuleSet = { __order: [] }, selector: string, value: IStyle) {\n  if (selector.indexOf('@') === 0) {\n    selector = selector + '{' + currentSelector;\n    extractRules([value], rules, selector);\n  } else if (selector.indexOf(',') > -1) {\n    expandCommaSeparatedGlobals(selector)\n      .split(',')\n      .map((s: string) => s.trim())\n      .forEach((separatedSelector: string) =>\n        extractRules([value], rules, expandSelector(separatedSelector, currentSelector)),\n      );\n  } else {\n    extractRules([value], rules, expandSelector(selector, currentSelector));\n  }\n}\n\nfunction extractRules(args: IStyle[], rules: IRuleSet = { __order: [] }, currentSelector: string = '&'): IRuleSet {\n  const stylesheet = Stylesheet.getInstance();\n  let currentRules: IDictionary | undefined = rules[currentSelector] as IDictionary;\n\n  if (!currentRules) {\n    currentRules = {};\n    rules[currentSelector] = currentRules;\n    rules.__order.push(currentSelector);\n  }\n\n  for (const arg of args) {\n    // If the arg is a string, we need to look up the class map and merge.\n    if (typeof arg === 'string') {\n      const expandedRules = stylesheet.argsFromClassName(arg);\n\n      if (expandedRules) {\n        extractRules(expandedRules, rules, currentSelector);\n      }\n      // Else if the arg is an array, we need to recurse in.\n    } else if (Array.isArray(arg)) {\n      extractRules(arg, rules, currentSelector);\n    } else {\n      for (const prop in arg as any) {\n        if ((arg as any).hasOwnProperty(prop)) {\n          const propValue = (arg as any)[prop];\n\n          if (prop === 'selectors') {\n            // every child is a selector.\n            const selectors: { [key: string]: IStyle } = (arg as any).selectors;\n\n            for (const newSelector in selectors) {\n              if (selectors.hasOwnProperty(newSelector)) {\n                extractSelector(currentSelector, rules, newSelector, selectors[newSelector]);\n              }\n            }\n          } else if (typeof propValue === 'object') {\n            // prop is a selector.\n            if (propValue !== null) {\n              extractSelector(currentSelector, rules, prop, propValue);\n            }\n          } else {\n            if (propValue !== undefined) {\n              // Else, add the rule to the currentSelector.\n              if (prop === 'margin' || prop === 'padding') {\n                expandQuads(currentRules, prop, propValue);\n              } else {\n                (currentRules as any)[prop] = propValue;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return rules;\n}\n\nfunction expandQuads(currentRules: IDictionary, name: string, value: string): void {\n  let parts = typeof value === 'string' ? tokenizeWithParentheses(value) : [value];\n\n  if (parts.length === 0) {\n    parts.push(value);\n  }\n\n  if (parts[parts.length - 1] === '!important') {\n    // Remove !important from parts, and append it to each part individually\n    parts = parts.slice(0, -1).map(p => p + ' !important');\n  }\n\n  currentRules[name + 'Top'] = parts[0];\n  currentRules[name + 'Right'] = parts[1] || parts[0];\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\n\nfunction getKeyForRules(options: IStyleOptions, rules: IRuleSet): string | undefined {\n  const serialized: string[] = [options.rtl ? 'rtl' : 'ltr'];\n  let hasProps = false;\n\n  for (const selector of rules.__order) {\n    serialized.push(selector);\n    const rulesForSelector = rules[selector];\n\n    for (const propName in rulesForSelector) {\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n        hasProps = true;\n        serialized.push(propName, rulesForSelector[propName]);\n      }\n    }\n  }\n\n  return hasProps ? serialized.join('') : undefined;\n}\n\nfunction repeatString(target: string, count: number): string {\n  if (count <= 0) {\n    return '';\n  }\n\n  if (count === 1) {\n    return target;\n  }\n\n  return target + repeatString(target, count - 1);\n}\n\nexport function serializeRuleEntries(options: IStyleOptions, ruleEntries: { [key: string]: string | number }): string {\n  if (!ruleEntries) {\n    return '';\n  }\n\n  const allEntries: (string | number)[] = [];\n\n  for (const entry in ruleEntries) {\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n      allEntries.push(entry, ruleEntries[entry]);\n    }\n  }\n\n  // Apply transforms.\n  for (let i = 0; i < allEntries.length; i += 2) {\n    kebabRules(allEntries, i);\n    provideUnits(allEntries, i);\n    rtlifyRules(options, allEntries, i);\n    prefixRules(allEntries, i);\n  }\n\n  // Apply punctuation.\n  for (let i = 1; i < allEntries.length; i += 4) {\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\n  }\n\n  return allEntries.join('');\n}\n\nexport interface IRegistration {\n  className: string;\n  key: string;\n  args: IStyle[];\n  rulesToInsert: string[];\n}\n\nexport function styleToRegistration(options: IStyleOptions, ...args: IStyle[]): IRegistration | undefined {\n  const rules: IRuleSet = extractRules(args);\n  const key = getKeyForRules(options, rules);\n\n  if (key) {\n    const stylesheet = Stylesheet.getInstance();\n    const registration: Partial<IRegistration> = {\n      className: stylesheet.classNameFromKey(key),\n      key,\n      args,\n    };\n\n    if (!registration.className) {\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\n      const rulesToInsert: string[] = [];\n\n      for (const selector of rules.__order) {\n        rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n      }\n      registration.rulesToInsert = rulesToInsert;\n    }\n\n    return registration as IRegistration;\n  }\n\n  return undefined;\n}\n\n/**\n * Insert style to stylesheet.\n * @param registration Style registration.\n * @param specificityMultiplier Number of times classname selector is repeated in the css rule.\n * This is to increase css specificity in case it's needed. Default to 1.\n */\nexport function applyRegistration(registration: IRegistration, specificityMultiplier: number = 1): void {\n  const stylesheet = Stylesheet.getInstance();\n  const { className, key, args, rulesToInsert } = registration;\n\n  if (rulesToInsert) {\n    // rulesToInsert is an ordered array of selector/rule pairs.\n    for (let i = 0; i < rulesToInsert.length; i += 2) {\n      const rules = rulesToInsert[i + 1];\n      if (rules) {\n        let selector = rulesToInsert[i];\n        selector = selector.replace(/&/g, repeatString(`.${registration.className}`, specificityMultiplier));\n\n        // Insert. Note if a media query, we must close the query with a final bracket.\n        const processedRule = `${selector}{${rules}}${selector.indexOf('@') === 0 ? '}' : ''}`;\n        stylesheet.insertRule(processedRule);\n      }\n    }\n    stylesheet.cacheClassName(className!, key!, args!, rulesToInsert);\n  }\n}\n\nexport function styleToClassName(options: IStyleOptions, ...args: IStyle[]): string {\n  const registration = styleToRegistration(options, ...args);\n  if (registration) {\n    applyRegistration(registration, options.specificityMultiplier);\n\n    return registration.className;\n  }\n\n  return '';\n}\n"]}