{"version":3,"file":"modalize.js","sourceRoot":"../src/","sources":["modalize.ts"],"names":[],"mappings":"AAAA;;;;GAIG;;;;;IAIH,0CAA0C;IAC1C,IAAM,YAAY,GAAG,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;IAErD;;;OAGG;IACH,SAAgB,QAAQ,CAAC,MAAmB;QAC1C,IAAM,cAAc,GAAG,yBAAW,CAAC,MAAM,CAAC,CAAC;QAC3C,IAAI,CAAC,cAAc,EAAE;YACnB,uBAAuB;YACvB,OAAO,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC;SACxB;QAED,IAAI,aAAa,GAAmC,EAAE,CAAC;QAEvD,kFAAkF;QAClF,OAAO,MAAM,KAAK,cAAc,CAAC,IAAI,IAAI,MAAM,CAAC,aAAa,EAAE;YAC7D,uCAAuC;YACvC,KAAsB,UAA2D,EAA3D,KAAC,MAAM,CAAC,aAAa,CAAC,QAAqC,EAA3D,cAA2D,EAA3D,IAA2D,EAAE;gBAA9E,IAAM,OAAO,SAAA;gBAChB,mDAAmD;gBACnD,IAAM,UAAU,GAAG,OAAO,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC;gBACvD,IAAI,OAAO,KAAK,MAAM,IAAI,CAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,WAAW,EAAE,MAAK,MAAM,IAAI,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;oBAC9G,aAAa,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC;iBAC3C;aACF;YAED,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC;SAC/B;QAED,2DAA2D;QAC3D,aAAa,CAAC,OAAO,CAAC,UAAC,EAAM;gBAAL,IAAI,QAAA;YAC1B,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;QAEH,OAAO;YACL,UAAU,CAAC,aAAa,CAAC,CAAC;YAC1B,aAAa,GAAG,EAAE,CAAC,CAAC,UAAU;QAChC,CAAC,CAAC;IACJ,CAAC;IAhCD,4BAgCC;IAED;;OAEG;IACH,SAAS,UAAU,CAAC,aAA6C;QAC/D,aAAa,CAAC,OAAO,CAAC,UAAC,EAAqB;gBAApB,IAAI,QAAA,EAAE,aAAa,QAAA;YACzC,8CAA8C;YAC9C,IAAI,aAAa,EAAE;gBACjB,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;aACjD;iBAAM;gBACL,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;aACrC;QACH,CAAC,CAAC,CAAC;IACL,CAAC","sourcesContent":["/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\n\nimport { getDocument } from './dom/getDocument';\n\n/** Tag names to ignore when modalizing */\nconst tagsToIgnore = ['TEMPLATE', 'STYLE', 'SCRIPT'];\n\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\nexport function modalize(target: HTMLElement): () => void {\n  const targetDocument = getDocument(target);\n  if (!targetDocument) {\n    // can't do this in SSR\n    return () => undefined;\n  }\n\n  let affectedNodes: [HTMLElement, string | null][] = [];\n\n  // start at target, then recurse and do the same for parent, until we reach <body>\n  while (target !== targetDocument.body && target.parentElement) {\n    // grab all siblings of current element\n    for (const sibling of (target.parentElement.children as unknown) as HTMLElement[]) {\n      // but ignore elements that are already aria-hidden\n      const ariaHidden = sibling.getAttribute('aria-hidden');\n      if (sibling !== target && ariaHidden?.toLowerCase() !== 'true' && tagsToIgnore.indexOf(sibling.tagName) === -1) {\n        affectedNodes.push([sibling, ariaHidden]);\n      }\n    }\n\n    target = target.parentElement;\n  }\n\n  // take all those elements and set aria-hidden=true on them\n  affectedNodes.forEach(([node]) => {\n    node.setAttribute('aria-hidden', 'true');\n  });\n\n  return () => {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n\n/**\n * Undoes the changes that modalize() did.\n */\nfunction unmodalize(affectedNodes: [HTMLElement, string | null][]) {\n  affectedNodes.forEach(([node, originalValue]) => {\n    // Restore the original value (false or unset)\n    if (originalValue) {\n      node.setAttribute('aria-hidden', originalValue);\n    } else {\n      node.removeAttribute('aria-hidden');\n    }\n  });\n}\n"]}