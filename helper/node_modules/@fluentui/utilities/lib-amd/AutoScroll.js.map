{"version":3,"file":"AutoScroll.js","sourceRoot":"../src/","sources":["AutoScroll.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventGroup } from './EventGroup';\nimport { findScrollableParent } from './scroll';\nimport { getRect } from './dom/getRect';\nimport type { IRectangle } from './IRectangle';\n\ndeclare function setTimeout(cb: Function, delay: number): number;\n\nconst SCROLL_ITERATION_DELAY = 16;\nconst SCROLL_GUTTER = 100;\nconst MAX_SCROLL_VELOCITY = 15;\n\n/**\n * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container\n * up/down depending on how close the mouse is to the top/bottom of the container.\n *\n * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.\n *\n * @public\n * {@docCategory AutoScroll}\n */\nexport class AutoScroll {\n  private _events: EventGroup;\n  private _scrollableParent: HTMLElement | null;\n  private _scrollRect: IRectangle | undefined;\n  private _scrollVelocity!: number;\n  private _isVerticalScroll!: boolean;\n  private _timeoutId?: number;\n\n  constructor(element: HTMLElement) {\n    this._events = new EventGroup(this);\n    this._scrollableParent = findScrollableParent(element) as HTMLElement;\n\n    this._incrementScroll = this._incrementScroll.bind(this);\n    this._scrollRect = getRect(this._scrollableParent);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (this._scrollableParent === (window as any)) {\n      this._scrollableParent = document.body;\n    }\n\n    if (this._scrollableParent) {\n      this._events.on(window, 'mousemove', this._onMouseMove, true);\n      this._events.on(window, 'touchmove', this._onTouchMove, true);\n    }\n  }\n\n  public dispose(): void {\n    this._events.dispose();\n    this._stopScroll();\n  }\n\n  private _onMouseMove(ev: MouseEvent): void {\n    this._computeScrollVelocity(ev);\n  }\n\n  private _onTouchMove(ev: TouchEvent): void {\n    if (ev.touches.length > 0) {\n      this._computeScrollVelocity(ev);\n    }\n  }\n\n  private _computeScrollVelocity(ev: MouseEvent | TouchEvent): void {\n    if (!this._scrollRect) {\n      return;\n    }\n\n    let clientX: number;\n    let clientY: number;\n    if ('clientX' in ev) {\n      clientX = ev.clientX;\n      clientY = ev.clientY;\n    } else {\n      clientX = ev.touches[0].clientX;\n      clientY = ev.touches[0].clientY;\n    }\n\n    let scrollRectTop = this._scrollRect.top;\n    let scrollRectLeft = this._scrollRect.left;\n    let scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;\n    let scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;\n\n    // variables to use for alternating scroll direction\n    let scrollRect;\n    let clientDirection;\n    let scrollClient;\n\n    // if either of these conditions are met we are scrolling vertically else horizontally\n    if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {\n      clientDirection = clientY;\n      scrollRect = scrollRectTop;\n      scrollClient = scrollClientBottom;\n      this._isVerticalScroll = true;\n    } else {\n      clientDirection = clientX;\n      scrollRect = scrollRectLeft;\n      scrollClient = scrollClientRight;\n      this._isVerticalScroll = false;\n    }\n\n    // calculate scroll velocity and direction\n    if (clientDirection! < scrollRect + SCROLL_GUTTER) {\n      this._scrollVelocity = Math.max(\n        -MAX_SCROLL_VELOCITY,\n        -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER),\n      );\n    } else if (clientDirection > scrollClient) {\n      this._scrollVelocity = Math.min(\n        MAX_SCROLL_VELOCITY,\n        MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER),\n      );\n    } else {\n      this._scrollVelocity = 0;\n    }\n\n    if (this._scrollVelocity) {\n      this._startScroll();\n    } else {\n      this._stopScroll();\n    }\n  }\n\n  private _startScroll(): void {\n    if (!this._timeoutId) {\n      this._incrementScroll();\n    }\n  }\n\n  private _incrementScroll(): void {\n    if (this._scrollableParent) {\n      if (this._isVerticalScroll) {\n        this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);\n      } else {\n        this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);\n      }\n    }\n\n    this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);\n  }\n\n  private _stopScroll(): void {\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      delete this._timeoutId;\n    }\n  }\n}\n"]}