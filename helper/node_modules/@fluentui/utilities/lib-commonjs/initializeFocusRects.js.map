{"version":3,"file":"initializeFocusRects.js","sourceRoot":"../src/","sources":["initializeFocusRects.ts"],"names":[],"mappings":";;;AAAA,6CAA4C;AAC5C,uCAAkD;AAClD,2DAA0D;AAS1D;;;;;;;;;;;;;;;GAeG;AACH,SAAgB,oBAAoB,CAAC,MAAe;;IAClD,IAAM,GAAG,GAAG,CAAC,MAAM,IAAI,qBAAS,EAAE,CAAc,CAAC;IACjD,IAAI,CAAC,GAAG,IAAI,CAAA,MAAA,GAAG,CAAC,YAAY,0CAAE,iBAAiB,MAAK,IAAI,EAAE;QACxD,OAAO;KACR;IAED,IAAI,CAAC,GAAG,CAAC,2BAA2B,EAAE;QACpC,GAAG,CAAC,2BAA2B,GAAG,IAAI,CAAC;QACvC,GAAG,CAAC,gBAAgB,CAAC,WAAW,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;QACtD,GAAG,CAAC,gBAAgB,CAAC,aAAa,EAAE,cAAc,EAAE,IAAI,CAAC,CAAC;QAC1D,GAAG,CAAC,gBAAgB,CAAC,SAAS,EAAE,UAAwB,EAAE,IAAI,CAAC,CAAC;KACjE;AACH,CAAC;AAZD,oDAYC;AAED,SAAS,YAAY,CAAC,EAAc;IAClC,uCAAkB,CAAC,KAAK,EAAE,EAAE,CAAC,MAAiB,CAAC,CAAC;AAClD,CAAC;AAED,SAAS,cAAc,CAAC,EAAgB;IACtC,IAAI,EAAE,CAAC,WAAW,KAAK,OAAO,EAAE;QAC9B,uCAAkB,CAAC,KAAK,EAAE,EAAE,CAAC,MAAiB,CAAC,CAAC;KACjD;AACH,CAAC;AAED,SAAS,UAAU,CAAC,EAAiB;IACnC,mDAAmD;IACnD,+BAAoB,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,uCAAkB,CAAC,IAAI,EAAE,EAAE,CAAC,MAAiB,CAAC,CAAC;AACnF,CAAC","sourcesContent":["import { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\ntype AppWindow =\n  | (Window & {\n      __hasInitializeFocusRects__: boolean;\n      FabricConfig?: { disableFocusRects?: boolean };\n    })\n  | undefined;\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param window - the window used to add the event listeners\n * @deprecated Use useFocusRects hook or FocusRects component instead.\n */\nexport function initializeFocusRects(window?: Window): void {\n  const win = (window || getWindow()) as AppWindow;\n  if (!win || win.FabricConfig?.disableFocusRects === true) {\n    return;\n  }\n\n  if (!win.__hasInitializeFocusRects__) {\n    win.__hasInitializeFocusRects__ = true;\n    win.addEventListener('mousedown', _onMouseDown, true);\n    win.addEventListener('pointerdown', _onPointerDown, true);\n    win.addEventListener('keydown', _onKeyDown as () => void, true);\n  }\n}\n\nfunction _onMouseDown(ev: MouseEvent): void {\n  setFocusVisibility(false, ev.target as Element);\n}\n\nfunction _onPointerDown(ev: PointerEvent): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element);\n  }\n}\n\nfunction _onKeyDown(ev: KeyboardEvent): void {\n  // eslint-disable-next-line deprecation/deprecation\n  isDirectionalKeyCode(ev.which) && setFocusVisibility(true, ev.target as Element);\n}\n"]}