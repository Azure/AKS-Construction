{"version":3,"file":"createMergedRef.js","sourceRoot":"../src/","sources":["createMergedRef.ts"],"names":[],"mappings":";;;AACA,iCAAsC;AAUtC;;;GAGG;AACH,IAAM,cAAc,GAAG,UAAgB,KAAgC,IAAK,OAAA,UAAC,QAA+B;IAC1G,KAAkB,UAAU,EAAV,KAAA,KAAK,CAAC,IAAI,EAAV,cAAU,EAAV,IAAU,EAAE;QAAzB,IAAM,GAAG,SAAA;QACZ,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE;YAC7B,GAAG,CAAC,QAAQ,CAAC,CAAC;SACf;aAAM,IAAI,GAAG,EAAE;YACd,qDAAqD;YACnD,GAA6E,CAAC,OAAO,GAAG,QAAQ,CAAC;SACpG;KACF;AACH,CAAC,EAT2E,CAS3E,CAAC;AAEF;;GAEG;AACI,IAAM,eAAe,GAAG,UAAuB,KAAc;IAClE,IAAM,KAAK,GAA8B;QACvC,IAAI,EAAE,EAAuC;KAC9C,CAAC;IAEF,OAAO;QACL,iBAA4D;aAA5D,UAA4D,EAA5D,qBAA4D,EAA5D,IAA4D;YAA5D,4BAA4D;;QAE5D,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,CAAC,mBAAW,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE;YACxD,KAAK,CAAC,QAAQ,GAAG,cAAc,CAAgB,KAAK,CAAC,CAAC;SACvD;QAED,KAAK,CAAC,IAAI,GAAG,OAAO,CAAC;QAErB,OAAO,KAAK,CAAC,QAAS,CAAC;IACzB,CAAC,CAAC;AACJ,CAAC,CAAC;AAhBW,QAAA,eAAe,mBAgB1B","sourcesContent":["import * as React from 'react';\nimport { arraysEqual } from './array';\n\n/**\n * Internal state type for the ref.\n */\ntype LocalState<TType, TValue> = {\n  refs: (React.Ref<TType | null | TValue> | undefined)[];\n  resolver?: (newValue: TType | TValue | null) => void;\n};\n\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\nconst createResolver = <TType, TValue>(local: LocalState<TType, TValue>) => (newValue: TType | TValue | null) => {\n  for (const ref of local.refs) {\n    if (typeof ref === 'function') {\n      ref(newValue);\n    } else if (ref) {\n      // work around the immutability of the React.Ref type\n      ((ref as unknown) as React.MutableRefObject<TType | TValue | null | undefined>).current = newValue;\n    }\n  }\n};\n\n/**\n * Helper to merge refs from within class components.\n */\nexport const createMergedRef = <TType, TValue = null>(value?: TValue) => {\n  const local: LocalState<TType, TValue> = {\n    refs: [] as LocalState<TType, TValue>['refs'],\n  };\n\n  return (\n    ...newRefs: (React.Ref<TType | null | TValue> | undefined)[]\n  ): ((newValue: TType | TValue | null) => void) => {\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver<TType, TValue>(local);\n    }\n\n    local.refs = newRefs;\n\n    return local.resolver!;\n  };\n};\n"]}