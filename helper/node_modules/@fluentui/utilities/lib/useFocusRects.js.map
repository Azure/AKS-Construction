{"version":3,"file":"useFocusRects.js","sourceRoot":"../src/","sources":["useFocusRects.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangles.\n * We want to cleanup the listeners before the last component that uses focus rectangles unmounts.\n */\nexport type ListenerCallbacks = {\n  onMouseDown: (ev: MouseEvent) => void;\n  onPointerDown: (ev: PointerEvent) => void;\n  onKeyDown: (ev: KeyboardEvent) => void;\n  onKeyUp: (ev: KeyboardEvent) => void;\n};\nlet mountCounters = new WeakMap<Window | HTMLElement, number>();\nlet callbackMap = new WeakMap<IFocusRectsContext, ListenerCallbacks>();\n\nfunction setMountCounters(key: Window | HTMLElement, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\nfunction setCallbackMap(context: IFocusRectsContext): ListenerCallbacks {\n  let callbacks = callbackMap.get(context);\n  if (callbacks) {\n    return callbacks;\n  }\n\n  const onMouseDown = (ev: MouseEvent) => _onMouseDown(ev, context.registeredProviders);\n  const onPointerDown = (ev: PointerEvent) => _onPointerDown(ev, context.registeredProviders);\n  const onKeyDown = (ev: KeyboardEvent) => _onKeyDown(ev, context.registeredProviders);\n  const onKeyUp = (ev: KeyboardEvent) => _onKeyUp(ev, context.registeredProviders);\n  callbacks = { onMouseDown, onPointerDown, onKeyDown, onKeyUp };\n\n  callbackMap.set(context, callbacks);\n  return callbacks;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\nexport type IFocusRectsContext = {\n  /**\n   * Ref to the root element of the provider\n   */\n  readonly providerRef: React.RefObject<HTMLElement>;\n\n  /**\n   * Array of this and all child provider elements under this one in the React tree.\n   *\n   * Tracking all child providers will allow a focus event in the parent to also set focus styling in its descendants.\n   * This is needed for Combobox, for example, because the focus events happen on the parent context, but the visual\n   * focus indicator is in the combobox callout. The callout needs to be notified on focus events from the parent.\n   */\n  readonly registeredProviders: React.RefObject<HTMLElement>[];\n\n  /**\n   * Used by child FocusRectsProviders to register their element with the parent provider.\n   */\n  readonly registerProvider: (ref: React.RefObject<HTMLElement>) => void;\n\n  /**\n   * Used by child FocusRectsProviders to unregister their element from the parent provider.\n   */\n  readonly unregisterProvider: (ref: React.RefObject<HTMLElement>) => void;\n};\n\nexport const FocusRectsContext = React.createContext<IFocusRectsContext | undefined>(undefined);\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown, keyup, mousedown and pointerdown events. (It will only do it once for the current element of\n *    the FocusRectsContext providerRef or once per window if no such element is provided via context, so it's safe to\n *    call this method multiple times.)\n * 2. When the user presses triggers a keydown or keyup event via directional keyboard keys, adds the\n *    'ms-Fabric--isFocusVisible' classname to the current element of the FocusRectsContext providerRef or the document\n *    body if no such element is provided via context, and removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user triggers a mousedown or pointerdown event, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    current element of the FocusRectsContext providerRef or the document body if no such element is provided via\n *    context, and removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  const context = React.useContext(FocusRectsContext);\n\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let el: Window | HTMLElement = win;\n    let onMouseDown: (ev: MouseEvent) => void;\n    let onPointerDown: (ev: PointerEvent) => void;\n    let onKeyDown: (ev: KeyboardEvent) => void;\n    let onKeyUp: (ev: KeyboardEvent) => void;\n    if (context?.providerRef?.current) {\n      el = context.providerRef.current;\n      const callbacks = setCallbackMap(context);\n      onMouseDown = callbacks.onMouseDown;\n      onPointerDown = callbacks.onPointerDown;\n      onKeyDown = callbacks.onKeyDown;\n      onKeyUp = callbacks.onKeyUp;\n    } else {\n      onMouseDown = _onMouseDown;\n      onPointerDown = _onPointerDown;\n      onKeyDown = _onKeyDown;\n      onKeyUp = _onKeyUp;\n    }\n\n    let count = setMountCounters(el, 1);\n    if (count <= 1) {\n      el.addEventListener('mousedown', onMouseDown, true);\n      el.addEventListener('pointerdown', onPointerDown, true);\n      el.addEventListener('keydown', onKeyDown, true);\n      el.addEventListener('keyup', onKeyUp, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n      count = setMountCounters(el, -1);\n      if (count === 0) {\n        el.removeEventListener('mousedown', onMouseDown, true);\n        el.removeEventListener('pointerdown', onPointerDown, true);\n        el.removeEventListener('keydown', onKeyDown, true);\n        el.removeEventListener('keyup', onKeyUp, true);\n      }\n    };\n  }, [context, rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  setFocusVisibility(false, ev.target as Element, registeredProviders);\n}\n\nfunction _onPointerDown(ev: PointerEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element, registeredProviders);\n  }\n}\n\n// You need both a keydown and a keyup listener that sets focus visibility to true to handle two distinct scenarios when\n// attaching the listeners and classnames to the provider instead of the document body.\n// If you only have a keydown listener, then the focus rectangles will not show when moving from outside of the provider\n// to inside it. That is why a keyup listener is needed, since it will always trigger after the focus event is fired.\n// If you only have a keyup listener, then the focus rectangles will not show moving between different tabbable elements\n// if the tab key is pressed without being released. That's is why we need a keydown listener, since it will trigger for\n// every element that is being tabbed into.\n// This works because `classList.add` is smart and will not duplicate a classname that already exists on the classList\n// when focus visibility is turned on.\nfunction _onKeyDown(ev: KeyboardEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element, registeredProviders);\n  }\n}\n\nfunction _onKeyUp(ev: KeyboardEvent, registeredProviders?: React.RefObject<HTMLElement>[]): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element, registeredProviders);\n  }\n}\n"]}