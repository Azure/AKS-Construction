{"version":3,"file":"MarqueeSelection.base.js","sourceRoot":"../src/","sources":["components/MarqueeSelection/MarqueeSelection.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport {\n  Async,\n  EventGroup,\n  AutoScroll,\n  classNamesFunction,\n  findScrollableParent,\n  getDistanceBetweenPoints,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport type { Point, IRectangle } from '../../Utilities';\nimport type {\n  IMarqueeSelectionProps,\n  IMarqueeSelectionStyleProps,\n  IMarqueeSelectionStyles,\n} from './MarqueeSelection.types';\n\nconst getClassNames = classNamesFunction<IMarqueeSelectionStyleProps, IMarqueeSelectionStyles>();\n\nexport interface IMarqueeSelectionState {\n  dragOrigin?: Point;\n  dragRect?: IRectangle;\n}\n\n// We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\nconst MIN_DRAG_DISTANCE = 5;\n\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\nexport class MarqueeSelectionBase extends React.Component<IMarqueeSelectionProps, IMarqueeSelectionState> {\n  public static defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _dragOrigin: Point | undefined;\n  private _rootRect: IRectangle;\n  private _lastMouseEvent: MouseEvent | undefined;\n  private _autoScroll: AutoScroll | undefined;\n  private _selectedIndicies: { [key: string]: boolean } | undefined;\n  private _preservedIndicies: number[] | undefined;\n  private _itemRectCache: { [key: string]: IRectangle } | undefined;\n  private _allSelectedIndices: { [key: string]: boolean } | undefined;\n  private _scrollableParent?: HTMLElement;\n  private _scrollableSurface?: HTMLElement;\n  private _scrollTop: number;\n  private _scrollLeft: number;\n  private _isTouch: boolean;\n\n  constructor(props: IMarqueeSelectionProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      dragRect: undefined,\n    };\n  }\n\n  public componentDidMount(): void {\n    this._scrollableParent = findScrollableParent(this._root.current) as HTMLElement;\n    this._scrollableSurface = this._scrollableParent === (window as any) ? document.body : this._scrollableParent;\n    // When scroll events come from window, we need to read scrollTop values from the body.\n\n    const hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  }\n\n  public componentWillUnmount(): void {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { rootProps, children, theme, className, styles } = this.props;\n    const { dragRect } = this.state;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    return (\n      <div {...rootProps} className={classNames.root} ref={this._root}>\n        {children}\n        {dragRect && <div className={classNames.dragMask} />}\n        {dragRect && (\n          <div className={classNames.box} style={dragRect}>\n            <div className={classNames.boxFill} />\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n  private _isMouseEventOnScrollbar(ev: MouseEvent): boolean {\n    const targetElement = ev.target as HTMLElement;\n    const targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n    const targetScrollbarHeight = targetElement.offsetHeight - targetElement.clientHeight;\n\n    if (targetScrollbarWidth || targetScrollbarHeight) {\n      const targetRect = targetElement.getBoundingClientRect();\n\n      // Check vertical scroll\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      }\n\n      // Check horizontal scroll\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseDown = (ev: MouseEvent): void => {\n    const { isEnabled, onShouldStartSelection } = this.props;\n\n    // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n    if (this._isMouseEventOnScrollbar(ev)) {\n      return;\n    }\n\n    if (this._isInSelectionToggle(ev)) {\n      return;\n    }\n\n    if (\n      !this._isTouch &&\n      isEnabled &&\n      !this._isDragStartInSelection(ev) &&\n      (!onShouldStartSelection || onShouldStartSelection(ev))\n    ) {\n      if (this._scrollableSurface && ev.button === 0 && this._root.current) {\n        this._selectedIndicies = {};\n        this._preservedIndicies = undefined;\n        this._events.on(window, 'mousemove', this._onAsyncMouseMove, true);\n        this._events.on(this._scrollableParent, 'scroll', this._onAsyncMouseMove);\n        this._events.on(window, 'click', this._onMouseUp, true);\n\n        this._autoScroll = new AutoScroll(this._root.current);\n        this._scrollTop = this._scrollableSurface.scrollTop;\n        this._scrollLeft = this._scrollableSurface.scrollLeft;\n        this._rootRect = this._root.current.getBoundingClientRect();\n\n        this._onMouseMove(ev);\n      }\n    }\n  };\n\n  private _onTouchStart = (ev: TouchEvent): void => {\n    this._isTouch = true;\n\n    this._async.setTimeout(() => {\n      this._isTouch = false;\n    }, 0);\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._isTouch = true;\n\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 0);\n    }\n  };\n\n  private _getRootRect(): IRectangle {\n    return {\n      left:\n        this._rootRect.left +\n        (this._scrollableSurface ? this._scrollLeft - this._scrollableSurface.scrollLeft : this._scrollLeft),\n      top:\n        this._rootRect.top +\n        (this._scrollableSurface ? this._scrollTop - this._scrollableSurface.scrollTop : this._scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height,\n    };\n  }\n\n  private _onAsyncMouseMove(ev: MouseEvent): void {\n    this._async.requestAnimationFrame(() => {\n      this._onMouseMove(ev);\n    });\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  }\n\n  private _onMouseMove(ev: MouseEvent): boolean | undefined {\n    if (!this._autoScroll) {\n      return;\n    }\n\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n\n    const rootRect = this._getRootRect();\n    const currentPoint = { left: ev.clientX - rootRect.left, top: ev.clientY - rootRect.top };\n\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          const { selection } = this.props;\n\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        }\n\n        // We need to constrain the current point to the rootRect boundaries.\n        const constrainedPoint = this.props.isDraggingConstrainedToRoot\n          ? {\n              left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent!.clientX - rootRect.left)),\n              top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent!.clientY - rootRect.top)),\n            }\n          : {\n              left: this._lastMouseEvent!.clientX - rootRect.left,\n              top: this._lastMouseEvent!.clientY - rootRect.top,\n            };\n\n        const dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0)),\n        };\n\n        this._evaluateSelection(dragRect, rootRect);\n\n        this.setState({ dragRect });\n      }\n    }\n\n    return false;\n  }\n\n  private _onMouseUp(ev: MouseEvent): void {\n    this._events.off(window);\n    this._events.off(this._scrollableParent, 'scroll');\n\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined,\n      });\n\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _isPointInRectangle(rectangle: IRectangle, point: Point): boolean {\n    return (\n      !!point.top &&\n      rectangle.top < point.top &&\n      rectangle.bottom! > point.top &&\n      !!point.left &&\n      rectangle.left < point.left &&\n      rectangle.right! > point.left\n    );\n  }\n\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n  private _isDragStartInSelection(ev: MouseEvent): boolean {\n    const selection = this.props.selection;\n    if (!this._root.current || (selection && selection.getSelectedCount() === 0)) {\n      return false;\n    }\n\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = Number(element.getAttribute('data-selection-index'));\n      if (selection.isIndexSelected(index)) {\n        const itemRect = element.getBoundingClientRect();\n        if (this._isPointInRectangle(itemRect, { left: ev.clientX, top: ev.clientY })) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  private _isInSelectionToggle(ev: MouseEvent): boolean {\n    let element: HTMLElement | null = ev.target as HTMLElement;\n\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n\n      element = element.parentElement;\n    }\n\n    return false;\n  }\n\n  private _evaluateSelection(dragRect: IRectangle, rootRect: IRectangle): void {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n\n    const { selection } = this.props;\n    const allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n\n    for (let i = 0; i < allElements.length; i++) {\n      const element = allElements[i];\n      const index = element.getAttribute('data-selection-index') as string;\n\n      // Pull the memoized rectangle for the item, or the get the rect and memoize.\n      let itemRect = this._itemRectCache[index];\n\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect();\n\n        // Normalize the item rect to the dragRect coordinates.\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height,\n        };\n\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n\n      if (\n        itemRect.top < dragRect.top + dragRect.height &&\n        itemRect.bottom! > dragRect.top &&\n        itemRect.left < dragRect.left + dragRect.width &&\n        itemRect.right! > dragRect.left\n      ) {\n        this._selectedIndicies![index] = true;\n      } else {\n        delete this._selectedIndicies![index];\n      }\n    }\n\n    // set previousSelectedIndices to be all of the selected indices from last time\n    const previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {};\n\n    // set all indices that are supposed to be selected in _allSelectedIndices\n    for (const index in this._selectedIndicies!) {\n      if (this._selectedIndicies!.hasOwnProperty(index)) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    if (this._preservedIndicies) {\n      for (const index of this._preservedIndicies!) {\n        this._allSelectedIndices![index] = true;\n      }\n    }\n\n    // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n    let needToUpdate = false;\n    for (const index in this._allSelectedIndices!) {\n      if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n\n    if (!needToUpdate) {\n      for (const index in previousSelectedIndices!) {\n        if (this._allSelectedIndices![index] !== previousSelectedIndices![index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    }\n\n    // only update selection when needed\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      for (const index of Object.keys(this._allSelectedIndices!)) {\n        selection.setIndexSelected(Number(index), true, false);\n      }\n\n      selection.setChangeEvents(true);\n    }\n  }\n}\n"]}