{"version":3,"file":"List.js","sourceRoot":"../src/","sources":["components/List/List.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EACL,KAAK,EACL,UAAU,EACV,SAAS,EACT,GAAG,EACH,aAAa,EACb,SAAS,EACT,oBAAoB,EACpB,cAAc,EACd,SAAS,EACT,SAAS,EACT,sBAAsB,GACvB,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,YAAY,EAAE,MAAM,cAAc,CAAC;AAC5C,OAAO,EAAE,qBAAqB,EAAE,MAAM,iBAAiB,CAAC;AACxD,OAAO,EAAE,eAAe,EAAE,kBAAkB,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AAWzF,IAAM,YAAY,GAAG,EAAE,CAAC;AACxB,IAAM,uBAAuB,GAAG,GAAG,CAAC;AACpC,IAAM,uBAAuB,GAAG,GAAG,CAAC;AACpC,IAAM,mBAAmB,GAAG,GAAG,CAAC;AAChC,4EAA4E;AAC5E,IAAM,mBAAmB,GAAG,GAAG,CAAC;AAChC,IAAM,sBAAsB,GAAG,EAAE,CAAC;AAClC,IAAM,mBAAmB,GAAG,EAAE,CAAC;AAC/B,IAAM,+BAA+B,GAAG,CAAC,CAAC;AAC1C,IAAM,8BAA8B,GAAG,CAAC,CAAC;AACzC,IAAM,eAAe,GAAG,OAAO,CAAC;AAChC,IAAM,iBAAiB,GAAG,SAAS,CAAC;AAuBpC,IAAM,UAAU,GAAG;IACjB,GAAG,EAAE,CAAC,CAAC;IACP,MAAM,EAAE,CAAC,CAAC;IACV,IAAI,EAAE,CAAC,CAAC;IACR,KAAK,EAAE,CAAC,CAAC;IACT,KAAK,EAAE,CAAC;IACR,MAAM,EAAE,CAAC;CACV,CAAC;AAEF,+DAA+D;AAC/D,IAAM,gBAAgB,GAAG,UAAC,OAAoB,IAAK,OAAA,OAAO,CAAC,qBAAqB,EAAE,EAA/B,CAA+B,CAAC;AACnF,IAAM,mBAAmB,GAAG,gBAAgB,CAAC;AAC7C,IAAM,kBAAkB,GAAG,gBAAgB,CAAC;AAE5C;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH;IAAmC,wBAA6C;IAuD9E,cAAY,KAAoB;QAAhC,YACE,kBAAM,KAAK,CAAC,SA2Cb;QA1FO,WAAK,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;QAC1C,cAAQ,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;QAC7C,eAAS,GAA4B,EAAE,CAAC;QA8XxC,+BAAyB,GAAG,UAAC,SAAwB,EAAE,aAA4B;YACzF,IACE,SAAS,CAAC,KAAK,KAAK,KAAI,CAAC,KAAK,CAAC,KAAK;gBACpC,SAAS,CAAC,WAAW,KAAK,KAAI,CAAC,KAAK,CAAC,WAAW;gBAChD,SAAS,CAAC,UAAU,KAAK,KAAI,CAAC,KAAK,CAAC,UAAU;gBAC9C,SAAS,CAAC,OAAO,KAAK,KAAI,CAAC,KAAK,CAAC,OAAO;gBACxC,CAAC,aAAa,CAAC,UAAU,EACzB;gBACA,IAAI,CAAC,SAAS,EAAE,EAAE;oBAChB,OAAO,aAAa,CAAC;iBACtB;gBACD,sGAAsG;gBACtG,6EAA6E;gBAC7E,KAAI,CAAC,qBAAqB,EAAE,CAAC;gBAC7B,KAAI,CAAC,aAAa,GAAG,IAAI,CAAC;gBAE1B,KAAI,CAAC,eAAe,EAAE,CAAC;gBACvB,KAAI,CAAC,oBAAoB,EAAE,CAAC;gBAE5B,OAAO,KAAI,CAAC,YAAY,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;aACpD;YAED,OAAO,aAAa,CAAC;QACvB,CAAC,CAAC;QAwDM,mBAAa,GAAG,UAAC,KAAgC;YAC/C,IAAA,OAAO,GAA+B,KAAK,QAApC,EAAE,cAAc,GAAe,KAAK,eAApB,EAAE,QAAQ,GAAK,KAAK,SAAV,CAAW;YAEpD,OAAO,CACL,sCAAK,GAAG,EAAE,OAAO,IAAM,QAAQ,GAC5B,cAAc,CACX,CACP,CAAC;QACJ,CAAC,CAAC;QAEM,sBAAgB,GAAG,UAAC,KAAmC;YACrD,IAAA,UAAU,GAA6B,KAAK,WAAlC,EAAE,YAAY,GAAe,KAAK,aAApB,EAAE,QAAQ,GAAK,KAAK,SAAV,CAAW;YAErD,OAAO,CACL,sCAAK,GAAG,EAAE,UAAU,IAAM,QAAQ,GAC/B,YAAY,CACT,CACP,CAAC;QACJ,CAAC,CAAC;QAgBM,mBAAa,GAAG,UAAC,SAAwB,EAAE,aAA8C;;YACzF,IAAA,KAAkD,KAAI,CAAC,KAAK,EAA1D,YAAY,kBAAA,EAAE,uBAAuB,6BAAA,EAAE,IAAI,UAAe,CAAC;YAGjE,IAAA,KAEE,SAAS,KAFqB,EAAxB,aAAU,EAAV,KAAK,mBAAG,EAAE,KAAA,EAAE,UAAU,gBAAA,EAC3B,QAAQ,UACT,SAAS,EAHP,QAGL,CADY,CACC;YAEd,oDAAoD;YACpD,IAAM,QAAQ,GAAG,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,cAAc,CAAC;YAClE,IAAM,KAAK,GAAsB,EAAE,CAAC;YAEpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACrC,IAAM,KAAK,GAAG,UAAU,GAAG,CAAC,CAAC;gBAC7B,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAEtB,IAAI,OAAO,GAAG,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,IAAK,IAAY,CAAC,GAAG,CAAC;gBAE7F,IAAI,OAAO,KAAK,IAAI,IAAI,OAAO,KAAK,SAAS,EAAE;oBAC7C,OAAO,GAAG,KAAK,CAAC;iBACjB;gBAED,IAAM,UAAU,GAAG,uBAAuB,aAAvB,uBAAuB,cAAvB,uBAAuB,GAAI,YAAY,CAAC;gBAE3D,IAAM,IAAI,GACR,MAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAG,IAAI,EAAE,KAAK,EAAE,CAAC,KAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,SAAS,CAAC,mCAAI,IAAI,CAAC;gBAE3G,IAAI,CAAC,uBAAuB,IAAI,IAAI,EAAE;oBACpC,KAAK,CAAC,IAAI,CACR,6BACE,IAAI,EAAE,QAAQ,EACd,SAAS,EAAE,cAAc,EACzB,GAAG,EAAE,OAAO,qBACK,KAAK,uBACJ,UAAU,IAE3B,IAAI,CACD,CACP,CAAC;iBACH;aACF;YAED,OAAO,wCAAS,QAAQ,GAAG,KAAK,CAAO,CAAC;QAC1C,CAAC,CAAC;QA3eA,sBAAsB,CAAC,KAAI,CAAC,CAAC;QAE7B,KAAI,CAAC,KAAK,GAAG;YACX,KAAK,EAAE,EAAE;YACT,WAAW,EAAE,KAAK;YAClB,wBAAwB,EAAE,KAAI,CAAC,yBAAyB;YACxD,UAAU,EAAE,KAAK;SAClB,CAAC;QAEF,KAAI,CAAC,MAAM,GAAG,IAAI,KAAK,CAAC,KAAI,CAAC,CAAC;QAC9B,KAAI,CAAC,OAAO,GAAG,IAAI,UAAU,CAAC,KAAI,CAAC,CAAC;QACpC,KAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;QAC9B,KAAI,CAAC,eAAe,GAAG,CAAC,CAAC;QACzB,KAAI,CAAC,qBAAqB,GAAG,CAAC,CAAC;QAC/B,KAAI,CAAC,sBAAsB,GAAG,CAAC,CAAC;QAEhC,4CAA4C;QAC5C,KAAI,CAAC,eAAe,GAAG,CAAC,CAAC;QAEzB,wCAAwC;QACxC,KAAI,CAAC,cAAc,GAAG,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAI,CAAC,cAAc,EAAE,uBAAuB,EAAE;YACvF,OAAO,EAAE,KAAK;YACd,OAAO,EAAE,uBAAuB;SACjC,CAAC,CAAC;QAEH,KAAI,CAAC,YAAY,GAAG,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAI,CAAC,YAAY,EAAE,mBAAmB,EAAE;YAC/E,OAAO,EAAE,KAAK;SACf,CAAC,CAAC;QAEH,KAAI,CAAC,cAAc,GAAG,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAI,CAAC,cAAc,EAAE,YAAY,EAAE;YAC5E,OAAO,EAAE,KAAK;SACf,CAAC,CAAC;QAEH,KAAI,CAAC,gBAAgB,GAAG,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAI,CAAC,gBAAgB,EAAE,mBAAmB,EAAE;YACvF,OAAO,EAAE,KAAK;SACf,CAAC,CAAC;QAEH,KAAI,CAAC,kBAAkB,GAAG,EAAE,CAAC;QAC7B,KAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;QAC9B,KAAI,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC;QACxB,KAAI,CAAC,UAAU,GAAG,EAAE,CAAC;;IACvB,CAAC;IAnDa,6BAAwB,GAAtC,UACE,SAAwB,EACxB,aAA4B;QAE5B,OAAO,aAAa,CAAC,wBAAwB,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;IAC1E,CAAC;IAgDD,sBAAW,0BAAQ;aAAnB;YACE,OAAO,IAAI,CAAC,SAAS,CAAC;QACxB,CAAC;;;OAAA;IAED;;;;;;;;;;OAUG;IACI,4BAAa,GAApB,UACE,KAAa,EACb,WAA2C,EAC3C,YAA8C;QAA9C,6BAAA,EAAA,eAA6B,YAAY,CAAC,IAAI;QAE9C,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAoB,CAAC;QACnD,IAAM,WAAW,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QAC3C,IAAM,QAAQ,GAAG,UAAU,GAAG,WAAW,CAAC;QAE1C,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QAEtC,IAAI,SAAS,GAAG,CAAC,CAAC;QAElB,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,KAAK,IAAI,SAAS,GAAG,UAAU,EAAE,SAAS,GAAG,QAAQ,EAAE,SAAS,IAAI,YAAY,EAAE;YAChF,IAAM,iBAAiB,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;YAEzF,IAAM,UAAU,GAAG,iBAAiB,CAAC,MAAM,CAAC;YAC5C,YAAY,GAAG,iBAAiB,CAAC,SAAS,CAAC;YAE3C,IAAM,sBAAsB,GAAG,SAAS,IAAI,KAAK,IAAI,SAAS,GAAG,YAAY,GAAG,KAAK,CAAC;YACtF,IAAI,sBAAsB,EAAE;gBAC1B,6GAA6G;gBAC7G,qEAAqE;gBACrE,IAAI,WAAW,IAAI,IAAI,CAAC,cAAc,EAAE;oBACtC,IAAM,UAAU,GAAG,kBAAkB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBAC3D,IAAM,cAAc,GAAG,kBAAkB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;oBAC/D,IAAM,YAAY,GAAG;wBACnB,GAAG,EAAE,cAAc;wBACnB,MAAM,EAAE,cAAc,GAAG,UAAU,CAAC,MAAM;qBAC3C,CAAC;oBAEF,8CAA8C;oBAC9C,IAAM,sBAAsB,GAAG,KAAK,GAAG,SAAS,CAAC;oBACjD,KAAK,IAAI,eAAe,GAAG,CAAC,EAAE,eAAe,GAAG,sBAAsB,EAAE,EAAE,eAAe,EAAE;wBACzF,SAAS,IAAI,WAAW,CAAC,SAAS,GAAG,eAAe,CAAC,CAAC;qBACvD;oBACD,IAAM,YAAY,GAAG,SAAS,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC;oBAEpD,yEAAyE;oBACzE,wDAAwD;oBACxD,QAAQ,YAAY,EAAE;wBACpB,KAAK,YAAY,CAAC,GAAG;4BACnB,kBAAkB,CAAC,IAAI,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;4BACnD,OAAO;wBACT,KAAK,YAAY,CAAC,MAAM;4BACtB,kBAAkB,CAAC,IAAI,CAAC,cAAc,EAAE,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;4BAC1E,OAAO;wBACT,KAAK,YAAY,CAAC,MAAM;4BACtB,kBAAkB,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,SAAS,GAAG,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;4BAC5F,OAAO;wBACT,KAAK,YAAY,CAAC,IAAI,CAAC;wBACvB;4BACE,MAAM;qBACT;oBAED,IAAM,kBAAkB,GAAG,SAAS,IAAI,YAAY,CAAC,GAAG,IAAI,YAAY,IAAI,YAAY,CAAC,MAAM,CAAC;oBAChG,IAAI,kBAAkB,EAAE;wBACtB,uCAAuC;wBACvC,OAAO;qBACR;oBAED,IAAM,oBAAoB,GAAG,SAAS,GAAG,YAAY,CAAC,GAAG,CAAC;oBAC1D,IAAM,oBAAoB,GAAG,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC;oBAEhE,IAAI,oBAAoB,EAAE;wBACxB,sCAAsC;wBACtC,0BAA0B;wBAC1B,YAAY;wBACZ,iCAAiC;wBACjC,cAAc;wBACd,cAAc;wBACd,cAAc;qBACf;yBAAM,IAAI,oBAAoB,EAAE;wBAC/B,0DAA0D;wBAC1D,wBAAwB;wBACxB,WAAW;wBACX,aAAa;wBACb,mCAAmC;wBACnC,aAAa;wBACb,4BAA4B;wBAC5B,SAAS,GAAG,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC;qBAC9C;iBACF;gBAED,IAAI,IAAI,CAAC,cAAc,EAAE;oBACvB,kBAAkB,CAAC,IAAI,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;iBACpD;gBACD,OAAO;aACR;YAED,SAAS,IAAI,UAAU,CAAC;SACzB;IACH,CAAC;IAEM,sCAAuB,GAA9B,UAA+B,WAA2C;QACxE,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,EAAE,CAAC;QACrC,KAAmB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;YAArB,IAAM,IAAI,cAAA;YACb,IAAM,aAAa,GACjB,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3G,IAAI,aAAa,EAAE;gBACjB,IAAI,CAAC,WAAW,EAAE;oBAChB,IAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;oBAC3D,OAAO,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC;iBAC/E;qBAAM;oBACL,IAAI,cAAc,GAAG,CAAC,CAAC;oBACvB,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,EAAE,SAAS,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,SAAS,EAAE,EAAE;wBAC/F,IAAM,SAAS,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;wBACzC,IACE,IAAI,CAAC,GAAG,GAAG,cAAc,IAAI,IAAI,CAAC,UAAU;4BAC5C,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,GAAG,cAAc,GAAG,SAAS,EACvD;4BACA,OAAO,SAAS,CAAC;yBAClB;6BAAM;4BACL,cAAc,IAAI,SAAS,CAAC;yBAC7B;qBACF;iBACF;aACF;SACF;QACD,OAAO,CAAC,CAAC;IACX,CAAC;IAEM,gCAAiB,GAAxB;QACE,IAAI,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;QACpC,IAAI,CAAC,cAAc,GAAG,oBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAgB,CAAC;QAC9E,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;QAEpB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE;YAC7B,IAAM,cAAc,GAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAM,CAAC,CAAC;YACvE,IAAI,cAAc,EAAE;gBAClB,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;gBAC9B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;aAC1D;SACF;QAED,IAAI,CAAC,eAAe,EAAE,CAAC;QAEvB,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QACvD,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YACtB,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SACnE;QACD,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YAC/D,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,cAAc,EAAE,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;SACrE;IACH,CAAC;IAEM,iCAAkB,GAAzB,UAA0B,aAAyB,EAAE,aAA4B;QAC/E,mFAAmF;QACnF,uGAAuG;QACvG,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC;QAC9B,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC;QAE9B,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,KAAK,aAAa,CAAC,YAAY,EAAE;YAC1D,iEAAiE;YACjE,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE;gBAC7B,6DAA6D;gBAC7D,IAAM,cAAc,GAAG,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,KAAM,CAAC,CAAC;gBAEvE,IAAI,cAAc,EAAE;oBAClB,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;oBAC9B,IAAI,CAAC,cAAc,EAAE,CAAC;iBACvB;qBAAM;oBACL,wBAAwB;oBACxB,IAAI,CAAC,YAAY,EAAE,CAAC;iBACrB;aACF;iBAAM;gBACL,uBAAuB;gBACvB,IAAI,CAAC,YAAY,EAAE,CAAC;aACrB;YAED,+DAA+D;YAC/D,IAAI,UAAU,CAAC,cAAc,EAAE;gBAC7B,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,KAAmB,CAAC,CAAC;aAC3D;SACF;IACH,CAAC;IAEM,mCAAoB,GAA3B;QACE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;QACtB,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAEvB,OAAO,IAAI,CAAC,cAAc,CAAC;IAC7B,CAAC;IAEM,oCAAqB,GAA5B,UAA6B,QAAuB,EAAE,QAAuB;QACnE,IAAO,QAAQ,GAAK,IAAI,CAAC,KAAK,MAAf,CAAgB;QAC/B,IAAO,QAAQ,GAAK,QAAQ,MAAb,CAAc;QACrC,IAAI,qBAAqB,GAAG,KAAK,CAAC;QAElC,qCAAqC;QACrC,IAAI,CAAC,QAAQ,CAAC,WAAW,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;YACnD,OAAO,IAAI,CAAC;SACb;QAED,IAAI,QAAQ,CAAC,OAAO,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YAC3C,OAAO,IAAI,CAAC;SACb;QAED,IAAI,QAAQ,CAAC,SAAS,KAAK,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;YAC/C,OAAO,IAAI,CAAC;SACb;QAED,IAAI,QAAQ,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,QAAS,CAAC,MAAM,KAAK,QAAS,CAAC,MAAM,EAAE;YAChF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACzC,IAAM,OAAO,GAAG,QAAS,CAAC,CAAC,CAAC,CAAC;gBAC7B,IAAM,OAAO,GAAG,QAAS,CAAC,CAAC,CAAC,CAAC;gBAE7B,IAAI,OAAO,CAAC,GAAG,KAAK,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,EAAE;oBAC1E,qBAAqB,GAAG,IAAI,CAAC;oBAC7B,MAAM;iBACP;aACF;SACF;aAAM;YACL,qBAAqB,GAAG,IAAI,CAAC;SAC9B;QAED,OAAO,qBAAqB,CAAC;IAC/B,CAAC;IAEM,0BAAW,GAAlB;QACE,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,sFAAsF;QACtF,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACtD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACzD,IAAI,CAAC,eAAe,EAAE,CAAC;QAEvB,iBAAM,WAAW,WAAE,CAAC;IACtB,CAAC;IAED;;OAEG;IACI,iCAAkB,GAAzB;QACE,OAAO,IAAI,CAAC,YAAa,CAAC,MAAM,CAAC;IACnC,CAAC;IAEM,qBAAM,GAAb;QACQ,IAAA,KAA8D,IAAI,CAAC,KAAK,EAAtE,SAAS,eAAA,EAAE,YAAa,EAAb,IAAI,mBAAG,MAAM,KAAA,EAAE,eAAe,qBAAA,EAAE,YAAY,kBAAe,CAAC;QACvE,IAAA,KAAe,IAAI,CAAC,KAAK,MAAf,EAAV,KAAK,mBAAG,EAAE,KAAA,CAAgB;QAClC,IAAM,YAAY,GAAkB,EAAE,CAAC;QACvC,IAAM,QAAQ,GAAG,cAAc,CAAuC,IAAI,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;QAEjG,KAAmB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;YAArB,IAAM,IAAI,cAAA;YACb,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;SAC3C;QAED,IAAM,oBAAoB,GAAG,eAAe;YAC1C,CAAC,CAAC,qBAAqB,CAAC,eAAe,EAAE,IAAI,CAAC,gBAAgB,CAAC;YAC/D,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC;QAE1B,IAAM,iBAAiB,GAAG,YAAY;YACpC,CAAC,CAAC,qBAAqB,CAAC,YAAY,EAAE,IAAI,CAAC,aAAa,CAAC;YACzD,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC;QAEvB,OAAO,iBAAiB,CAAC;YACvB,OAAO,EAAE,IAAI,CAAC,KAAK;YACnB,KAAK,OAAA;YACL,cAAc,EAAE,oBAAoB,CAAC;gBACnC,UAAU,EAAE,IAAI,CAAC,QAAQ;gBACzB,KAAK,OAAA;gBACL,YAAY,cAAA;gBACZ,QAAQ,EAAE;oBACR,IAAI,EAAE,cAAc;oBACpB,SAAS,EAAE,iBAAiB;iBAC7B;aACF,CAAC;YACF,QAAQ,wBACH,QAAQ,KACX,SAAS,EAAE,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,EACpC,IAAI,EAAE,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,EAChD,YAAY,EAAE,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,SAAS,GAC3E;SACF,CAAC,CAAC;IACL,CAAC;IA2BO,gCAAiB,GAAzB,UAA0B,KAAiC;QAAjC,sBAAA,EAAA,QAAuB,IAAI,CAAC,KAAK;QACjD,IAAA,kBAAkB,GAAK,KAAK,mBAAV,CAAW;QACrC,OAAO,CAAC,kBAAkB,IAAI,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAC1D,CAAC;IAED;;OAEG;IACK,mCAAoB,GAA5B;QACE,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;IACvB,CAAC;IAEO,0BAAW,GAAnB,UAAoB,IAAc;QAAlC,iBAwCC;QAvCS,IAAA,YAAY,GAAK,IAAI,CAAC,KAAK,aAAf,CAAgB;QACpC,IAAI,UAAU,CAAC;QACf,uFAAuF;QACvF,IAAI,YAAY,EAAE;YAChB,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACvC,IAAI,UAAU,IAAI,UAAU,CAAC,WAAW,EAAE;gBACxC,OAAO,UAAU,CAAC,WAAW,CAAC;aAC/B;SACF;QAED,IAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAEnC,IAAA,KAAsC,IAAI,CAAC,KAAK,aAAf,EAAjC,YAAY,mBAAG,IAAI,CAAC,aAAa,KAAA,CAAgB;QAEzD,IAAM,WAAW,GAAG,YAAY,CAC9B;YACE,IAAI,MAAA;YACJ,SAAS,EAAE,cAAc;YACzB,GAAG,EAAE,IAAI,CAAC,GAAG;YACb,GAAG,EAAE,UAAC,MAAe;gBACnB,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC;YACpC,CAAC;YACD,KAAK,EAAE,SAAS;YAChB,IAAI,EAAE,cAAc;SACrB,EACD,IAAI,CAAC,aAAa,CACnB,CAAC;QAEF,kFAAkF;QAClF,gGAAgG;QAChG,wGAAwG;QACxG,8FAA8F;QAC9F,IAAI,YAAY,IAAI,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE;YACzC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;gBAC1B,IAAI,MAAA;gBACJ,WAAW,aAAA;aACZ,CAAC;SACH;QACD,OAAO,WAAW,CAAC;IACrB,CAAC;IAsBD,8CAA8C;IACtC,4BAAa,GAArB,UAAsB,IAAc;QAC1B,IAAA,YAAY,GAAK,IAAI,CAAC,KAAK,aAAf,CAAgB;QAEpC,6BACK,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GACxC,CAAC,CAAC,IAAI,CAAC,KAAK;YACb,CAAC,CAAC;gBACE,MAAM,EAAE,IAAI,CAAC,MAAM;aACpB;YACH,CAAC,CAAC,EAAE,CAAC,EACP;IACJ,CAAC;IA+CD,+EAA+E;IACvE,uBAAQ,GAAhB,UAAiB,EAAO;QACtB,IAAI,MAAM,GAAG,EAAE,CAAC,MAAqB,CAAC;QAEtC,OAAO,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;YACvC,IAAM,WAAW,GAAG,MAAM,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAC;YAE3D,IAAI,WAAW,EAAE;gBACf,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;gBACzC,MAAM;aACP;YAED,MAAM,GAAG,SAAS,CAAC,MAAM,CAAgB,CAAC;SAC3C;IACH,CAAC;IAED;;;OAGG;IACK,wBAAS,GAAjB;QACE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE;YAC/D,IAAI,CAAC,QAAQ,CAAC,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC;SACtC;QACD,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC7B,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC1B,CAAC;IAEO,oCAAqB,GAA7B;QACE,IAAI,CAAC,qBAAqB,GAAG,CAAC,CAAC;QAC/B,IAAI,CAAC,sBAAsB,GAAG,CAAC,CAAC;IAClC,CAAC;IAED;;OAEG;IACK,6BAAc,GAAtB;QACE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAEhD,kFAAkF;QAClF,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,aAA2B,EAAE,IAAI,CAAC,iBAAiB,CAAC,EAAE;YAC5G,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SAC1D;aAAM;YACL,qGAAqG;SACtG;IACH,CAAC;IAED;;;OAGG;IACK,2BAAY,GAApB;QACQ,IAAA,KAAkD,IAAI,CAAC,KAAK,EAA1D,oBAAoB,0BAAA,EAAE,qBAAqB,2BAAe,CAAC;QAC7D,IAAA,KAAiG,IAAI,EAA5E,oBAAoB,2BAAA,EAA0B,qBAAqB,4BAAS,CAAC;QAC5G,IAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,oBAA8B,EAAE,oBAAoB,GAAG,CAAC,CAAC,CAAC;QACxF,IAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,qBAA+B,EAAE,qBAAqB,GAAG,CAAC,CAAC,CAAC;QAE3F,IAAI,YAAY,KAAK,oBAAoB,IAAI,aAAa,KAAK,qBAAqB,EAAE;YACpF,sDAAsD;YAEtD,IAAI,CAAC,qBAAqB,GAAG,YAAY,CAAC;YAC1C,IAAI,CAAC,sBAAsB,GAAG,aAAa,CAAC;YAC5C,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YAChD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SAC1D;QAED,IAAI,oBAAqB,GAAG,YAAY,IAAI,qBAAsB,GAAG,aAAa,EAAE;YAClF,gCAAgC;YAChC,IAAI,CAAC,YAAY,EAAE,CAAC;SACrB;IACH,CAAC;IAED;;;OAGG;IACK,+BAAgB,GAAxB;QACE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE;YACpC,IAAI,CAAC,QAAQ,CAAC,EAAE,WAAW,EAAE,KAAK,EAAE,CAAC,CAAC;SACvC;IACH,CAAC;IAEO,6BAAc,GAAtB;QACE,IAAI,CAAC,WAAW,EAAE,CAAC;IACrB,CAAC;IAEO,2BAAY,GAApB,UAAqB,SAAwB,EAAE,aAA4B;QACzE,iCAAiC;QAEjC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,IAAI,CAAC,kBAAkB,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;SACnD;QAED,IAAM,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;QAChE,IAAM,YAAY,GAAG,aAAa,CAAC,KAAM,CAAC;QAE1C,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,YAAY,CAAC,KAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAEvE,sCACK,aAAa,GACb,YAAY,KACf,YAAY,EAAE,EAAE,IAChB;IACJ,CAAC;IAED;;;;;OAKG;IACK,iCAAkB,GAA1B,UAA2B,QAAoB,EAAE,QAAoB,EAAE,KAAoB;QACjF,IAAA,WAAW,GAAoB,KAAK,YAAzB,EAAE,aAAa,GAAK,KAAK,cAAV,CAAW;QAE7C,IAAI,WAAW,IAAI,aAAa,EAAE;YAChC,IAAM,eAAe,GAEjB,EAAE,CAAC;YAEP,KAAmB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;gBAAxB,IAAM,IAAI,iBAAA;gBACb,IAAI,IAAI,CAAC,KAAK,EAAE;oBACd,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;iBACzC;aACF;YAED,KAAmB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;gBAAxB,IAAM,IAAI,iBAAA;gBACb,IAAI,IAAI,CAAC,KAAK,EAAE;oBACd,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;wBACrC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;qBACzB;yBAAM;wBACL,OAAO,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;qBACzC;iBACF;aACF;YAED,KAAK,IAAM,KAAK,IAAI,eAAe,EAAE;gBACnC,IAAI,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;oBACzC,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;iBAC7C;aACF;SACF;IACH,CAAC;IAEO,sCAAuB,GAA/B,UAAgC,KAAiB;QAC/C,IAAI,aAAa,GAAG,KAAK,CAAC;QAE1B,gFAAgF;QAChF,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,EAAE;YAC7B,OAAO,aAAa,CAAC;SACtB;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAEtB,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC;aAC1D;SACF;QAED,OAAO,aAAa,CAAC;IACvB,CAAC;IAED;;;OAGG;IACK,2BAAY,GAApB,UAAqB,IAAc;QACjC,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAC7B,IAAM,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAgB,CAAC;QAC5D,IAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAE9D,sEAAsE;QAEtE,IACE,WAAW;YACX,IAAI,CAAC,iBAAiB,EAAE;YACxB,CAAC,CAAC,YAAY,IAAI,YAAY,CAAC,cAAc,KAAK,IAAI,CAAC,eAAe,CAAC,EACvE;YACA,IAAM,aAAa,GAAG;gBACpB,KAAK,EAAE,WAAW,CAAC,WAAW;gBAC9B,MAAM,EAAE,WAAW,CAAC,YAAY;aACjC,CAAC;YAEF,IAAI,aAAa,CAAC,MAAM,IAAI,aAAa,CAAC,KAAK,EAAE;gBAC/C,gBAAgB,GAAG,IAAI,CAAC,MAAM,KAAK,aAAa,CAAC,MAAM,CAAC;gBAExD,mGAAmG;gBAEnG,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC;gBAEnC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG;oBACzC,MAAM,EAAE,aAAa,CAAC,MAAM;oBAC5B,cAAc,EAAE,IAAI,CAAC,eAAe;iBACrC,CAAC;gBAEF,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,KAAK,CACpC,CAAC,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,eAAe,GAAG,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,CACvG,CAAC;gBAEF,IAAI,CAAC,eAAe,EAAE,CAAC;aACxB;SACF;QAED,OAAO,gBAAgB,CAAC;IAC1B,CAAC;IAED,oDAAoD;IAC5C,2BAAY,GAApB,UAAqB,IAAc;QACzB,IAAA,WAAW,GAAK,IAAI,CAAC,KAAK,YAAf,CAAgB;QAEnC,iGAAiG;QAEjG,IAAI,WAAW,EAAE;YACf,WAAW,CAAC,IAAI,CAAC,CAAC;SACnB;IACH,CAAC;IAED,wDAAwD;IAChD,6BAAc,GAAtB,UAAuB,IAAc;QAC3B,IAAA,aAAa,GAAK,IAAI,CAAC,KAAK,cAAf,CAAgB;QAErC,yGAAyG;QAEzG,IAAI,aAAa,EAAE;YACjB,aAAa,CAAC,IAAI,CAAC,CAAC;SACrB;IACH,CAAC;IAED,kDAAkD;IAC1C,0BAAW,GAAnB,UAAoB,KAAoB,EAAE,KAAoB;QACtD,IAAA,WAAW,GAAK,KAAK,YAAV,CAAW;QACpB,IAAA,KAAK,GAAgC,KAAK,MAArC,EAAE,UAAU,GAAoB,KAAK,WAAzB,EAAE,aAAa,GAAK,KAAK,cAAV,CAAW;QAEnD,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QAE1C,IAAM,gBAAgB,gBAAQ,UAAU,CAAE,CAAC;QAC3C,IAAM,KAAK,GAAe,EAAE,CAAC;QAE7B,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,aAAa,GAAG,IAAI,CAAC;QACzB,IAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,IAAM,QAAQ,GAAG,UAAW,GAAG,WAAW,CAAC;QAC3C,IAAM,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;QAEvD,2GAA2G;QAC3G,wFAAwF;QACxF,kGAAkG;QAClG,IAAM,aAAa,GAAG,IAAI,CAAC,oBAAoB,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC;QAExE,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;gCAE7B,SAAS;YAChB,IAAM,iBAAiB,GAAG,OAAK,qBAAqB,CAAC,KAAK,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;YACpF,IAAM,UAAU,GAAG,iBAAiB,CAAC,MAAM,CAAC;YAC5C,IAAM,QAAQ,GAAG,iBAAiB,CAAC,IAAI,CAAC;YACxC,IAAM,GAAG,GAAG,iBAAiB,CAAC,GAAG,CAAC;YAElC,YAAY,GAAG,iBAAiB,CAAC,SAAS,CAAC;YAE3C,IAAM,UAAU,GAAG,OAAO,GAAG,UAAU,GAAG,CAAC,CAAC;YAE5C,IAAM,cAAc,GAClB,SAAS,CAAC,KAAK,CAAC,KAAmB,EAAE,UAAC,IAAc,IAAK,OAAA,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAA7C,CAA6C,CAAC,GAAG,CAAC,CAAC,CAAC;YAC/G,IAAM,oBAAoB,GAAG,CAAC,WAAW,IAAI,CAAC,UAAU,IAAI,WAAW,CAAC,GAAG,IAAI,OAAO,IAAI,WAAW,CAAC,MAAO,CAAC,CAAC;YAC/G,IAAM,qBAAqB,GACzB,CAAC,OAAK,aAAa,IAAI,CAAC,UAAU,IAAI,OAAK,aAAa,CAAC,GAAG,IAAI,OAAO,IAAI,OAAK,aAAa,CAAC,MAAO,CAAC,CAAC;YACzG,IAAM,aAAa,GACjB,CAAC,CAAC,aAAa,IAAI,CAAC,qBAAqB,IAAI,CAAC,oBAAoB,IAAI,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC;YAC/G,IAAM,aAAa,GAAG,YAAY,IAAI,SAAS,IAAI,YAAY,GAAG,SAAS,GAAG,YAAY,CAAC;YAC3F,IAAM,WAAW,GAAG,SAAS,KAAK,UAAU,CAAC;YAE7C,iFAAiF;YACjF,iEAAiE;YAEjE,qDAAqD;YACrD,yGAAyG;YACzG,IAAI,aAAa,IAAI,aAAa,IAAI,WAAW,EAAE;gBACjD,IAAI,aAAa,EAAE;oBACjB,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;oBAC1B,aAAa,GAAG,IAAI,CAAC;iBACtB;gBAED,IAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,QAAQ,GAAG,SAAS,CAAC,CAAC;gBACjE,IAAM,OAAO,GAAG,OAAK,WAAW,CAC9B,GAAG,EACH,KAAM,CAAC,KAAK,CAAC,SAAS,EAAE,SAAS,GAAG,WAAW,CAAC,EAChD,SAAS,EACT,SAAS,EACT,SAAS,EACT,QAAQ,CACT,CAAC;gBAEF,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC;gBACtB,OAAO,CAAC,MAAM,GAAG,UAAU,CAAC;gBAC5B,IAAI,OAAK,YAAY,IAAI,OAAK,YAAY,CAAC,MAAM,EAAE;oBACjD,OAAO,CAAC,SAAS,GAAG,UAAU,IAAI,OAAK,YAAY,CAAC,GAAG,IAAI,OAAO,IAAI,OAAK,YAAY,CAAC,MAAM,CAAC;iBAChG;gBAED,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAEpB,IAAI,qBAAqB,IAAI,OAAK,YAAY,EAAE;oBAC9C,UAAU,CAAC,gBAAgB,EAAE;wBAC3B,GAAG,EAAE,OAAO;wBACZ,MAAM,EAAE,UAAU;wBAClB,MAAM,EAAE,UAAU;wBAClB,IAAI,EAAE,WAAW,CAAC,IAAI;wBACtB,KAAK,EAAE,WAAW,CAAC,KAAK;wBACxB,KAAK,EAAE,WAAW,CAAC,KAAK;qBACzB,CAAC,CAAC;iBACJ;aACF;iBAAM;gBACL,IAAI,CAAC,aAAa,EAAE;oBAClB,aAAa,GAAG,OAAK,WAAW,CAC9B,iBAAiB,GAAG,SAAS,EAC7B,SAAS,EACT,SAAS,EACT,CAAC,EACD,SAAS,EACT,QAAQ,EACR,IAAI,CAAC,YAAY,CAClB,CAAC;iBACH;gBACD,aAAa,CAAC,MAAM,GAAG,CAAC,aAAa,CAAC,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;gBAChF,aAAa,CAAC,SAAS,IAAI,YAAY,CAAC;aACzC;YACD,OAAO,IAAI,UAAU,GAAG,OAAO,GAAG,CAAC,CAAC;YAEpC,mFAAmF;YACnF,4EAA4E;YAC5E,IAAI,aAAa,IAAI,gBAAgB,EAAE;;aAEtC;;;QAhFH,KAAK,IAAI,SAAS,GAAG,UAAW,EAAE,SAAS,GAAG,QAAQ,EAAE,SAAS,IAAI,YAAY;kCAAxE,SAAS;;;SAiFjB;QAED,IAAI,aAAa,EAAE;YACjB,aAAa,CAAC,GAAG,GAAG,iBAAiB,GAAG,KAAK,CAAC;YAC9C,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SAC3B;QAED,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,CAAC;QAE1C,mDAAmD;QACnD,6BACK,KAAK,KACR,KAAK,OAAA,EACL,cAAc,EAAE,IAAI,CAAC,eAAe,IACpC;IACJ,CAAC;IAEO,oCAAqB,GAA7B,UACE,KAAiB,EACjB,SAAiB,EACjB,WAAuB;QAQf,IAAA,oBAAoB,GAAK,KAAK,qBAAV,CAAW;QAEvC,IAAI,oBAAoB,EAAE;YACxB,IAAM,QAAQ,GAAG,oBAAoB,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;YAEtD,IAAA,KAAkE,QAAQ,UAAb,EAA7D,SAAS,mBAAG,IAAI,CAAC,oBAAoB,CAAC,SAAS,EAAE,WAAW,CAAC,KAAA,CAAc;YAE3E,IAAA,KAAoE,QAAQ,OAAb,EAA/D,MAAM,mBAAG,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,EAAE,SAAS,CAAC,KAAA,CAAc;YAErF,OAAO;gBACL,SAAS,WAAA;gBACT,MAAM,QAAA;gBACN,IAAI,EAAE,QAAQ,CAAC,IAAI;gBACnB,GAAG,EAAE,QAAQ,CAAC,GAAG;aAClB,CAAC;SACH;aAAM;YACL,IAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;YAEpE,OAAO;gBACL,SAAS,WAAA;gBACT,MAAM,EAAE,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,EAAE,SAAS,CAAC;aAC/D,CAAC;SACH;IACH,CAAC;IAED;;;OAGG;IACK,6BAAc,GAAtB,UAAuB,SAAiB,EAAE,WAAuB,EAAE,YAAoB;QACrF,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE;YAC5B,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;SACvE;aAAM;YACL,IAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;YAExD,OAAO,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,IAAI,mBAAmB,CAAC;SAC9F;IACH,CAAC;IAEO,mCAAoB,GAA5B,UAA6B,SAAiB,EAAE,YAAwB;QACtE,IAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,mBAAmB;YACjD,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,SAAS,EAAE,YAAY,CAAC;YACzD,CAAC,CAAC,sBAAsB,CAAC;QAE3B,OAAO,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,sBAAsB,CAAC;IAC9D,CAAC;IAEO,0BAAW,GAAnB,UACE,OAA2B,EAC3B,KAAwB,EACxB,UAAuB,EACvB,KAAwC,EACxC,KAA+B,EAC/B,IAAU,EACV,QAAkB;QAJlB,2BAAA,EAAA,cAAsB,CAAC;QACvB,sBAAA,EAAA,QAAgB,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACxC,sBAAA,EAAA,UAA+B;QAI/B,OAAO,GAAG,OAAO,IAAI,eAAe,GAAG,UAAU,CAAC;QAClD,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAC5C,IAAI,UAAU,IAAI,UAAU,CAAC,IAAI,EAAE;YACjC,OAAO,UAAU,CAAC,IAAI,CAAC;SACxB;QAED,OAAO;YACL,GAAG,EAAE,OAAO;YACZ,UAAU,YAAA;YACV,SAAS,EAAE,KAAK;YAChB,KAAK,OAAA;YACL,KAAK,OAAA;YACL,GAAG,EAAE,CAAC;YACN,MAAM,EAAE,CAAC;YACT,IAAI,MAAA;YACJ,QAAQ,EAAE,QAAQ,IAAI,KAAK;SAC5B,CAAC;IACJ,CAAC;IAEO,8BAAe,GAAvB,UAAwB,KAAqB;QACrC,IAAA,KAAqC,KAAK,IAAI,IAAI,CAAC,KAAK,EAAtD,KAAK,WAAA,EAAE,UAAU,gBAAA,EAAE,WAAW,iBAAwB,CAAC;QAE/D,OAAO,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,UAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;IAC5F,CAAC;IAED,uGAAuG;IAC/F,iCAAkB,GAA1B,UAA2B,KAAoB,EAAE,KAAoB,EAAE,WAAqB;QAClF,IAAA,oBAAoB,GAA4B,KAAK,qBAAjC,EAAE,qBAAqB,GAAK,KAAK,sBAAV,CAAW;QACtD,IAAA,KAAK,GAAK,KAAK,MAAV,CAAW;QACxB,uGAAuG;QACvG,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE;YAClC,OAAO;SACR;QAED,IAAI,WAAW,GAAG,IAAI,CAAC,YAAY,iBAAS,UAAU,CAAE,CAAC;QACzD,IAAM,YAAY,GAAG,eAAe,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC1D,IAAM,SAAS,GAAG,kBAAkB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAE1D,mFAAmF;QACnF,0EAA0E;QAC1E,qGAAqG;QACrG,IACE,IAAI,CAAC,QAAQ,CAAC,OAAO;YACrB,CAAC,WAAW;gBACV,CAAC,KAAK;gBACN,CAAC,IAAI,CAAC,YAAY;gBAClB,CAAC,YAAY;gBACb,YAAY,KAAK,IAAI,CAAC,aAAa;gBACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC,GAAG,IAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC,EACxE;YACA,WAAW,GAAG,IAAI,CAAC,YAAY,GAAG,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YAC7E,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;SAC7B;QAED,kFAAkF;QAClF,gEAAgE;QAChE,IAAI,WAAW,IAAI,CAAC,YAAY,IAAI,YAAY,KAAK,IAAI,CAAC,aAAa,EAAE;YACvE,IAAI,CAAC,eAAe,EAAE,CAAC;SACxB;QAED,IAAI,CAAC,aAAa,GAAG,YAAY,IAAI,CAAC,CAAC;QAEvC,uGAAuG;QACvG,4BAA4B;QAC5B,qGAAqG;QACrG,iDAAiD;QACjD,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QACjD,IAAM,GAAG,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAC1C,IAAM,WAAW,GAAG;YAClB,GAAG,EAAE,UAAU;YACf,IAAI,EAAE,WAAW,CAAC,IAAI;YACtB,MAAM,EAAE,UAAU,GAAG,GAAI,CAAC,WAAW;YACrC,KAAK,EAAE,WAAW,CAAC,KAAK;YACxB,KAAK,EAAE,WAAW,CAAC,KAAK;YACxB,MAAM,EAAE,GAAI,CAAC,WAAW;SACzB,CAAC;QAEF,wEAAwE;QACxE,IAAI,CAAC,aAAa,GAAG,WAAW,CAAC,WAAW,EAAE,IAAI,CAAC,sBAAsB,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC;QACvG,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC,WAAW,EAAE,qBAAsB,EAAE,oBAAqB,CAAC,CAAC;QAE5F,wCAAwC;QACxC,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;IAClC,CAAC;IA1hCa,iBAAY,GAAG;QAC3B,UAAU,EAAE,CAAC;QACb,YAAY,EAAE,UAAC,IAAS,EAAE,KAAa,EAAE,aAAsB,IAAK,OAAA,0CAAG,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAI,EAAhC,CAAgC;QACpG,uBAAuB,EAAE,SAAS;QAClC,oBAAoB,EAAE,8BAA8B;QACpD,qBAAqB,EAAE,+BAA+B;KACvD,CAAC;IAqhCJ,WAAC;CAAA,AA5hCD,CAAmC,KAAK,CAAC,SAAS,GA4hCjD;SA5hCY,IAAI;AA8hCjB,SAAS,WAAW,CAAC,IAAgB,EAAE,WAAmB,EAAE,UAAkB;IAC5E,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC;IACjD,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,WAAW,GAAG,UAAU,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;IAEtE,OAAO;QACL,GAAG,KAAA;QACH,MAAM,EAAE,GAAG,GAAG,MAAM;QACpB,MAAM,QAAA;QACN,IAAI,EAAE,IAAI,CAAC,IAAI;QACf,KAAK,EAAE,IAAI,CAAC,KAAK;QACjB,KAAK,EAAE,IAAI,CAAC,KAAK;KAClB,CAAC;AACJ,CAAC;AAED,SAAS,kBAAkB,CAAC,SAAqB,EAAE,SAAqB;IACtE,OAAO,CACL,SAAS,CAAC,GAAG,IAAI,SAAS,CAAC,GAAG;QAC9B,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI;QAChC,SAAS,CAAC,MAAO,IAAI,SAAS,CAAC,MAAO;QACtC,SAAS,CAAC,KAAM,IAAI,SAAS,CAAC,KAAM,CACrC,CAAC;AACJ,CAAC;AAED,SAAS,UAAU,CAAC,UAAsB,EAAE,OAAmB;IAC7D,UAAU,CAAC,GAAG,GAAG,OAAO,CAAC,GAAG,GAAG,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC;IACtG,UAAU,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC;IAC5G,UAAU,CAAC,MAAM;QACf,OAAO,CAAC,MAAO,GAAG,UAAU,CAAC,MAAO,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC;IACxG,UAAU,CAAC,KAAK,GAAG,OAAO,CAAC,KAAM,GAAG,UAAU,CAAC,KAAM,IAAI,UAAU,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC;IACpH,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAM,GAAG,UAAU,CAAC,IAAI,GAAG,CAAC,CAAC;IAC3D,UAAU,CAAC,MAAM,GAAG,UAAU,CAAC,MAAO,GAAG,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC;IAE5D,OAAO,UAAU,CAAC;AACpB,CAAC","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  canUseDOM,\n  css,\n  divProperties,\n  findIndex,\n  findScrollableParent,\n  getNativeProps,\n  getParent,\n  getWindow,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { ScrollToMode } from './List.types';\nimport { composeRenderFunction } from '../../Utilities';\nimport { getScrollHeight, getScrollYPosition, setScrollYPosition } from './utils/scroll';\nimport type { IRectangle, IRenderFunction } from '../../Utilities';\nimport type {\n  IList,\n  IListProps,\n  IPage,\n  IPageProps,\n  IListOnRenderSurfaceProps,\n  IListOnRenderRootProps,\n} from './List.types';\n\nconst RESIZE_DELAY = 16;\nconst MIN_SCROLL_UPDATE_DELAY = 100;\nconst MAX_SCROLL_UPDATE_DELAY = 500;\nconst IDLE_DEBOUNCE_DELAY = 200;\n// The amount of time to wait before declaring that the list isn't scrolling\nconst DONE_SCROLLING_WAIT = 500;\nconst DEFAULT_ITEMS_PER_PAGE = 10;\nconst DEFAULT_PAGE_HEIGHT = 30;\nconst DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nconst DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\nconst PAGE_KEY_PREFIX = 'page-';\nconst SPACER_KEY_PREFIX = 'spacer-';\n\nexport interface IListState<T = any> {\n  pages?: IPage<T>[];\n\n  /** The last versionstamp for  */\n  measureVersion?: number;\n  isScrolling?: boolean;\n  getDerivedStateFromProps(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T>;\n\n  pagesVersion?: {};\n  hasMounted: boolean;\n}\n\ninterface IPageCacheItem<T> {\n  page: IPage<T>;\n  pageElement?: JSX.Element;\n}\n\ninterface IPageCache<T> {\n  [key: string]: IPageCacheItem<T>;\n}\n\nconst EMPTY_RECT = {\n  top: -1,\n  bottom: -1,\n  left: -1,\n  right: -1,\n  width: 0,\n  height: 0,\n};\n\n// Naming expensive measures so that they're named in profiles.\nconst _measurePageRect = (element: HTMLElement) => element.getBoundingClientRect();\nconst _measureSurfaceRect = _measurePageRect;\nconst _measureScrollRect = _measurePageRect;\n\n/**\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback\n * if provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if\n * provided by the caller, or by cached measurements if available, or by a running average, or a default fallback.\n *\n * The algorithm for rendering pages works like this:\n *\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\n * 2. If changes are necessary, apply changes (add/remove pages)\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\n *\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\n *\n * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,\n * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time.\n * And we start doing measurements and rendering in virtualized mode when items grows larger than this threshold.\n *\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\n */\nexport class List<T = any> extends React.Component<IListProps<T>, IListState<T>> implements IList {\n  public static defaultProps = {\n    startIndex: 0,\n    onRenderCell: (item: any, index: number, containsFocus: boolean) => <>{(item && item.name) || ''}</>,\n    onRenderCellConditional: undefined,\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND,\n  };\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _surface = React.createRef<HTMLDivElement>();\n  private _pageRefs: Record<string, unknown> = {};\n  private _async: Async;\n  private _events: EventGroup;\n  private _estimatedPageHeight: number;\n  private _totalEstimates: number;\n  private _cachedPageHeights: {\n    [key: string]: {\n      height: number;\n      measureVersion: number;\n    };\n  };\n  private _focusedIndex: number;\n  private _scrollElement?: HTMLElement;\n\n  // surface rect relative to window\n  private _surfaceRect: IRectangle | undefined;\n\n  // The visible rect that we're required to render given the current list state.\n  private _requiredRect: IRectangle | null;\n\n  // The visible rect that we're allowed to keep rendered. Pages outside of this rect will be removed.\n  private _allowedRect: IRectangle;\n\n  // The rect that is visible to the user\n  private _visibleRect: IRectangle | undefined;\n\n  // materialized rect around visible items, relative to surface\n  private _materializedRect: IRectangle | null;\n\n  private _requiredWindowsAhead: number;\n  private _requiredWindowsBehind: number;\n\n  private _measureVersion: number;\n  private _scrollHeight?: number;\n  private _scrollTop: number;\n  private _pageCache: IPageCache<T>;\n\n  public static getDerivedStateFromProps<U = any>(\n    nextProps: IListProps<U>,\n    previousState: IListState<U>,\n  ): IListState<U> {\n    return previousState.getDerivedStateFromProps(nextProps, previousState);\n  }\n\n  constructor(props: IListProps<T>) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      pages: [],\n      isScrolling: false,\n      getDerivedStateFromProps: this._getDerivedStateFromProps,\n      hasMounted: false,\n    };\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    this._estimatedPageHeight = 0;\n    this._totalEstimates = 0;\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n\n    // Track the measure version for everything.\n    this._measureVersion = 0;\n\n    // Ensure that scrolls are lazy updated.\n    this._onAsyncScroll = this._async.debounce(this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {\n      leading: false,\n      maxWait: MAX_SCROLL_UPDATE_DELAY,\n    });\n\n    this._onAsyncIdle = this._async.debounce(this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {\n      leading: false,\n    });\n\n    this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n      leading: false,\n    });\n\n    this._onScrollingDone = this._async.debounce(this._onScrollingDone, DONE_SCROLLING_WAIT, {\n      leading: false,\n    });\n\n    this._cachedPageHeights = {};\n    this._estimatedPageHeight = 0;\n    this._focusedIndex = -1;\n    this._pageCache = {};\n  }\n\n  public get pageRefs(): Readonly<Record<string, unknown>> {\n    return this._pageRefs;\n  }\n\n  /**\n   * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback\n   * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.\n   *\n   * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling\n   * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.\n   *\n   * @param index - Index of item to scroll to\n   * @param measureItem - Optional callback to measure the height of an individual item\n   * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling\n   */\n  public scrollToIndex(\n    index: number,\n    measureItem?: (itemIndex: number) => number,\n    scrollToMode: ScrollToMode = ScrollToMode.auto,\n  ): void {\n    const startIndex = this.props.startIndex as number;\n    const renderCount = this._getRenderCount();\n    const endIndex = startIndex + renderCount;\n\n    const allowedRect = this._allowedRect;\n\n    let scrollTop = 0;\n\n    let itemsPerPage = 1;\n    for (let itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      const pageSpecification = this._getPageSpecification(this.props, itemIndex, allowedRect);\n\n      const pageHeight = pageSpecification.height;\n      itemsPerPage = pageSpecification.itemCount;\n\n      const requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;\n      if (requestedIndexIsInPage) {\n        // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in\n        // just the given item, otherwise we'll only bring the page into view\n        if (measureItem && this._scrollElement) {\n          const scrollRect = _measureScrollRect(this._scrollElement);\n          const scrollPosition = getScrollYPosition(this._scrollElement);\n          const scrollWindow = {\n            top: scrollPosition,\n            bottom: scrollPosition + scrollRect.height,\n          };\n\n          // Adjust for actual item position within page\n          const itemPositionWithinPage = index - itemIndex;\n          for (let itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {\n            scrollTop += measureItem(itemIndex + itemIndexInPage);\n          }\n          const scrollBottom = scrollTop + measureItem(index);\n\n          // If scrollToMode is set to something other than auto, we always want to\n          // scroll the item into a specific position on the page.\n          switch (scrollToMode) {\n            case ScrollToMode.top:\n              setScrollYPosition(this._scrollElement, scrollTop);\n              return;\n            case ScrollToMode.bottom:\n              setScrollYPosition(this._scrollElement, scrollBottom - scrollRect.height);\n              return;\n            case ScrollToMode.center:\n              setScrollYPosition(this._scrollElement, (scrollTop + scrollBottom - scrollRect.height) / 2);\n              return;\n            case ScrollToMode.auto:\n            default:\n              break;\n          }\n\n          const itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;\n          if (itemIsFullyVisible) {\n            // Item is already visible, do nothing.\n            return;\n          }\n\n          const itemIsPartiallyAbove = scrollTop < scrollWindow.top;\n          const itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;\n\n          if (itemIsPartiallyAbove) {\n            //  We will just scroll to 'scrollTop'\n            //  .------.   - scrollTop\n            //  |Item  |\n            //  | .----|-. - scrollWindow.top\n            //  '------' |\n            //    |      |\n            //    '------'\n          } else if (itemIsPartiallyBelow) {\n            //  Adjust scrollTop position to just bring in the element\n            // .------.  - scrollTop\n            // |      |\n            // | .------.\n            // '-|----' | - scrollWindow.bottom\n            //   | Item |\n            //   '------' - scrollBottom\n            scrollTop = scrollBottom - scrollRect.height;\n          }\n        }\n\n        if (this._scrollElement) {\n          setScrollYPosition(this._scrollElement, scrollTop);\n        }\n        return;\n      }\n\n      scrollTop += pageHeight;\n    }\n  }\n\n  public getStartItemIndexInView(measureItem?: (itemIndex: number) => number): number {\n    const pages = this.state.pages || [];\n    for (const page of pages) {\n      const isPageVisible =\n        !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;\n      if (isPageVisible) {\n        if (!measureItem) {\n          const rowHeight = Math.floor(page.height / page.itemCount);\n          return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);\n        } else {\n          let totalRowHeight = 0;\n          for (let itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {\n            const rowHeight = measureItem(itemIndex);\n            if (\n              page.top + totalRowHeight <= this._scrollTop &&\n              this._scrollTop < page.top + totalRowHeight + rowHeight\n            ) {\n              return itemIndex;\n            } else {\n              totalRowHeight += rowHeight;\n            }\n          }\n        }\n      }\n    }\n    return 0;\n  }\n\n  public componentDidMount(): void {\n    this.setState({ hasMounted: true });\n    this._scrollElement = findScrollableParent(this._root.current) as HTMLElement;\n    this._scrollTop = 0;\n\n    if (!this.props.getPageHeight) {\n      const heightsChanged = this._updatePageMeasurements(this.state.pages!);\n      if (heightsChanged) {\n        this._materializedRect = null;\n        this.setState(this._updatePages(this.props, this.state));\n      }\n    }\n\n    this._measureVersion++;\n\n    this._events.on(window, 'resize', this._onAsyncResize);\n    if (this._root.current) {\n      this._events.on(this._root.current, 'focus', this._onFocus, true);\n    }\n    if (this._scrollElement) {\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);\n    }\n  }\n\n  public componentDidUpdate(previousProps: IListProps, previousState: IListState<T>): void {\n    // Multiple updates may have been queued, so the callback will reflect all of them.\n    // Re-fetch the current props and states to avoid using a stale props or state captured in the closure.\n    const finalProps = this.props;\n    const finalState = this.state;\n\n    if (this.state.pagesVersion !== previousState.pagesVersion) {\n      // If we weren't provided with the page height, measure the pages\n      if (!finalProps.getPageHeight) {\n        // If measured version is invalid since we've updated the DOM\n        const heightsChanged = this._updatePageMeasurements(finalState.pages!);\n\n        if (heightsChanged) {\n          this._materializedRect = null;\n          this._onAsyncScroll();\n        } else {\n          // Enqueue an idle bump.\n          this._onAsyncIdle();\n        }\n      } else {\n        // Enqueue an idle bump\n        this._onAsyncIdle();\n      }\n\n      // Notify the caller that rendering the new pages has completed\n      if (finalProps.onPagesUpdated) {\n        finalProps.onPagesUpdated(finalState.pages as IPage<T>[]);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n\n    delete this._scrollElement;\n  }\n\n  public shouldComponentUpdate(newProps: IListProps<T>, newState: IListState<T>): boolean {\n    const { pages: oldPages } = this.state;\n    const { pages: newPages } = newState;\n    let shouldComponentUpdate = false;\n\n    // Update if the page stops scrolling\n    if (!newState.isScrolling && this.state.isScrolling) {\n      return true;\n    }\n\n    if (newProps.version !== this.props.version) {\n      return true;\n    }\n\n    if (newProps.className !== this.props.className) {\n      return true;\n    }\n\n    if (newProps.items === this.props.items && oldPages!.length === newPages!.length) {\n      for (let i = 0; i < oldPages!.length; i++) {\n        const oldPage = oldPages![i];\n        const newPage = newPages![i];\n\n        if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {\n          shouldComponentUpdate = true;\n          break;\n        }\n      }\n    } else {\n      shouldComponentUpdate = true;\n    }\n\n    return shouldComponentUpdate;\n  }\n\n  public forceUpdate(): void {\n    this._invalidatePageCache();\n    // Ensure that when the list is force updated we update the pages first before render.\n    this._updateRenderRects(this.props, this.state, true);\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n\n    super.forceUpdate();\n  }\n\n  /**\n   * Get the current height the list and it's pages.\n   */\n  public getTotalListHeight(): number {\n    return this._surfaceRect!.height;\n  }\n\n  public render(): JSX.Element | null {\n    const { className, role = 'list', onRenderSurface, onRenderRoot } = this.props;\n    const { pages = [] } = this.state;\n    const pageElements: JSX.Element[] = [];\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    for (const page of pages) {\n      pageElements.push(this._renderPage(page));\n    }\n\n    const finalOnRenderSurface = onRenderSurface\n      ? composeRenderFunction(onRenderSurface, this._onRenderSurface)\n      : this._onRenderSurface;\n\n    const finalOnRenderRoot = onRenderRoot\n      ? composeRenderFunction(onRenderRoot, this._onRenderRoot)\n      : this._onRenderRoot;\n\n    return finalOnRenderRoot({\n      rootRef: this._root,\n      pages,\n      surfaceElement: finalOnRenderSurface({\n        surfaceRef: this._surface,\n        pages,\n        pageElements,\n        divProps: {\n          role: 'presentation',\n          className: 'ms-List-surface',\n        },\n      }),\n      divProps: {\n        ...divProps,\n        className: css('ms-List', className),\n        role: pageElements.length > 0 ? role : undefined,\n        'aria-label': pageElements.length > 0 ? divProps['aria-label'] : undefined,\n      },\n    });\n  }\n\n  private _getDerivedStateFromProps = (nextProps: IListProps<T>, previousState: IListState<T>): IListState<T> => {\n    if (\n      nextProps.items !== this.props.items ||\n      nextProps.renderCount !== this.props.renderCount ||\n      nextProps.startIndex !== this.props.startIndex ||\n      nextProps.version !== this.props.version ||\n      !previousState.hasMounted\n    ) {\n      if (!canUseDOM()) {\n        return previousState;\n      }\n      // We have received new items so we want to make sure that initially we only render a single window to\n      // fill the currently visible rect, and then later render additional windows.\n      this._resetRequiredWindows();\n      this._requiredRect = null;\n\n      this._measureVersion++;\n      this._invalidatePageCache();\n\n      return this._updatePages(nextProps, previousState);\n    }\n\n    return previousState;\n  };\n\n  private _shouldVirtualize(props: IListProps<T> = this.props): boolean {\n    const { onShouldVirtualize } = props;\n    return !onShouldVirtualize || onShouldVirtualize(props);\n  }\n\n  /**\n   * when props.items change or forceUpdate called, throw away cached pages\n   */\n  private _invalidatePageCache(): void {\n    this._pageCache = {};\n  }\n\n  private _renderPage(page: IPage<T>): JSX.Element {\n    const { usePageCache } = this.props;\n    let cachedPage;\n    // if usePageCache is set and cached page element can be found, just return cached page\n    if (usePageCache) {\n      cachedPage = this._pageCache[page.key];\n      if (cachedPage && cachedPage.pageElement) {\n        return cachedPage.pageElement;\n      }\n    }\n\n    const pageStyle = this._getPageStyle(page);\n\n    const { onRenderPage = this._onRenderPage } = this.props;\n\n    const pageElement = onRenderPage(\n      {\n        page,\n        className: 'ms-List-page',\n        key: page.key,\n        ref: (newRef: unknown) => {\n          this._pageRefs[page.key] = newRef;\n        },\n        style: pageStyle,\n        role: 'presentation',\n      },\n      this._onRenderPage,\n    );\n\n    // cache the first page for now since it is re-rendered a lot times unnecessarily.\n    // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.\n    // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the\n    // first 30 items did not change, we still re-rendered all of them in this props.items change.\n    if (usePageCache && page.startIndex === 0) {\n      this._pageCache[page.key] = {\n        page,\n        pageElement,\n      };\n    }\n    return pageElement;\n  }\n\n  private _onRenderRoot = (props: IListOnRenderRootProps<T>): JSX.Element => {\n    const { rootRef, surfaceElement, divProps } = props;\n\n    return (\n      <div ref={rootRef} {...divProps}>\n        {surfaceElement}\n      </div>\n    );\n  };\n\n  private _onRenderSurface = (props: IListOnRenderSurfaceProps<T>): JSX.Element => {\n    const { surfaceRef, pageElements, divProps } = props;\n\n    return (\n      <div ref={surfaceRef} {...divProps}>\n        {pageElements}\n      </div>\n    );\n  };\n\n  /** Generate the style object for the page. */\n  private _getPageStyle(page: IPage<T>): React.StyleHTMLAttributes<HTMLDivElement> {\n    const { getPageStyle } = this.props;\n\n    return {\n      ...(getPageStyle ? getPageStyle(page) : {}),\n      ...(!page.items\n        ? {\n            height: page.height,\n          }\n        : {}),\n    };\n  }\n\n  private _onRenderPage = (pageProps: IPageProps<T>, defaultRender?: IRenderFunction<IPageProps<T>>): any => {\n    const { onRenderCell, onRenderCellConditional, role } = this.props;\n\n    const {\n      page: { items = [], startIndex },\n      ...divProps\n    } = pageProps;\n\n    // only assign list item role if no role is assigned\n    const cellRole = role === undefined ? 'listitem' : 'presentation';\n    const cells: React.ReactNode[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      const index = startIndex + i;\n      const item = items[i];\n\n      let itemKey = this.props.getKey ? this.props.getKey(item, index) : item && (item as any).key;\n\n      if (itemKey === null || itemKey === undefined) {\n        itemKey = index;\n      }\n\n      const renderCell = onRenderCellConditional ?? onRenderCell;\n\n      const cell =\n        renderCell?.(item, index, !this.props.ignoreScrollingState ? this.state.isScrolling : undefined) ?? null;\n\n      if (!onRenderCellConditional || cell) {\n        cells.push(\n          <div\n            role={cellRole}\n            className={'ms-List-cell'}\n            key={itemKey}\n            data-list-index={index}\n            data-automationid=\"ListCell\"\n          >\n            {cell}\n          </div>,\n        );\n      }\n    }\n\n    return <div {...divProps}>{cells}</div>;\n  };\n\n  /** Track the last item index focused so that we ensure we keep it rendered. */\n  private _onFocus(ev: any): void {\n    let target = ev.target as HTMLElement;\n\n    while (target !== this._surface.current) {\n      const indexString = target.getAttribute('data-list-index');\n\n      if (indexString) {\n        this._focusedIndex = Number(indexString);\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  }\n\n  /**\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\n   * we will call onAsyncIdle which will reset it back to it's correct value.\n   */\n  private _onScroll(): void {\n    if (!this.state.isScrolling && !this.props.ignoreScrollingState) {\n      this.setState({ isScrolling: true });\n    }\n    this._resetRequiredWindows();\n    this._onScrollingDone();\n  }\n\n  private _resetRequiredWindows(): void {\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n  }\n\n  /**\n   * Debounced method to asynchronously update the visible region on a scroll event.\n   */\n  private _onAsyncScroll(): void {\n    this._updateRenderRects(this.props, this.state);\n\n    // Only update pages when the visible rect falls outside of the materialized rect.\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect as IRectangle, this._materializedRect)) {\n      this.setState(this._updatePages(this.props, this.state));\n    } else {\n      // console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\n    }\n  }\n\n  /**\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\n   * either, we increase the amount we render and re-evaluate.\n   */\n  private _onAsyncIdle(): void {\n    const { renderedWindowsAhead, renderedWindowsBehind } = this.props;\n    const { _requiredWindowsAhead: requiredWindowsAhead, _requiredWindowsBehind: requiredWindowsBehind } = this;\n    const windowsAhead = Math.min(renderedWindowsAhead as number, requiredWindowsAhead + 1);\n    const windowsBehind = Math.min(renderedWindowsBehind as number, requiredWindowsBehind + 1);\n\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\n      // console.log('idling', windowsBehind, windowsAhead);\n\n      this._requiredWindowsAhead = windowsAhead;\n      this._requiredWindowsBehind = windowsBehind;\n      this._updateRenderRects(this.props, this.state);\n      this.setState(this._updatePages(this.props, this.state));\n    }\n\n    if (renderedWindowsAhead! > windowsAhead || renderedWindowsBehind! > windowsBehind) {\n      // Async increment on next tick.\n      this._onAsyncIdle();\n    }\n  }\n\n  /**\n   * Function to call when the list is done scrolling.\n   * This function is debounced.\n   */\n  private _onScrollingDone(): void {\n    if (!this.props.ignoreScrollingState) {\n      this.setState({ isScrolling: false });\n    }\n  }\n\n  private _onAsyncResize(): void {\n    this.forceUpdate();\n  }\n\n  private _updatePages(nextProps: IListProps<T>, previousState: IListState<T>): IListState<T> {\n    // console.log('updating pages');\n\n    if (!this._requiredRect) {\n      this._updateRenderRects(nextProps, previousState);\n    }\n\n    const newListState = this._buildPages(nextProps, previousState);\n    const oldListPages = previousState.pages!;\n\n    this._notifyPageChanges(oldListPages, newListState.pages!, this.props);\n\n    return {\n      ...previousState,\n      ...newListState,\n      pagesVersion: {},\n    };\n  }\n\n  /**\n   * Notify consumers that the rendered pages have changed\n   * @param oldPages - The old pages\n   * @param newPages - The new pages\n   * @param props - The props to use\n   */\n  private _notifyPageChanges(oldPages: IPage<T>[], newPages: IPage<T>[], props: IListProps<T>): void {\n    const { onPageAdded, onPageRemoved } = props;\n\n    if (onPageAdded || onPageRemoved) {\n      const renderedIndexes: {\n        [index: number]: IPage<T>;\n      } = {};\n\n      for (const page of oldPages) {\n        if (page.items) {\n          renderedIndexes[page.startIndex] = page;\n        }\n      }\n\n      for (const page of newPages) {\n        if (page.items) {\n          if (!renderedIndexes[page.startIndex]) {\n            this._onPageAdded(page);\n          } else {\n            delete renderedIndexes[page.startIndex];\n          }\n        }\n      }\n\n      for (const index in renderedIndexes) {\n        if (renderedIndexes.hasOwnProperty(index)) {\n          this._onPageRemoved(renderedIndexes[index]);\n        }\n      }\n    }\n  }\n\n  private _updatePageMeasurements(pages: IPage<T>[]): boolean {\n    let heightChanged = false;\n\n    // when not in virtualize mode, we render all the items without page measurement\n    if (!this._shouldVirtualize()) {\n      return heightChanged;\n    }\n\n    for (let i = 0; i < pages.length; i++) {\n      const page = pages[i];\n\n      if (page.items) {\n        heightChanged = this._measurePage(page) || heightChanged;\n      }\n    }\n\n    return heightChanged;\n  }\n\n  /**\n   * Given a page, measure its dimensions, update cache.\n   * @returns True if the height has changed.\n   */\n  private _measurePage(page: IPage<T>): boolean {\n    let hasChangedHeight = false;\n    const pageElement = this._pageRefs[page.key] as HTMLElement;\n    const cachedHeight = this._cachedPageHeights[page.startIndex];\n\n    // console.log('   * measure attempt', page.startIndex, cachedHeight);\n\n    if (\n      pageElement &&\n      this._shouldVirtualize() &&\n      (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)\n    ) {\n      const newClientRect = {\n        width: pageElement.clientWidth,\n        height: pageElement.clientHeight,\n      };\n\n      if (newClientRect.height || newClientRect.width) {\n        hasChangedHeight = page.height !== newClientRect.height;\n\n        // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\n\n        page.height = newClientRect.height;\n\n        this._cachedPageHeights[page.startIndex] = {\n          height: newClientRect.height,\n          measureVersion: this._measureVersion,\n        };\n\n        this._estimatedPageHeight = Math.round(\n          (this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1),\n        );\n\n        this._totalEstimates++;\n      }\n    }\n\n    return hasChangedHeight;\n  }\n\n  /** Called when a page has been added to the DOM. */\n  private _onPageAdded(page: IPage<T>): void {\n    const { onPageAdded } = this.props;\n\n    // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageAdded) {\n      onPageAdded(page);\n    }\n  }\n\n  /** Called when a page has been removed from the DOM. */\n  private _onPageRemoved(page: IPage<T>): void {\n    const { onPageRemoved } = this.props;\n\n    // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageRemoved) {\n      onPageRemoved(page);\n    }\n  }\n\n  /** Build up the pages that should be rendered. */\n  private _buildPages(props: IListProps<T>, state: IListState<T>): IListState<T> {\n    let { renderCount } = props;\n    const { items, startIndex, getPageHeight } = props;\n\n    renderCount = this._getRenderCount(props);\n\n    const materializedRect = { ...EMPTY_RECT };\n    const pages: IPage<T>[] = [];\n\n    let itemsPerPage = 1;\n    let pageTop = 0;\n    let currentSpacer = null;\n    const focusedIndex = this._focusedIndex;\n    const endIndex = startIndex! + renderCount;\n    const shouldVirtualize = this._shouldVirtualize(props);\n\n    // First render is very important to track; when we render cells, we have no idea of estimated page height.\n    // So we should default to rendering only the first page so that we can get information.\n    // However if the user provides a measure function, let's just assume they know the right heights.\n    const isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;\n\n    const allowedRect = this._allowedRect;\n\n    for (let itemIndex = startIndex!; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      const pageSpecification = this._getPageSpecification(props, itemIndex, allowedRect);\n      const pageHeight = pageSpecification.height;\n      const pageData = pageSpecification.data;\n      const key = pageSpecification.key;\n\n      itemsPerPage = pageSpecification.itemCount;\n\n      const pageBottom = pageTop + pageHeight - 1;\n\n      const isPageRendered =\n        findIndex(state.pages as IPage<T>[], (page: IPage<T>) => !!page.items && page.startIndex === itemIndex) > -1;\n      const isPageInAllowedRange = !allowedRect || (pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom!);\n      const isPageInRequiredRange =\n        !this._requiredRect || (pageBottom >= this._requiredRect.top && pageTop <= this._requiredRect.bottom!);\n      const isPageVisible =\n        (!isFirstRender && (isPageInRequiredRange || (isPageInAllowedRange && isPageRendered))) || !shouldVirtualize;\n      const isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;\n      const isFirstPage = itemIndex === startIndex;\n\n      // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' +\n      // isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);\n\n      // Only render whats visible, focused, or first page,\n      // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages\n      if (isPageVisible || isPageFocused || isFirstPage) {\n        if (currentSpacer) {\n          pages.push(currentSpacer);\n          currentSpacer = null;\n        }\n\n        const itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\n        const newPage = this._createPage(\n          key,\n          items!.slice(itemIndex, itemIndex + itemsInPage),\n          itemIndex,\n          undefined,\n          undefined,\n          pageData,\n        );\n\n        newPage.top = pageTop;\n        newPage.height = pageHeight;\n        if (this._visibleRect && this._visibleRect.bottom) {\n          newPage.isVisible = pageBottom >= this._visibleRect.top && pageTop <= this._visibleRect.bottom;\n        }\n\n        pages.push(newPage);\n\n        if (isPageInRequiredRange && this._allowedRect) {\n          _mergeRect(materializedRect, {\n            top: pageTop,\n            bottom: pageBottom,\n            height: pageHeight,\n            left: allowedRect.left,\n            right: allowedRect.right,\n            width: allowedRect.width,\n          });\n        }\n      } else {\n        if (!currentSpacer) {\n          currentSpacer = this._createPage(\n            SPACER_KEY_PREFIX + itemIndex,\n            undefined,\n            itemIndex,\n            0,\n            undefined,\n            pageData,\n            true /*isSpacer*/,\n          );\n        }\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\n        currentSpacer.itemCount += itemsPerPage;\n      }\n      pageTop += pageBottom - pageTop + 1;\n\n      // in virtualized mode, we render need to render first page then break and measure,\n      // otherwise, we render all items without measurement to make rendering fast\n      if (isFirstRender && shouldVirtualize) {\n        break;\n      }\n    }\n\n    if (currentSpacer) {\n      currentSpacer.key = SPACER_KEY_PREFIX + 'end';\n      pages.push(currentSpacer);\n    }\n\n    this._materializedRect = materializedRect;\n\n    // console.log('materialized: ', materializedRect);\n    return {\n      ...state,\n      pages,\n      measureVersion: this._measureVersion,\n    };\n  }\n\n  private _getPageSpecification(\n    props: IListProps,\n    itemIndex: number,\n    visibleRect: IRectangle,\n  ): {\n    // These return values are now no longer optional.\n    itemCount: number;\n    height: number;\n    data?: any;\n    key?: string;\n  } {\n    const { getPageSpecification } = props;\n\n    if (getPageSpecification) {\n      const pageData = getPageSpecification(itemIndex, visibleRect);\n\n      const { itemCount = this._getItemCountForPage(itemIndex, visibleRect) } = pageData;\n\n      const { height = this._getPageHeight(itemIndex, visibleRect, itemCount) } = pageData;\n\n      return {\n        itemCount,\n        height,\n        data: pageData.data,\n        key: pageData.key,\n      };\n    } else {\n      const itemCount = this._getItemCountForPage(itemIndex, visibleRect);\n\n      return {\n        itemCount,\n        height: this._getPageHeight(itemIndex, visibleRect, itemCount),\n      };\n    }\n  }\n\n  /**\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\n   * cached height, or estimated page height, or default page height.\n   */\n  private _getPageHeight(itemIndex: number, visibleRect: IRectangle, itemsPerPage: number): number {\n    if (this.props.getPageHeight) {\n      return this.props.getPageHeight(itemIndex, visibleRect, itemsPerPage);\n    } else {\n      const cachedHeight = this._cachedPageHeights[itemIndex];\n\n      return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;\n    }\n  }\n\n  private _getItemCountForPage(itemIndex: number, visibileRect: IRectangle): number {\n    const itemsPerPage = this.props.getItemCountForPage\n      ? this.props.getItemCountForPage(itemIndex, visibileRect)\n      : DEFAULT_ITEMS_PER_PAGE;\n\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\n  }\n\n  private _createPage(\n    pageKey: string | undefined,\n    items: any[] | undefined,\n    startIndex: number = -1,\n    count: number = items ? items.length : 0,\n    style: React.CSSProperties = {},\n    data?: any,\n    isSpacer?: boolean,\n  ): IPage<T> {\n    pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;\n    const cachedPage = this._pageCache[pageKey];\n    if (cachedPage && cachedPage.page) {\n      return cachedPage.page;\n    }\n\n    return {\n      key: pageKey,\n      startIndex,\n      itemCount: count,\n      items,\n      style,\n      top: 0,\n      height: 0,\n      data,\n      isSpacer: isSpacer || false,\n    };\n  }\n\n  private _getRenderCount(props?: IListProps<T>): number {\n    const { items, startIndex, renderCount } = props || this.props;\n\n    return renderCount === undefined ? (items ? items.length - startIndex! : 0) : renderCount;\n  }\n\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\n  private _updateRenderRects(props: IListProps<T>, state: IListState<T>, forceUpdate?: boolean): void {\n    const { renderedWindowsAhead, renderedWindowsBehind } = props;\n    const { pages } = state;\n    // when not in virtualize mode, we render all items without measurement to optimize page rendering perf\n    if (!this._shouldVirtualize(props)) {\n      return;\n    }\n\n    let surfaceRect = this._surfaceRect || { ...EMPTY_RECT };\n    const scrollHeight = getScrollHeight(this._scrollElement);\n    const scrollTop = getScrollYPosition(this._scrollElement);\n\n    // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\n    // This needs to be called to recalculate when new pages should be loaded.\n    // We check to see how far we've scrolled and if it's further than a third of a page we run it again.\n    if (\n      this._surface.current &&\n      (forceUpdate ||\n        !pages ||\n        !this._surfaceRect ||\n        !scrollHeight ||\n        scrollHeight !== this._scrollHeight ||\n        Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight / 3)\n    ) {\n      surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);\n      this._scrollTop = scrollTop;\n    }\n\n    // If the scroll height has changed, something in the container likely resized and\n    // we should redo the page heights incase their content resized.\n    if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {\n      this._measureVersion++;\n    }\n\n    this._scrollHeight = scrollHeight || 0;\n\n    // If the surface is above the container top or below the container bottom, or if this is not the first\n    // render return empty rect.\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\n    // used to calculate the width of the list items.\n    const visibleTop = Math.max(0, -surfaceRect.top);\n    const win = getWindow(this._root.current);\n    const visibleRect = {\n      top: visibleTop,\n      left: surfaceRect.left,\n      bottom: visibleTop + win!.innerHeight,\n      right: surfaceRect.right,\n      width: surfaceRect.width,\n      height: win!.innerHeight,\n    };\n\n    // The required/allowed rects are adjusted versions of the visible rect.\n    this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\n    this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind!, renderedWindowsAhead!);\n\n    // store the visible rect for later use.\n    this._visibleRect = visibleRect;\n  }\n}\n\nfunction _expandRect(rect: IRectangle, pagesBefore: number, pagesAfter: number): IRectangle {\n  const top = rect.top - pagesBefore * rect.height;\n  const height = rect.height + (pagesBefore + pagesAfter) * rect.height;\n\n  return {\n    top,\n    bottom: top + height,\n    height,\n    left: rect.left,\n    right: rect.right,\n    width: rect.width,\n  };\n}\n\nfunction _isContainedWithin(innerRect: IRectangle, outerRect: IRectangle): boolean {\n  return (\n    innerRect.top >= outerRect.top &&\n    innerRect.left >= outerRect.left &&\n    innerRect.bottom! <= outerRect.bottom! &&\n    innerRect.right! <= outerRect.right!\n  );\n}\n\nfunction _mergeRect(targetRect: IRectangle, newRect: IRectangle): IRectangle {\n  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;\n  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;\n  targetRect.bottom =\n    newRect.bottom! > targetRect.bottom! || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;\n  targetRect.right = newRect.right! > targetRect.right! || targetRect.right === -1 ? newRect.right : targetRect.right;\n  targetRect.width = targetRect.right! - targetRect.left + 1;\n  targetRect.height = targetRect.bottom! - targetRect.top + 1;\n\n  return targetRect;\n}\n"]}