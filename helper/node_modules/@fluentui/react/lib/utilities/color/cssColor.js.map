{"version":3,"file":"cssColor.js","sourceRoot":"../src/","sources":["utilities/color/cssColor.ts"],"names":[],"mappings":"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","sourcesContent":["import { MAX_COLOR_ALPHA } from './consts';\nimport { hsl2rgb } from './hsl2rgb';\nimport type { IRGB } from './interfaces';\n\n/**\n * Converts a valid CSS color string to an RGB color.\n * Note that hex colors *must* be prefixed with # to be considered valid.\n * Alpha in returned color defaults to 100.\n * Four and eight digit hex values (with alpha) are supported if the current browser supports them.\n */\nexport function cssColor(color?: string): IRGB | undefined {\n  if (!color) {\n    return undefined;\n  }\n\n  // Need to check the following valid color formats: RGB(A), HSL(A), hex, named color\n\n  // First check for well formatted RGB(A), HSL(A), and hex formats at the start.\n  // This is for perf (no creating an element) and catches the intentional \"transparent\" color\n  //   case early on.\n  const easyColor: IRGB | undefined = _rgba(color) || _hex6(color) || _hex3(color) || _hsla(color);\n  if (easyColor) {\n    return easyColor;\n  }\n\n  // if the above fails, do the more expensive catch-all\n  return _browserCompute(color);\n}\n\n/**\n * Uses the browser's getComputedStyle() to determine what the passed-in color is.\n * This assumes _rgba, _hex6, _hex3, and _hsla have already been tried and all failed.\n * This works by attaching an element to the DOM, which may fail in server-side rendering\n *   or with headless browsers.\n */\nfunction _browserCompute(str: string): IRGB | undefined {\n  if (typeof document === 'undefined') {\n    // don't throw an error when used server-side\n    return undefined;\n  }\n  const elem = document.createElement('div');\n  elem.style.backgroundColor = str;\n  // This element must be attached to the DOM for getComputedStyle() to have a value\n  elem.style.position = 'absolute';\n  elem.style.top = '-9999px';\n  elem.style.left = '-9999px';\n  elem.style.height = '1px';\n  elem.style.width = '1px';\n  document.body.appendChild(elem);\n  const eComputedStyle = getComputedStyle(elem);\n  const computedColor = eComputedStyle && eComputedStyle.backgroundColor;\n  document.body.removeChild(elem);\n  // computedColor is always an RGB(A) string, except for invalid colors in IE/Edge which return 'transparent'\n\n  // browsers return one of these if the color string is invalid,\n  // so need to differentiate between an actual error and intentionally passing in this color\n  if (computedColor === 'rgba(0, 0, 0, 0)' || computedColor === 'transparent') {\n    switch (str.trim()) {\n      // RGB and HSL were already checked at the start of the function\n      case 'transparent':\n      case '#0000':\n      case '#00000000':\n        return { r: 0, g: 0, b: 0, a: 0 };\n    }\n    return undefined;\n  }\n\n  return _rgba(computedColor);\n}\n\n/**\n * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _rgba(str?: string | null): IRGB | undefined {\n  if (!str) {\n    return undefined;\n  }\n\n  const match = str.match(/^rgb(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    const hasAlpha = !!match[1];\n    const expectedPartCount = hasAlpha ? 4 : 3;\n    const parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      return {\n        r: parts[0],\n        g: parts[1],\n        b: parts[2],\n        a: hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA,\n      };\n    }\n  }\n}\n\n/**\n * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).\n * Otherwise returns undefined.\n */\nfunction _hsla(str: string): IRGB | undefined {\n  const match = str.match(/^hsl(a?)\\(([\\d., ]+)\\)$/);\n  if (match) {\n    const hasAlpha = !!match[1];\n    const expectedPartCount = hasAlpha ? 4 : 3;\n    const parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      const rgba = hsl2rgb(parts[0], parts[1], parts[2]);\n      rgba.a = hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA;\n      return rgba;\n    }\n  }\n}\n\n/**\n * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex6(str: string): IRGB | undefined {\n  if (str[0] === '#' && str.length === 7 && /^#[\\da-fA-F]{6}$/.test(str)) {\n    return {\n      r: parseInt(str.slice(1, 3), 16),\n      g: parseInt(str.slice(3, 5), 16),\n      b: parseInt(str.slice(5, 7), 16),\n      a: MAX_COLOR_ALPHA,\n    };\n  }\n}\n\n/**\n * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\n * Otherwise returns undefined.\n */\nfunction _hex3(str: string): IRGB | undefined {\n  if (str[0] === '#' && str.length === 4 && /^#[\\da-fA-F]{3}$/.test(str)) {\n    return {\n      r: parseInt(str[1] + str[1], 16),\n      g: parseInt(str[2] + str[2], 16),\n      b: parseInt(str[3] + str[3], 16),\n      a: MAX_COLOR_ALPHA,\n    };\n  }\n}\n"]}