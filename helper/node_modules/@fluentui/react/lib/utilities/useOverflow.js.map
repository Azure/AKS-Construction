{"version":3,"file":"useOverflow.js","sourceRoot":"../src/","sources":["utilities/useOverflow.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\nimport type { RefCallback } from '@fluentui/react-hooks';\n\n/**\n * Callback to notify the user that the items in the overflow have changed. This should ensure that the overflow menu\n * is visible, and contains all of the overflowing items.\n *\n * @param overflowIndex - The index of the first item in the overflow, or items.length if nothing is overflowing.\n * @param items - The list of all items in the container, and whether that particular item is in the overflow\n */\nexport type OverflowItemsChangedCallback = (\n  overflowIndex: number,\n  items: { ele: HTMLElement; isOverflowing: boolean }[],\n) => void;\n\n/** Parameters for {@see useOverflow} */\nexport type OverflowParams = {\n  /** Callback to notify the user that the items in the overflow have changed. */\n  onOverflowItemsChanged: OverflowItemsChangedCallback;\n\n  /** True if the element containing overflowMenuButtonRef is in right-to-left order */\n  rtl: boolean;\n\n  /** Optional: Index of item that should never go into the overflow menu. */\n  pinnedIndex?: number;\n};\n\n/** Return value for {@see useOverflow} */\nexport type OverflowRefs = {\n  /** Set the overflow menu button's ref to this ref callback */\n  menuButtonRef: RefCallback<HTMLElement>;\n};\n\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport const useOverflow = ({ onOverflowItemsChanged, rtl, pinnedIndex }: OverflowParams): OverflowRefs => {\n  const updateOverflowRef = React.useRef<() => void>();\n  const containerWidthRef = React.useRef<number>();\n\n  // Attach a resize observer to the container\n  const containerRef = useRefEffect<HTMLElement>(container => {\n    const cleanupObserver = observeResize(container, entries => {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n\n    return () => {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n\n  const menuButtonRef = useRefEffect<HTMLElement>(menuButton => {\n    containerRef(menuButton.parentElement);\n    return () => containerRef(null);\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const container = containerRef.current;\n    const menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n\n    // items contains the container's children, excluding the overflow menu button itself\n    const items: HTMLElement[] = [];\n    for (let i = 0; i < container.children.length; i++) {\n      const item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    const minContainerWidth: number[] = [];\n    let extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = () => {\n      const containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (let i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          const itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n\n    let prevOverflowIndex = items.length;\n    const setOverflowIndex = (overflowIndex: number) => {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(\n          overflowIndex,\n          items.map((ele, index) => ({\n            ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex,\n          })),\n        );\n      }\n    };\n\n    let cancelAnimationFrame: (() => void) | undefined = undefined;\n\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      const win = getWindow(container);\n      if (win) {\n        const animationFrameId = win.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = () => win.cancelAnimationFrame(animationFrameId);\n      }\n    }\n\n    return () => {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n\n  return { menuButtonRef };\n};\n"]}