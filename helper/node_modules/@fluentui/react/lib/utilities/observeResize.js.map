{"version":3,"file":"observeResize.js","sourceRoot":"../src/","sources":["utilities/observeResize.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,qBAAqB,CAAC;AAEhD;;;;;;;;;;;;;GAaG;AACH,MAAM,CAAC,IAAM,aAAa,GAAG,UAC3B,MAA2B,EAC3B,QAAuE;IAEvE,IAAI,OAAO,cAAc,KAAK,WAAW,EAAE;QACzC,IAAM,UAAQ,GAAG,IAAI,cAAc,CAAC,QAAQ,CAAC,CAAC;QAE9C,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YACzB,MAAM,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,UAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAnB,CAAmB,CAAC,CAAC;SAC1C;aAAM;YACL,UAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;SAC1B;QAED,OAAO,cAAM,OAAA,UAAQ,CAAC,UAAU,EAAE,EAArB,CAAqB,CAAC;KACpC;SAAM;QACL,0DAA0D;QAC1D,IAAM,iBAAe,GAAG,cAAM,OAAA,QAAQ,CAAC,SAAS,CAAC,EAAnB,CAAmB,CAAC;QAElD,IAAM,KAAG,GAAG,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QAClE,IAAI,CAAC,KAAG,EAAE;YACR,4DAA4D;YAC5D,OAAO;gBACL,sBAAsB;YACxB,CAAC,CAAC;SACH;QAED,mFAAmF;QACnF,IAAM,kBAAgB,GAAG,KAAG,CAAC,qBAAqB,CAAC,iBAAe,CAAC,CAAC;QACpE,KAAG,CAAC,gBAAgB,CAAC,QAAQ,EAAE,iBAAe,EAAE,KAAK,CAAC,CAAC;QAEvD,OAAO;YACL,KAAG,CAAC,oBAAoB,CAAC,kBAAgB,CAAC,CAAC;YAC3C,KAAG,CAAC,mBAAmB,CAAC,QAAQ,EAAE,iBAAe,EAAE,KAAK,CAAC,CAAC;QAC5D,CAAC,CAAC;KACH;AACH,CAAC,CAAC","sourcesContent":["import { getWindow } from '@fluentui/utilities';\n\n/**\n * Wrapper for ResizeObserver, with fallback for browsers that don't support ResizeObserver.\n *\n * Calls the onResize callback once layout is complete, and again whenever any of the target(s) change size.\n * Or if ResizeObserver isn't supported, calls the callback whenever the window changes size.\n *\n * @param target - Either a single element, or array of elements to watch for size changes.\n * @param onResize - Callback to be notified when layout is complete, and when the target(s) change size.\n *    If this browser supports ResizeObserver, the callback will be passed the ResizeObserverEntry[] array.\n *    Otherwise, the entries array will be undefined, and you'll need to find another way to get the element's size,\n *    (e.g. clientWidth/clientHeight or getBoundingClientRect).\n *\n * @returns A function to clean up the observer/listener.\n */\nexport const observeResize = (\n  target: Element | Element[],\n  onResize: (entries: readonly ResizeObserverEntry[] | undefined) => void,\n): (() => void) => {\n  if (typeof ResizeObserver !== 'undefined') {\n    const observer = new ResizeObserver(onResize);\n\n    if (Array.isArray(target)) {\n      target.forEach(t => observer.observe(t));\n    } else {\n      observer.observe(target);\n    }\n\n    return () => observer.disconnect();\n  } else {\n    // Fallback for browsers that don't support ResizeObserver\n    const onResizeWrapper = () => onResize(undefined);\n\n    const win = getWindow(Array.isArray(target) ? target[0] : target);\n    if (!win) {\n      // Can't listen for resize if we can't get the window object\n      return () => {\n        // Nothing to clean up\n      };\n    }\n\n    // Listen for the first animation frame, which will happen after layout is complete\n    const animationFrameId = win.requestAnimationFrame(onResizeWrapper);\n    win.addEventListener('resize', onResizeWrapper, false);\n\n    return () => {\n      win.cancelAnimationFrame(animationFrameId);\n      win.removeEventListener('resize', onResizeWrapper, false);\n    };\n  }\n};\n\n/** Temporary type definition for ResizeObserver. Can be removed when official types are available. */\ntype ResizeObserver = {\n  new (callback: (entries: readonly ResizeObserverEntry[], observer: ResizeObserver) => void): ResizeObserver;\n  observe(target: Element, options?: { box: 'content-box' | 'border-box' }): void;\n  unobserve(target: Element): void;\n  disconnect(): void;\n};\n\n/** Temporary type definition for ResizeObserverEntry. Can be removed when official types are available. */\ntype ResizeObserverEntry = {\n  readonly contentRect: DOMRectReadOnly;\n  readonly target: Element;\n};\n\n/** Temporary definition for ResizeObserver. Can be removed when official types are available. */\ndeclare const ResizeObserver: ResizeObserver | undefined;\n"]}