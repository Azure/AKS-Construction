{"version":3,"file":"ContextualMenu.types.js","sourceRoot":"../src/","sources":["components/ContextualMenu/ContextualMenu.types.ts"],"names":[],"mappings":";;;AAqBA,gEAA+D;AAAtD,kHAAA,eAAe,OAAA;AAExB;;GAEG;AACH,IAAY,sBAKX;AALD,WAAY,sBAAsB;IAChC,uEAAU,CAAA;IACV,yEAAW,CAAA;IACX,uEAAU,CAAA;IACV,yEAAW,CAAA;AACb,CAAC,EALW,sBAAsB,GAAtB,8BAAsB,KAAtB,8BAAsB,QAKjC","sourcesContent":["import * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { IFocusZoneProps } from '../../FocusZone';\nimport type { IIconProps } from '../../Icon';\nimport type { ICalloutProps, ICalloutContentStyleProps } from '../../Callout';\nimport type { ITheme, IStyle } from '../../Styling';\nimport type { IButtonStyles } from '../../Button';\nimport type { IRefObject, IBaseProps, IRectangle, IRenderFunction, IStyleFunctionOrObject } from '../../Utilities';\nimport type { IWithResponsiveModeState } from '../../ResponsiveMode';\nimport type { IContextualMenuClassNames, IMenuItemClassNames } from './ContextualMenu.classNames';\nimport type { IVerticalDividerClassNames } from '../Divider/VerticalDivider.types';\nimport type {\n  IContextualMenuItemProps,\n  IContextualMenuRenderItem,\n  IContextualMenuItemStyleProps,\n  IContextualMenuItemRenderFunctions,\n} from './ContextualMenuItem.types';\nimport type { IKeytipProps } from '../../Keytip';\nimport type { Target } from '@fluentui/react-hooks';\nimport type { IPopupRestoreFocusParams } from '../../Popup';\n\nexport { DirectionalHint } from '../../common/DirectionalHint';\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport enum ContextualMenuItemType {\n  Normal = 0,\n  Divider = 1,\n  Header = 2,\n  Section = 3,\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenu {}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuProps\n  extends IBaseProps<IContextualMenu>,\n    React.RefAttributes<HTMLDivElement>,\n    // eslint-disable-next-line deprecation/deprecation\n    IWithResponsiveModeState {\n  /**\n   * Optional callback to access the IContextualMenu interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   * @deprecated ContextualMenu has no imperative methods, so componentRef no longer returns a ref\n   */\n  componentRef?: IRefObject<IContextualMenu>;\n\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules.\n   */\n  styles?: IStyleFunctionOrObject<IContextualMenuStyleProps, IContextualMenuStyles>;\n\n  /**\n   * Theme provided by higher-order component.\n   */\n  theme?: ITheme;\n\n  /**\n   * Additional CSS class to apply to the ContextualMenu.\n   */\n  className?: string;\n\n  /**\n   * The target that the ContextualMenu should try to position itself based on.\n   * It can be either an element, a query selector string resolving to a valid element,\n   * or a MouseEvent. If a MouseEvent is given, the origin point of the event will be used.\n   */\n  target?: Target;\n\n  /**\n   * How the menu should be positioned\n   * @defaultvalue DirectionalHint.bottomAutoEdge\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the menu should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used.\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * The gap between the ContextualMenu and the target\n   * @defaultvalue 0\n   */\n  gapSpace?: number;\n\n  /**\n   * The width of the beak.\n   * @defaultvalue 16\n   */\n  beakWidth?: number;\n\n  /**\n   * If true the context menu will render as the same width as the target element\n   * @defaultvalue false\n   */\n  useTargetWidth?: boolean;\n\n  /**\n   * If true the context menu will have a minimum width equal to the width of the target element\n   * @defaultvalue false\n   */\n  useTargetAsMinWidth?: boolean;\n\n  /**\n   * The bounding rectangle (or callback that returns a rectangle) which the contextual menu can appear in.\n   */\n  bounds?: IRectangle | ((target?: Target, targetWindow?: Window) => IRectangle | undefined);\n\n  /**\n   * If true then the beak is visible. If false it will not be shown.\n   */\n  isBeakVisible?: boolean;\n\n  /**\n   * If true, the menu will be positioned to cover the target.\n   * If false, it will be positioned next to the target.\n   * @defaultvalue false\n   */\n  coverTarget?: boolean;\n\n  /**\n   * If true the positioning logic will prefer to flip edges rather than to nudge the rectangle to fit within bounds,\n   * thus making sure the element aligns perfectly with target's alignment edge\n   */\n  alignTargetEdge?: boolean;\n\n  /**\n   * Menu items to display.\n   */\n  items: IContextualMenuItem[];\n\n  /**\n   * Used as `aria-labelledby` for the menu element inside the callout.\n   */\n  labelElementId?: string;\n\n  /**\n   * Whether to focus on the menu when mounted.\n   * @defaultvalue true\n   */\n  shouldFocusOnMount?: boolean;\n\n  /**\n   * Whether to focus on the contextual menu container (as opposed to the first menu item).\n   *\n   * Avoid using as it breaks the default focus behaviour when using assistive technologies.\n   */\n  shouldFocusOnContainer?: boolean;\n\n  /**\n   * Callback when the ContextualMenu tries to close. If `dismissAll` is true then all\n   * submenus will be dismissed.\n   */\n  onDismiss?: (ev?: Event | React.MouseEvent | React.KeyboardEvent, dismissAll?: boolean) => void;\n\n  /**\n   * Click handler which is invoked if `onClick` is not passed for individual contextual\n   * menu item.\n   * Returning true will dismiss the menu even if `ev.preventDefault()` was called.\n   */\n  onItemClick?: (\n    ev?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    item?: IContextualMenuItem,\n  ) => boolean | void;\n\n  /**\n   * Whether this menu is a submenu of another menu.\n   */\n  isSubMenu?: boolean;\n\n  /**\n   * ID for the ContextualMenu's root element (inside the callout).\n   * Should be used for `aria-owns` and other such uses, rather than direct reference for programmatic purposes.\n   */\n  id?: string;\n\n  /**\n   * Accessible label for the ContextualMenu's root element (inside the callout).\n   */\n  ariaLabel?: string;\n\n  /**\n   * If true do not render on a new layer. If false render on a new layer.\n   * @defaultvalue false\n   */\n  doNotLayer?: boolean;\n\n  /**\n   * If true the position will not change sides in an attempt to fit the ContextualMenu within bounds.\n   * It will still attempt to align it to whatever bounds are given.\n   * @defaultvalue false\n   */\n  directionalHintFixed?: boolean;\n\n  /**\n   * Callback for when the menu has been opened.\n   */\n  onMenuOpened?: (contextualMenu?: IContextualMenuProps) => void;\n\n  /**\n   * Callback for when the menu is being closed (removing from the DOM).\n   */\n  onMenuDismissed?: (contextualMenu?: IContextualMenuProps) => void;\n\n  /**\n   * Additional custom props for the Callout.\n   */\n  calloutProps?: ICalloutProps;\n\n  /**\n   * Title to be displayed at the top of the menu, above the items.\n   */\n  title?: string;\n\n  /**\n   * Method to provide the classnames to style the contextual menu.\n   * @deprecated Use `styles` instead to leverage mergeStyles API.\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  getMenuClassNames?: (theme: ITheme, className?: string) => IContextualMenuClassNames;\n\n  /** Custom render function for a submenu. */\n  onRenderSubMenu?: IRenderFunction<IContextualMenuProps>;\n\n  /**\n   * Method to override the render of the list of menu items.\n   */\n  onRenderMenuList?: IRenderFunction<IContextualMenuListProps>;\n\n  /**\n   * Method to wrap menu items. Gives the ability to wrap a custom\n   * tooltip to each menu item button.\n   */\n  onRenderContextualMenuItem?: IRenderFunction<IContextualMenuItem>;\n\n  /**\n   * Delay (in milliseconds) to wait before expanding / dismissing a submenu on mouseEnter or mouseLeave\n   */\n  subMenuHoverDelay?: number;\n\n  /**\n   * Custom component to use for rendering individual menu items.\n   * @defaultvalue ContextualMenuItem\n   */\n  contextualMenuItemAs?:\n    | React.ComponentClass<IContextualMenuItemProps>\n    | React.FunctionComponent<IContextualMenuItemProps>;\n\n  /**\n   * Props to pass down to the FocusZone.\n   * NOTE: the default FocusZoneDirection will be used unless a direction\n   * is specified in the focusZoneProps (even if other focusZoneProps are defined)\n   * @defaultvalue \\{ direction: FocusZoneDirection.vertical \\}\n   */\n  focusZoneProps?: IFocusZoneProps;\n\n  /**\n   * Custom component to use for rendering the focus zone (the root).\n   * @defaultValue FocusZone\n   */\n  focusZoneAs?: React.ComponentClass<IFocusZoneProps> | React.FunctionComponent<IFocusZoneProps>;\n\n  /**\n   * If true, renders the ContextualMenu in a hidden state.\n   * Use this flag, rather than rendering a ContextualMenu conditionally based on visibility,\n   * to improve rendering performance when it becomes visible.\n   * Note: When ContextualMenu is hidden its content will not be rendered. It will only render\n   * once the ContextualMenu is visible.\n   */\n  hidden?: boolean;\n\n  /**\n   * If true, the menu will be updated even when `hidden=true`. Note that this will consume\n   * resources to update even when nothing is being shown to the user. This might be helpful if\n   * your updates are small and you want the menu to display quickly when `hidden` is set to false.\n   */\n  shouldUpdateWhenHidden?: boolean;\n\n  /**\n   * If true, the contextual menu will not be updated until focus enters the menu via other means.\n   * This will only result in different behavior when `shouldFocusOnMount = false`.\n   */\n  delayUpdateFocusOnHover?: boolean;\n\n  /**\n   * Called when the component is unmounting, and focus needs to be restored. If this is provided,\n   * focus will not be restored automatically, and you'll need to call `params.originalElement.focus()`.\n   */\n  onRestoreFocus?: (params: IPopupRestoreFocusParams) => void;\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuItemRenderProps extends IContextualMenuItem {\n  index: number;\n  focusableElementIndex: number;\n  totalItemCount: number;\n  hasCheckmarks: boolean;\n  hasIcons: boolean;\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuListProps {\n  items: IContextualMenuItem[];\n  totalItemCount: number;\n  hasCheckmarks: boolean;\n  hasIcons: boolean;\n  defaultMenuItemRenderer: (item: IContextualMenuItemRenderProps) => React.ReactNode;\n  ariaLabel?: string;\n  labelElementId?: string;\n  role?: string;\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuItem {\n  /**\n   * Optional callback to access the IContextualMenuRenderItem interface.\n   * This will get passed down to ContextualMenuItem.\n   */\n  componentRef?: IRefObject<IContextualMenuRenderItem>;\n\n  /**\n   * Unique id to identify the item\n   */\n  key: string;\n\n  /**\n   * Text of the menu item.\n   * If a standard hyphen (-) is passed in, then the item will be rendered as a divider.\n   * If a dash must appear as text, use an emdash (—), figuredash (‒), or minus symbol (−) instead.\n   */\n  text?: string;\n\n  /**\n   * Secondary description for the menu item to display\n   */\n  secondaryText?: string;\n\n  itemType?: ContextualMenuItemType;\n\n  /**\n   * Props for an icon to display next to the item.\n   */\n  iconProps?: IIconProps;\n\n  /**\n   * Custom render function for the menu item icon.\n   * iconProps must be present on at least one item for onRenderIcon to be called.\n   */\n  onRenderIcon?: IRenderFunction<IContextualMenuItemProps>;\n\n  /**\n   * Props for the Icon used for the chevron.\n   */\n  submenuIconProps?: IIconProps;\n\n  /**\n   * Whether the menu item is disabled\n   * @defaultvalue false\n   */\n  disabled?: boolean;\n\n  /**\n   * If the menu item is a split button, this prop disables purely the primary action of the button.\n   * @defaultvalue false\n   */\n  primaryDisabled?: boolean;\n\n  /**\n   * @deprecated Not used\n   */\n  shortCut?: string;\n\n  /**\n   * Whether or not this menu item can be checked\n   * @defaultvalue false\n   */\n  canCheck?: boolean;\n\n  /**\n   * Whether or not this menu item is currently checked.\n   * @defaultvalue false\n   */\n  checked?: boolean;\n\n  /**\n   * Whether or not this menu item is a splitButton.\n   * @defaultvalue false\n   */\n  split?: boolean;\n\n  /**\n   * Any custom data the developer wishes to associate with the menu item.\n   */\n  data?: any;\n\n  /**\n   * Callback for when the menu item is invoked. If `ev.preventDefault()` is called in `onClick`,\n   * the click will not close the menu.\n   *\n   * Only for ContextualMenu items, returning true will dismiss the menu even if `ev.preventDefault()`\n   * was called (does not apply for button or CommandBar sub-menu items).\n   */\n  onClick?: (\n    ev?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    item?: IContextualMenuItem,\n  ) => boolean | void;\n\n  /**\n   * Navigate to this URL when the menu item is clicked.\n   */\n  href?: string;\n\n  /**\n   * Target window when using `href`.\n   */\n  target?: string;\n\n  /**\n   * Link relation setting when using `href`.\n   * If `target` is `_blank`, `rel` is defaulted to a value to prevent clickjacking.\n   */\n  rel?: string;\n\n  /**\n   * Properties to apply to a submenu to this item.\n   *\n   * The ContextualMenu will provide default values for `target`, `onDismiss`, `isSubMenu`,\n   * `id`, `shouldFocusOnMount`, `directionalHint`, `className`, and `gapSpace`, all of which\n   * can be overridden.\n   */\n  subMenuProps?: IContextualMenuProps;\n\n  /**\n   * Method to provide the classnames to style the individual items inside a menu.\n   * @deprecated Use `styles` prop of `IContextualMenuItemProps` to leverage mergeStyles API.\n   */\n  getItemClassNames?: (\n    theme: ITheme,\n    disabled: boolean,\n    expanded: boolean,\n    checked: boolean,\n    isAnchorLink: boolean,\n    knownIcon: boolean,\n    itemClassName?: string,\n    dividerClassName?: string,\n    iconClassName?: string,\n    subMenuClassName?: string,\n    primaryDisabled?: boolean,\n  ) => // eslint-disable-next-line deprecation/deprecation\n  IMenuItemClassNames;\n\n  /**\n   * Optional IContextualMenuItemProps overrides to customize behaviors such as item styling via `styles`.\n   */\n  itemProps?: Partial<IContextualMenuItemProps>;\n\n  /**\n   * Method to provide the classnames to style the Vertical Divider of a split button inside a menu.\n   * Default value is the `getSplitButtonVerticalDividerClassNames` func defined in `ContextualMenu.classnames.ts`.\n   * @defaultvalue getSplitButtonVerticalDividerClassNames\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  getSplitButtonVerticalDividerClassNames?: (theme: ITheme) => IVerticalDividerClassNames;\n\n  /**\n   * Properties to apply to render this item as a section.\n   * This prop is mutually exclusive with `subMenuProps`.\n   */\n  sectionProps?: IContextualMenuSection;\n\n  /**\n   * Additional CSS class to apply to the menu item.\n   */\n  className?: string;\n\n  /**\n   * Additional styles to apply to the menu item\n   * @deprecated Use `styles` instead to leverage mergeStyles API.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Custom accessible label for the element.\n   * If no override is specified, the `aria-label` attribute will contain the item name.\n   */\n  ariaLabel?: string;\n\n  /**\n   * Title (tooltip) text displayed when hovering over an item.\n   */\n  title?: string;\n\n  /**\n   * Method to custom render this menu item.\n   * For keyboard accessibility, the top-level rendered item should be a focusable element\n   * (like an anchor or a button) or have the `data-is-focusable` property set to true.\n   *\n   * @param item - Item to render. Will typically be of type `IContextualMenuItem`.\n   * (When rendering a command bar item, will be `ICommandBarItemProps`.)\n   * @param dismissMenu - Function to dismiss the menu. Can be used to ensure that a custom menu\n   * item click dismisses the menu. (Will be undefined if rendering a command bar item.)\n   */\n  onRender?: (item: any, dismissMenu: (ev?: any, dismissAll?: boolean) => void) => React.ReactNode;\n\n  /**\n   * Method to customize sub-components rendering of this menu item.\n   *\n   * @param props - Props used to pass into render functions\n   * @param defaultRenders - Default render functions that renders default sub-components\n   */\n  onRenderContent?: (\n    props: IContextualMenuItemProps,\n    defaultRenders: IContextualMenuItemRenderFunctions,\n  ) => React.ReactNode;\n\n  /**\n   * A function to be executed on mouse down. This is executed before an `onClick` event and can\n   * be used to interrupt native on click events as well. The click event should still handle\n   * the commands. This should only be used in special cases when react and non-react are mixed.\n   */\n  onMouseDown?: (item: IContextualMenuItem, event: React.MouseEvent<HTMLElement>) => void;\n\n  /**\n   * Optional override for the menu button's role.\n   * @default `menuitem` or `menuitemcheckbox`\n   */\n  role?: string;\n\n  /**\n   * When rendering a custom menu component that is passed in, the component might also be a list of\n   * elements. We want to keep track of the correct index our menu is using based off of\n   * the length of the custom list. It is up to the user to increment the count for their list.\n   */\n  customOnRenderListLength?: number;\n\n  /**\n   * Keytip for this contextual menu item\n   */\n  keytipProps?: IKeytipProps;\n\n  /**\n   * @deprecated Use subMenuProps.items instead.\n   */\n  items?: IContextualMenuItem[];\n\n  /**\n   * Any additional properties to use when custom rendering menu items.\n   */\n  [propertyName: string]: any;\n\n  /**\n   * Detailed description of the menu item for the benefit of screen readers.\n   */\n  ariaDescription?: string;\n\n  /**\n   * ID of the element that contains additional detailed descriptive information for screen readers\n   */\n  ariaDescribedBy?: string;\n\n  /**\n   * @deprecated No longer used. All contextual menu items are now focusable when disabled.\n   */\n  inactive?: boolean;\n\n  /**\n   * Text of the menu item.\n   * @deprecated Use `text` instead.\n   */\n  name?: string;\n\n  /**\n   * Flag which indicates that, when the item is clicked, the 'target' for the click event should be\n   * overridden to reflect the launch target from the root menu.\n   * This avoids a situation where the 'target' of the event may wind up detached from the DOM\n   * when the menu is dismissed in response to the click.\n   */\n  preferMenuTargetAsEventTarget?: boolean;\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuSection extends React.ClassAttributes<any> {\n  /**\n   * The items to include inside the section.\n   */\n  items: IContextualMenuItem[];\n\n  /**\n   * The optional section title.\n   */\n  title?: string | IContextualMenuItem;\n\n  /**\n   * If set to true, the section will display a divider at the top of the section.\n   */\n  topDivider?: boolean;\n\n  /**\n   * If set to true, the section will display a divider at the bottom of the section.\n   */\n  bottomDivider?: boolean;\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IMenuItemStyles extends IButtonStyles {\n  /**\n   * Styles for a menu item that is an anchor link.\n   */\n  item?: IStyle;\n\n  /**\n   * Styles for the content inside the button/link of the menuItem.\n   */\n  linkContent?: IStyle;\n\n  /**\n   * Styles for a menu item that is an anchor link.\n   */\n  anchorLink?: IStyle;\n\n  /**\n   * Default icon color style for known icons.\n   */\n  iconColor?: IStyle;\n\n  /**\n   * Default style for checkmark icons.\n   */\n  checkmarkIcon?: IStyle;\n\n  /**\n   * Styles for the submenu icon of a menu item.\n   */\n  subMenuIcon?: IStyle;\n\n  /**\n   * Styles for a divider item of a ContextualMenu.\n   */\n  divider?: IStyle;\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuStyleProps {\n  theme: ITheme;\n\n  className?: string;\n\n  // Insert ContextualMenu style props below\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuStyles {\n  /**\n   * Style override for the contextual menu title.\n   */\n  title: IStyle;\n\n  /**\n   * Style for the container which parents all menu items.\n   */\n  container: IStyle;\n\n  /**\n   * Base styles for the root element of all ContextualMenus.\n   */\n  root: IStyle;\n\n  /**\n   * Styles for the header item of a ContextualMenu\n   */\n  header: IStyle;\n\n  /**\n   * Styles for the list that contains all menuItems.\n   */\n  list: IStyle;\n\n  /**\n   * SubComponent styles.\n   */\n  subComponentStyles: IContextualMenuSubComponentStyles;\n}\n\n/**\n * {@docCategory ContextualMenu}\n */\nexport interface IContextualMenuSubComponentStyles {\n  /** Styles for the callout that hosts the ContextualMenu options. */\n  callout: IStyleFunctionOrObject<ICalloutContentStyleProps, any>;\n\n  /** Styles for each menu item. */\n  menuItem: IStyleFunctionOrObject<IContextualMenuItemStyleProps, any>;\n}\n"]}