{"version":3,"file":"KeytipManager.js","sourceRoot":"../src/","sources":["utilities/keytips/KeytipManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventGroup, getId } from '../../Utilities';\nimport { KeytipEvents } from '../../utilities/keytips/KeytipConstants';\nimport type { IKeytipProps } from '../../Keytip';\n\nexport interface IUniqueKeytip {\n  uniqueID: string;\n  keytip: IKeytipProps;\n}\n\n/**\n * This class is responsible for handling registering, updating, and unregistering of keytips\n */\nexport class KeytipManager {\n  private static _instance: KeytipManager = new KeytipManager();\n\n  public keytips: { [key: string]: IUniqueKeytip } = {};\n  public persistedKeytips: { [key: string]: IUniqueKeytip } = {};\n  public sequenceMapping: { [key: string]: IKeytipProps } = {};\n\n  // This is (and should be) updated and kept in sync\n  // with the inKeytipMode in KeytipLayer.\n  public inKeytipMode = false;\n\n  // Boolean that gets checked before entering keytip mode by the KeytipLayer\n  // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)\n  public shouldEnterKeytipMode = true;\n\n  // Boolean to indicate whether to delay firing an event to update subscribers of\n  // keytip data changed.\n  public delayUpdatingKeytipChange = false;\n\n  /**\n   * Static function to get singleton KeytipManager instance\n   *\n   * @returns Singleton KeytipManager instance\n   */\n  public static getInstance(): KeytipManager {\n    return this._instance;\n  }\n\n  /**\n   * Initialization code to set set parameters to define\n   * how the KeytipManager handles keytip data.\n   *\n   * @param delayUpdatingKeytipChange - T/F if we should delay notifiying keytip subscribers\n   * of keytip changes\n   */\n  public init(delayUpdatingKeytipChange: boolean) {\n    this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;\n  }\n\n  /**\n   * Registers a keytip\n   *\n   * @param keytipProps - Keytip to register\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   * @returns Unique ID for this keytip\n   */\n  public register(keytipProps: IKeytipProps, persisted: boolean = false): string {\n    let props: IKeytipProps = keytipProps;\n    if (!persisted) {\n      // Add the overflowSetSequence if necessary\n      props = this.addParentOverflow(keytipProps);\n      this.sequenceMapping[props.keySequences.toString()] = props;\n    }\n    // Create a unique keytip\n    const uniqueKeytip: IUniqueKeytip = this._getUniqueKtp(props);\n    // Add to dictionary\n    persisted\n      ? (this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip)\n      : (this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip);\n\n    // We only want to add something new if we are currently showing keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;\n      EventGroup.raise(this, event, {\n        keytip: props,\n        uniqueID: uniqueKeytip.uniqueID,\n      });\n    }\n\n    return uniqueKeytip.uniqueID;\n  }\n\n  /**\n   * Update a keytip\n   *\n   * @param keytipProps - Keytip to update\n   * @param uniqueID - Unique ID of this keytip\n   */\n  public update(keytipProps: IKeytipProps, uniqueID: string): void {\n    const newKeytipProps = this.addParentOverflow(keytipProps);\n    const uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);\n    const oldKeyTip = this.keytips[uniqueID];\n    if (oldKeyTip) {\n      // Update everything except 'visible'\n      uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;\n      // Update keytip in this.keytips\n      this.keytips[uniqueID] = uniqueKeytip;\n\n      // Update the sequence to be up to date\n      delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];\n      this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;\n\n      // Raise event only if we are currently in keytip mode\n      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n        EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {\n          keytip: uniqueKeytip.keytip,\n          uniqueID: uniqueKeytip.uniqueID,\n        });\n      }\n    }\n  }\n\n  /**\n   * Unregisters a keytip\n   *\n   * @param keytipToRemove - IKeytipProps of the keytip to remove\n   * @param uniqueID - Unique ID of this keytip\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   */\n  public unregister(keytipToRemove: IKeytipProps, uniqueID: string, persisted: boolean = false): void {\n    persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];\n    !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];\n\n    const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;\n    // Update keytips only if we're in keytip mode\n    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {\n      EventGroup.raise(this, event, {\n        keytip: keytipToRemove,\n        uniqueID: uniqueID,\n      });\n    }\n  }\n\n  /**\n   * Manual call to enter keytip mode\n   */\n  public enterKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);\n  }\n\n  /**\n   * Manual call to exit keytip mode\n   */\n  public exitKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);\n  }\n\n  /**\n   * Gets all IKeytipProps from this.keytips\n   *\n   * @returns All keytips stored in the manager\n   */\n  public getKeytips(): IKeytipProps[] {\n    return Object.keys(this.keytips).map(key => this.keytips[key].keytip);\n  }\n\n  /**\n   * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it\n   *\n   * @param keytipProps - Keytip props to add overflowSetSequence to if necessary\n   * @returns - Modified keytip props, if needed to be modified\n   */\n  public addParentOverflow(keytipProps: IKeytipProps): IKeytipProps {\n    const fullSequence = [...keytipProps.keySequences];\n    fullSequence.pop();\n    if (fullSequence.length !== 0) {\n      const parentKeytip = this.sequenceMapping[fullSequence.toString()];\n      if (parentKeytip && parentKeytip.overflowSetSequence) {\n        return {\n          ...keytipProps,\n          overflowSetSequence: parentKeytip.overflowSetSequence,\n        };\n      }\n    }\n    return keytipProps;\n  }\n\n  /**\n   * Public function to bind for overflow items that have a submenu\n   */\n  public menuExecute(overflowButtonSequences: string[], keytipSequences: string[]) {\n    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {\n      overflowButtonSequences,\n      keytipSequences,\n    });\n  }\n\n  /**\n   * Creates an IUniqueKeytip object\n   *\n   * @param keytipProps - IKeytipProps\n   * @param uniqueID - Unique ID, will default to the next unique ID if not passed\n   * @returns IUniqueKeytip object\n   */\n  private _getUniqueKtp(keytipProps: IKeytipProps, uniqueID: string = getId()): IUniqueKeytip {\n    return { keytip: { ...keytipProps }, uniqueID };\n  }\n}\n"]}