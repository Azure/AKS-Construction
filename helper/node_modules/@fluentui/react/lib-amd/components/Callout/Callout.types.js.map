{"version":3,"file":"Callout.types.js","sourceRoot":"../src/","sources":["components/Callout/Callout.types.ts"],"names":[],"mappings":"","sourcesContent":["import * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { IStyle, ITheme } from '../../Styling';\nimport type { IRectangle, IStyleFunctionOrObject } from '../../Utilities';\nimport type { ICalloutPositionedInfo } from '../../Positioning';\nimport type { ILayerProps } from '../../Layer';\nimport type { IPopupProps } from '../../Popup';\nimport type { Target } from '@fluentui/react-hooks';\nimport type { IPopupRestoreFocusParams } from '../../Popup';\n\n/**\n * {@docCategory Callout}\n */\nexport interface ICalloutProps extends React.HTMLAttributes<HTMLDivElement>, React.RefAttributes<HTMLDivElement> {\n  /**\n   * The target that the Callout should try to position itself based on.\n   * It can be an element, a query selector string of a valid element,\n   * or a `MouseEvent`. If a `MouseEvent` is given, the origin point of the event will be used.\n   */\n  target?: Target;\n\n  /**\n   * How the element should be positioned\n   * @defaultvalue DirectionalHint.BottomAutoEdge\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of the `directionalHint` alignment edge will be used instead.\n   * This means that `DirectionalHint.BottomLeft` will change to `DirectionalHint.BottomRight` but\n   * `DirectionalHint.LeftAuto` will not change.\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * The gap between the Callout and the target, specified as number of pixels\n   * @defaultvalue 0\n   */\n  gapSpace?: number;\n\n  /**\n   * The width of the beak.\n   * @defaultvalue 16\n   */\n  beakWidth?: number;\n\n  /**\n   * Custom width for callout including borders. If value is 0, no width is applied.\n   * @defaultvalue 0\n   */\n  calloutWidth?: number;\n\n  /**\n   * Maximum width for callout including borders. If value is 0, no width is applied.\n   * @defaultvalue 0\n   */\n  calloutMaxWidth?: number;\n\n  /**\n   * Minimum width for callout including borders. If value is 0, no width is applied.\n   * @defaultvalue 0\n   */\n  calloutMinWidth?: number;\n\n  /**\n   * The background color of the Callout in hex format ie. #ffffff.\n   * @defaultvalue $ms-color-white\n   */\n  backgroundColor?: string;\n\n  /**\n   * The bounding rectangle the callout can appear in (or callback that returns a rectangle).\n   */\n  bounds?: IRectangle | ((target?: Target, targetWindow?: Window) => IRectangle | undefined);\n\n  /**\n   * The minimum distance the callout will be away from the edge of the screen.\n   *  @defaultvalue 8\n   */\n  minPagePadding?: number;\n\n  /**\n   * Whether the beak is visible.\n   * @defaultvalue true\n   */\n  isBeakVisible?: boolean;\n\n  /**\n   * If true then the callout will not dismiss on scroll\n   * @defaultvalue false\n   * @deprecated use preventDismissOnEvent callback instead\n   */\n  preventDismissOnScroll?: boolean;\n\n  /**\n   * If true then the callout will not dismiss on resize\n   * @defaultvalue false\n   * @deprecated use preventDismissOnEvent callback instead\n   */\n  preventDismissOnResize?: boolean;\n\n  /**\n   * If true then the callout will not dismiss when it loses focus\n   * @defaultvalue false\n   * @deprecated use preventDismissOnEvent callback instead\n   */\n  preventDismissOnLostFocus?: boolean;\n\n  /**\n   * If true then the callout will dismiss when the target element is clicked\n   * @defaultvalue false\n   */\n  dismissOnTargetClick?: boolean;\n\n  /**\n   * If defined, then takes priority over `preventDismissOnLostFocus`, `preventDismissOnResize`,\n   * and `preventDismissOnScroll`.\n   * If it returns true, the callout will not dismiss for this event.\n   * If not defined or returns false, the callout can dismiss for this event.\n   */\n  preventDismissOnEvent?: (ev: Event | React.FocusEvent | React.KeyboardEvent | React.MouseEvent) => boolean;\n\n  /**\n   * If true, callout will dismiss when the window gets focus.\n   * @defaultvalue false\n   */\n  shouldDismissOnWindowFocus?: boolean;\n\n  /**\n   * If true, the callout element will be positioned to cover the target.\n   * If false, it will position next to the target.\n   * @defaultvalue false\n   */\n  coverTarget?: boolean;\n\n  /**\n   * If true the positioning logic will prefer to flip edges rather than to nudge the rectangle to fit within bounds,\n   * thus making sure the element aligns perfectly with target's alignment edge.\n   */\n  alignTargetEdge?: boolean;\n\n  /**\n   * Aria role assigned to the callout (e.g. `dialog`, `alertdialog`).\n   */\n  role?: string;\n\n  /**\n   * Accessible label text for callout.\n   */\n  ariaLabel?: string;\n\n  /**\n   * ID of the element which contains label text for the callout.\n   */\n  ariaLabelledBy?: string;\n\n  /**\n   * ID of the element which contains the description for the callout.\n   */\n  ariaDescribedBy?: string;\n\n  /**\n   * CSS class to apply to the callout.\n   * @defaultvalue null\n   */\n  className?: string;\n\n  /**\n   * CSS style to apply to the callout.\n   *\n   * If you set `overflowY` in this object, it provides a performance optimization by preventing\n   * Popup (underlying component of Callout) from calculating whether it needs a scroll bar.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Optional callback when the layer content has mounted.\n   */\n  onLayerMounted?: () => void;\n\n  /**\n   * Optional props to pass to the Layer component hosting the callout.\n   */\n  layerProps?: ILayerProps;\n\n  /**\n   * Optional props to pass the Popup component that the callout uses.\n   */\n  popupProps?: IPopupProps;\n\n  /**\n   * Optional callback that is called once the callout has been correctly positioned.\n   * @param positions - Gives the user information about how the callout is positioned such as the\n   * final edge of the target that it positioned against, the beak position, and the beak's relationship to the\n   * edges of the callout.\n   */\n  onPositioned?: (positions?: ICalloutPositionedInfo) => void;\n\n  /**\n   * Callback when the Callout tries to close.\n   */\n  onDismiss?: (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => void;\n\n  /**\n   * If true, do not render on a new layer. If false, render on a new layer.\n   */\n  doNotLayer?: boolean;\n\n  /**\n   * If true the position will not change sides in an attempt to fit the callout within bounds.\n   * It will still attempt to align it to whatever bounds are given.\n   * @defaultvalue false\n   */\n  directionalHintFixed?: boolean;\n\n  /**\n   * Specify the final height of the content.\n   * To be used when expanding the content dynamically so that callout can adjust its position.\n   */\n  finalHeight?: number;\n\n  /**\n   * Manually set `overflowYHidden` style prop to true on `calloutMain` element.\n   * A variety of callout load animations will need this to hide the scollbar that can appear.\n   */\n  hideOverflow?: boolean;\n\n  /**\n   * If true, then the callout will attempt to focus the first focusable element that it contains.\n   * If it doesn't find a focusable element, no focus will be set.\n   */\n  setInitialFocus?: boolean;\n\n  /**\n   * Set max height of callout.\n   * When not set, the callout will expand with contents up to the bottom of the screen.\n   */\n  calloutMaxHeight?: number;\n\n  /**\n   * Callback when the Callout body is scrolled.\n   */\n  onScroll?: () => void;\n\n  /**\n   * Optional theme for component\n   */\n  theme?: ITheme;\n\n  /**\n   * Optional styles for the component.\n   */\n  styles?: IStyleFunctionOrObject<ICalloutContentStyleProps, ICalloutContentStyles>;\n\n  /**\n   * If specified, renders the Callout in a hidden state.\n   * Use this flag, rather than rendering a callout conditionally based on visibility,\n   * to improve rendering performance when it becomes visible.\n   * Note: When callout is hidden its content will not be rendered. It will only render\n   * once the callout is visible.\n   */\n  hidden?: boolean;\n\n  /**\n   * If true, the component will be updated even when `hidden` is true.\n   * Note that this would consume resources to update even though nothing is being shown to the user.\n   * This might be helpful though if your updates are small and you want the\n   * callout to be revealed quickly to the user when `hidden` is set to false.\n   */\n  shouldUpdateWhenHidden?: boolean;\n\n  /**\n   * If specified, determines whether the underlying {@link Popup} component should try to restore\n   * focus when it is dismissed.  When set to false, the Popup won't try to restore focus to\n   * the last focused element.\n   * @defaultvalue true\n   * @deprecated use `onRestoreFocus` instead\n   */\n  shouldRestoreFocus?: boolean;\n\n  /**\n   * Called when the component is unmounting, and focus needs to be restored. If this is provided,\n   * focus will not be restored automatically, and you'll need to call `params.originalElement.focus()`.\n   */\n  onRestoreFocus?: (params: IPopupRestoreFocusParams) => void;\n}\n\n/**\n * {@docCategory Callout}\n */\nexport interface ICalloutContentStyleProps {\n  /**\n   * Theme to apply to the callout content.\n   */\n  theme: ITheme;\n\n  /**\n   * Width for callout including borders.\n   */\n  calloutWidth?: number;\n\n  /**\n   * CSS class to apply to the callout.\n   */\n  className?: string;\n\n  /**\n   * Callout positioning data\n   */\n  positions?: ICalloutPositionedInfo;\n\n  /**\n   * Whether or not to clip content of the callout, if it overflows vertically.\n   */\n  overflowYHidden?: boolean;\n\n  /**\n   * Background color for the beak and callout.\n   */\n  backgroundColor?: string;\n\n  /**\n   * Width of Callout beak\n   */\n  beakWidth?: number;\n\n  /**\n   * Max width for callout including borders.\n   */\n  calloutMaxWidth?: number;\n\n  /**\n   * Min width for callout including borders.\n   */\n  calloutMinWidth?: number;\n\n  /**\n   * If true, a z-index should be set on the root element (since the Callout will not be rendered on a new layer).\n   */\n  doNotLayer?: boolean;\n}\n\n/**\n * {@docCategory Callout}\n */\nexport interface ICalloutContentStyles {\n  /**\n   * Style for wrapper of Callout component.\n   */\n  container: IStyle;\n\n  /**\n   * Style for callout container root element.\n   */\n  root: IStyle;\n\n  /**\n   * Style for callout beak.\n   */\n  beak: IStyle;\n\n  /**\n   * Style for callout beak curtain.\n   */\n  beakCurtain: IStyle;\n\n  /**\n   * Style for content component of the callout.\n   */\n  calloutMain: IStyle;\n}\n\nexport type { Target };\n"]}