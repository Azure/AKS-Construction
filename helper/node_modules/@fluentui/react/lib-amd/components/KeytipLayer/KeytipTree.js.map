{"version":3,"file":"KeytipTree.js","sourceRoot":"../src/","sources":["components/KeytipLayer/KeytipTree.ts"],"names":[],"mappings":"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","sourcesContent":["import { find, isElementVisibleAndNotHidden, values } from '../../Utilities';\nimport { ktpTargetFromSequences, mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\nimport type { IKeytipProps } from '../../Keytip';\nimport type { IKeytipTreeNode } from './IKeytipTreeNode';\n\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\nexport class KeytipTree {\n  public currentKeytip?: IKeytipTreeNode;\n  public root: IKeytipTreeNode;\n  public nodeMap: { [nodeId: string]: IKeytipTreeNode } = {};\n\n  /**\n   * KeytipTree constructor\n   */\n  constructor() {\n    // Root has no keytipSequence\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: [],\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n  public addNode(keytipProps: IKeytipProps, uniqueID: string, persisted?: boolean): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n\n    // Create node and add to map\n    const node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n    this.nodeMap[uniqueID] = node;\n\n    // Try to add self to parents children\n    const parents = this.getNodes([parentID]);\n    parents.forEach(parent => parent.children.push(nodeID));\n  }\n\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n  public updateNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n    const node = this.nodeMap[uniqueID];\n    const prevParent = node.parent;\n    if (node) {\n      // Fix parent nodes if needed\n      if (prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        this._removeChildFromParents(prevParent, node.id);\n      }\n      if (node.id !== nodeID) {\n        // If the ID of the node has changed, update node's parent's array of children with new ID\n        const parents = this.getNodes([parentID]);\n        parents.forEach(parent => {\n          const index = parent.children.indexOf(node.id);\n          index >= 0 ? (parent.children[index] = nodeID) : parent.children.push(nodeID);\n        });\n      }\n\n      // Update values\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  }\n\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n  public removeNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last sequence to calculate the parent ID\n    fullSequence.pop();\n\n    // Parent ID is the root if there aren't any more sequences\n    this._removeChildFromParents(this._getParentID(fullSequence), nodeID);\n\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  }\n\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n  public getExactMatchedNode(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode | undefined {\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    const matchingNodes = possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n\n    // If we found no nodes, we are done\n    if (matchingNodes.length === 0) {\n      return undefined;\n    }\n\n    // Since the matching nodes all have the same key sequence,\n    // Grab the first one build the correct selector\n    const node = matchingNodes[0];\n\n    // If we have exactly one node, return it\n    if (matchingNodes.length === 1) {\n      return node;\n    }\n\n    // Get the potential target elements based on a selector from the sequences\n    const keySequences = node.keySequences;\n    const overflowSetSequence = node.overflowSetSequence;\n    const fullKeySequences = overflowSetSequence ? mergeOverflows(keySequences, overflowSetSequence) : keySequences;\n    const keytipTargetSelector = ktpTargetFromSequences(fullKeySequences);\n    const potentialTargetElements = document.querySelectorAll(keytipTargetSelector);\n\n    // If we have less nodes than the potential target elements,\n    // we won't be able to map element to node, return the first node.\n    // Note, the number of nodes could be more than the number of potential\n    // target elements, if an OverflowSet is involved\n    if (matchingNodes.length < potentialTargetElements.length) {\n      return node;\n    }\n\n    // Attempt to find the node that corresponds to the first visible/non-hidden element\n    const matchingIndex = Array.from(potentialTargetElements).findIndex((element: HTMLElement) =>\n      isElementVisibleAndNotHidden(element),\n    );\n    if (matchingIndex !== -1) {\n      return matchingNodes[matchingIndex];\n    }\n\n    // We did not find any visible elements associated with any of the nodes.\n    // We may be dealing with a keytip that is a submenu in an OverflowSet.\n    // Worst case, fall back to the first node returned\n    const overflowNode = matchingNodes.find(matchingNode => matchingNode.hasOverflowSubMenu);\n    return overflowNode || node;\n  }\n\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n  public getPartiallyMatchedNodes(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode[] {\n    // Get children that are persisted\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  }\n\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n  public getChildren(node?: IKeytipTreeNode): string[] {\n    if (!node) {\n      node = this.currentKeytip;\n      if (!node) {\n        return [];\n      }\n    }\n    const children = node.children;\n    return Object.keys(this.nodeMap).reduce((nodes: string[], key: string): string[] => {\n      if (children.indexOf(this.nodeMap[key].id) >= 0 && !this.nodeMap[key].persisted) {\n        nodes.push(this.nodeMap[key].id);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n  public getNodes(ids: string[]): IKeytipTreeNode[] {\n    return Object.keys(this.nodeMap).reduce((nodes: IKeytipTreeNode[], key: string): IKeytipTreeNode[] => {\n      if (ids.indexOf(this.nodeMap[key].id) >= 0) {\n        nodes.push(this.nodeMap[key]);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n  public getNode(id: string): IKeytipTreeNode | undefined {\n    const nodeMapValues = values<IKeytipTreeNode>(this.nodeMap);\n    return find(nodeMapValues, (node: IKeytipTreeNode): boolean => {\n      return node.id === id;\n    });\n  }\n\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n  public isCurrentKeytipParent(keytipProps: IKeytipProps): boolean {\n    if (this.currentKeytip) {\n      let fullSequence = [...keytipProps.keySequences];\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      }\n      // Take off the last sequence to calculate the parent ID\n      fullSequence.pop();\n      // Parent ID is the root if there aren't any more sequences\n      const parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      let matchesCurrWithoutOverflow = false;\n      if (this.currentKeytip.overflowSetSequence) {\n        const currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n    return false;\n  }\n\n  private _getParentID(fullSequence: string[]): string {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  }\n\n  private _getFullSequence(keytipProps: IKeytipProps): string[] {\n    let fullSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n    return fullSequence;\n  }\n\n  private _getNodeSequence(node: IKeytipTreeNode): string {\n    let fullSequence = [...node.keySequences];\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n    return fullSequence[fullSequence.length - 1];\n  }\n\n  private _createNode(\n    id: string,\n    parentId: string,\n    children: string[],\n    keytipProps: IKeytipProps,\n    persisted?: boolean,\n  ): IKeytipTreeNode {\n    const {\n      keySequences,\n      hasDynamicChildren,\n      overflowSetSequence,\n      hasMenu,\n      onExecute,\n      onReturn,\n      disabled,\n      hasOverflowSubMenu,\n    } = keytipProps;\n    const node = {\n      id,\n      keySequences,\n      overflowSetSequence,\n      parent: parentId,\n      children,\n      onExecute,\n      onReturn,\n      hasDynamicChildren,\n      hasMenu,\n      disabled,\n      persisted,\n      hasOverflowSubMenu,\n    };\n    node.children = Object.keys(this.nodeMap).reduce((array: string[], nodeMapKey: string): string[] => {\n      if (this.nodeMap[nodeMapKey].parent === id) {\n        array.push(this.nodeMap[nodeMapKey].id);\n      }\n      return array;\n    }, []);\n    return node;\n  }\n\n  private _removeChildFromParents(parentID: string, childID: string): void {\n    const parents = this.getNodes([parentID]);\n    parents.forEach(parent => {\n      const childIndex = parent.children.indexOf(childID);\n      if (childIndex >= 0) {\n        parent.children.splice(childIndex, 1);\n      }\n    });\n  }\n}\n"]}