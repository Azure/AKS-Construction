{"version":3,"file":"FocusTrapZone.js","sourceRoot":"../src/","sources":["components/FocusTrapZone/FocusTrapZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  focusAsync,\n  getPropsWithDefaults,\n  modalize,\n  on,\n} from '../../Utilities';\nimport { useId, useConst, useMergedRefs, useEventCallback, usePrevious, useUnmount } from '@fluentui/react-hooks';\nimport { useDocument } from '../../WindowProvider';\nimport type { IRefObject } from '../../Utilities';\nimport type { IFocusTrapZoneProps, IFocusTrapZone } from './FocusTrapZone.types';\n\ninterface IFocusTrapZoneInternalState {\n  previouslyFocusedElementInTrapZone?: HTMLElement;\n  hasFocus: boolean;\n  /** ID tracked in focusStack. Don't respect prop updates in case the ID changes while the FTZ is active. */\n  focusStackId: string;\n}\n\nconst COMPONENT_NAME = 'FocusTrapZone';\n\nconst DEFAULT_PROPS = {\n  disabled: false,\n  disableFirstFocus: false,\n  forceFocusInsideTrap: true,\n  isClickableOutsideFocusTrap: false,\n};\n\nconst useComponentRef = (\n  componentRef: IRefObject<IFocusTrapZone> | undefined,\n  previouslyFocusedElement: HTMLElement | undefined,\n  focusFTZ: () => void,\n) => {\n  React.useImperativeHandle(\n    componentRef,\n    () => ({\n      get previouslyFocusedElement() {\n        return previouslyFocusedElement;\n      },\n      focus: focusFTZ,\n    }),\n    [focusFTZ, previouslyFocusedElement],\n  );\n};\n\nexport const FocusTrapZone: React.FunctionComponent<IFocusTrapZoneProps> & {\n  /**\n   * Stack of active FocusTrapZone identifiers, exposed for testing purposes only.\n   * (This is always set, just marked as optional to avoid a cast in the component definition.)\n   * @internal\n   */\n  focusStack?: string[];\n} = React.forwardRef<HTMLDivElement, IFocusTrapZoneProps>((propsWithoutDefaults, ref) => {\n  const root = React.useRef<HTMLDivElement>(null);\n  const firstBumper = React.useRef<HTMLDivElement>(null);\n  const lastBumper = React.useRef<HTMLDivElement>(null);\n  const mergedRootRef = useMergedRefs(root, ref) as React.Ref<HTMLDivElement>;\n  const doc = useDocument();\n\n  const isFirstRender = usePrevious(false) ?? true;\n\n  const props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);\n\n  const internalState = useConst<IFocusTrapZoneInternalState>({\n    hasFocus: false,\n    focusStackId: useId('ftz-', props.id),\n  });\n\n  const {\n    children,\n    componentRef,\n    disabled,\n    disableFirstFocus,\n    forceFocusInsideTrap,\n    focusPreviouslyFocusedInnerElement,\n    // eslint-disable-next-line deprecation/deprecation\n    firstFocusableSelector,\n    firstFocusableTarget,\n    // eslint-disable-next-line deprecation/deprecation\n    disableRestoreFocus = props.ignoreExternalFocusing,\n    isClickableOutsideFocusTrap,\n    enableAriaHiddenSiblings,\n  } = props;\n\n  const bumperProps = {\n    'aria-hidden': true,\n    style: {\n      pointerEvents: 'none',\n      position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n    },\n    tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n    'data-is-visible': true,\n    'data-is-focus-trap-zone-bumper': true,\n  } as React.HTMLAttributes<HTMLDivElement>;\n\n  const focusElementAsync = React.useCallback((element: HTMLElement) => {\n    if (element !== firstBumper.current && element !== lastBumper.current) {\n      focusAsync(element);\n    }\n  }, []);\n\n  /**\n   * Callback to force focus into FTZ (named to avoid overlap with global focus() callback).\n   * useEventCallback always returns the same callback reference but updates the implementation\n   * every render to avoid stale captured values.\n   */\n  const focusFTZ = useEventCallback(() => {\n    if (!root.current) {\n      return; // not done mounting\n    }\n\n    const { previouslyFocusedElementInTrapZone } = internalState;\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      previouslyFocusedElementInTrapZone &&\n      elementContains(root.current, previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusElementAsync(previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    let firstFocusableChild: HTMLElement | null = null;\n\n    if (typeof firstFocusableTarget === 'string') {\n      firstFocusableChild = root.current.querySelector(firstFocusableTarget);\n    } else if (firstFocusableTarget) {\n      firstFocusableChild = firstFocusableTarget(root.current);\n    } else if (firstFocusableSelector) {\n      const focusSelector =\n        typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector();\n      firstFocusableChild = root.current.querySelector('.' + focusSelector);\n    }\n\n    // Fall back to first element if query selector did not match any elements.\n    if (!firstFocusableChild) {\n      firstFocusableChild = getNextElement(\n        root.current,\n        root.current.firstChild as HTMLElement,\n        false,\n        false,\n        false,\n        true,\n      );\n    }\n\n    if (firstFocusableChild) {\n      focusElementAsync(firstFocusableChild);\n    }\n  });\n\n  /** Used in root div focus/blur handlers */\n  const focusBumper = (isFirstBumper: boolean) => {\n    if (disabled || !root.current) {\n      return;\n    }\n\n    const nextFocusable =\n      isFirstBumper === internalState.hasFocus\n        ? getLastTabbable(root.current, lastBumper.current!, true, false)\n        : getFirstTabbable(root.current, firstBumper.current!, true, false);\n\n    if (nextFocusable) {\n      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {\n        // This can happen when FTZ contains no tabbable elements.\n        // focusFTZ() will take care of finding a focusable element in FTZ.\n        focusFTZ();\n      } else {\n        nextFocusable.focus();\n      }\n    }\n  };\n\n  /** Root div blur handler (doesn't need useCallback since it's for a native element) */\n  const onRootBlurCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    props.onBlurCapture?.(ev);\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the root\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = doc!.activeElement as Element;\n    }\n    if (!elementContains(root.current, relatedTarget as HTMLElement)) {\n      internalState.hasFocus = false;\n    }\n  };\n\n  /** Root div focus handler (doesn't need useCallback since it's for a native element) */\n  const onRootFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    props.onFocusCapture?.(ev);\n\n    if (ev.target === firstBumper.current) {\n      focusBumper(true);\n    } else if (ev.target === lastBumper.current) {\n      focusBumper(false);\n    }\n\n    internalState.hasFocus = true;\n\n    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      internalState.previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  /** Called to restore focus on unmount or props change. (useEventCallback ensures latest prop values are used.) */\n  const returnFocusToInitiator = useEventCallback((elementToFocusOnDismiss: HTMLElement | null) => {\n    FocusTrapZone.focusStack = FocusTrapZone.focusStack!.filter(value => internalState.focusStackId !== value);\n\n    if (!doc) {\n      return;\n    }\n\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !disableRestoreFocus &&\n      typeof elementToFocusOnDismiss?.focus === 'function' &&\n      // only restore focus if the current focused element is within the FTZ, or if nothing is focused\n      (elementContains(root.current, activeElement) || activeElement === doc.body)\n    ) {\n      focusElementAsync(elementToFocusOnDismiss);\n    }\n  });\n\n  /** Called in window event handlers. (useEventCallback ensures latest prop values are used.) */\n  const forceFocusOrClickInTrap = useEventCallback((ev: FocusEvent | MouseEvent): void => {\n    // be sure to use the latest values here\n    if (disabled) {\n      return;\n    }\n    if (internalState.focusStackId === FocusTrapZone.focusStack!.slice(-1)[0]) {\n      const targetElement = ev.target as HTMLElement | null;\n      if (targetElement && !elementContains(root.current, targetElement)) {\n        if (doc && doc.activeElement === doc.body) {\n          setTimeout(() => {\n            if (doc && doc.activeElement === doc.body) {\n              focusFTZ();\n              internalState.hasFocus = true; // set focus here since we stop event propagation\n            }\n          }, 0);\n        } else {\n          focusFTZ();\n          internalState.hasFocus = true; // set focus here since we stop event propagation\n        }\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  });\n\n  // Update window event handlers when relevant props change\n  React.useEffect(() => {\n    const disposables: Array<() => void> = [];\n\n    if (forceFocusInsideTrap) {\n      disposables.push(on(window, 'focus', forceFocusOrClickInTrap, true));\n    }\n    if (!isClickableOutsideFocusTrap) {\n      disposables.push(on(window, 'click', forceFocusOrClickInTrap, true));\n    }\n\n    return () => {\n      disposables.forEach(dispose => dispose());\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap]);\n\n  // On prop change or first render, focus the FTZ and update focusStack if appropriate\n  React.useEffect(() => {\n    // Do nothing if disabled, or if it's a re-render and forceFocusInsideTrap is false\n    // (to match existing behavior, the FTZ handles first focus even if forceFocusInsideTrap\n    // is false, though it's debatable whether it should do this)\n    if (disabled || (!isFirstRender && !forceFocusInsideTrap) || !root.current) {\n      return;\n    }\n\n    // Transition from forceFocusInsideTrap / FTZ disabled to enabled (or initial mount)\n    FocusTrapZone.focusStack!.push(internalState.focusStackId);\n\n    const elementToFocusOnDismiss = props.elementToFocusOnDismiss || (doc!.activeElement as HTMLElement | null);\n\n    if (!disableFirstFocus && !elementContains(root.current, elementToFocusOnDismiss)) {\n      focusFTZ();\n    }\n\n    // To match existing behavior, always return focus on cleanup (even if we didn't handle\n    // initial focus), but it's debatable whether that's correct\n    return () => returnFocusToInitiator(elementToFocusOnDismiss);\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when these two props change\n  }, [forceFocusInsideTrap, disabled]);\n\n  // Handle modalization separately from first focus\n  React.useEffect(() => {\n    if (!disabled && enableAriaHiddenSiblings) {\n      const unmodalize = modalize(root.current!);\n      return unmodalize;\n    }\n  }, [disabled, enableAriaHiddenSiblings, root]);\n\n  // Cleanup lifecyle method for internalState.\n  useUnmount(() => {\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete internalState.previouslyFocusedElementInTrapZone;\n  });\n\n  useComponentRef(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);\n\n  return (\n    <div\n      // this is above the native props spread so props['aria-labelledby'] will override it if provided\n      aria-labelledby={props.ariaLabelledBy}\n      // native props include onFocus, onBlur, className\n      {...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties)}\n      ref={mergedRootRef}\n      onFocusCapture={onRootFocusCapture}\n      onBlurCapture={onRootBlurCapture}\n    >\n      <div {...bumperProps} ref={firstBumper} />\n      {children}\n      <div {...bumperProps} ref={lastBumper} />\n    </div>\n  );\n});\n\nFocusTrapZone.displayName = COMPONENT_NAME;\nFocusTrapZone.focusStack = [];\n"]}