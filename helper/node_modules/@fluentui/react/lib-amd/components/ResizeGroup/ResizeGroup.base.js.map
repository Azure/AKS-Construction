{"version":3,"file":"ResizeGroup.base.js","sourceRoot":"../src/","sources":["components/ResizeGroup/ResizeGroup.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Async, divProperties, getNativeProps } from '../../Utilities';\nimport { ResizeGroupDirection } from './ResizeGroup.types';\nimport { useConst, useMergedRefs, useAsync, useOnEvent, useWarnings } from '@fluentui/react-hooks';\nimport { useWindow } from '../../WindowProvider';\nimport type { IResizeGroupProps } from './ResizeGroup.types';\n\nconst RESIZE_DELAY = 16;\n\nexport interface IResizeGroupState {\n  /**\n   * Final data used to render proper sized component\n   */\n  renderedData?: any;\n\n  /**\n   * Data to render in a hidden div for measurement\n   */\n  dataToMeasure?: any;\n\n  /**\n   * Set to true when the content container might have new dimensions and should\n   * be remeasured.\n   */\n  measureContainer?: boolean;\n\n  /**\n   * Are we resizing to accommodate having more or less available space?\n   * The 'grow' direction is when the container may have more room than the last render,\n   * such as when a window resize occurs. This means we will try to fit more content in the window.\n   * The 'shrink' direction is when the contents don't fit in the container and we need\n   * to find a transformation of the data that makes everything fit.\n   */\n  resizeDirection?: 'grow' | 'shrink';\n}\n\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\nexport const getMeasurementCache = () => {\n  const measurementsCache: { [key: string]: number } = {};\n\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: (data: any): number | undefined => {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: (data: any, measurement: number): void => {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    },\n  };\n};\n\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\n  const _measurementCache = measurementCache;\n  let _containerDimension: number | undefined;\n\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _getMeasuredDimension(measuredData: any, getElementToMeasureDimension: () => number): number {\n    const cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    const measuredDimension = getElementToMeasureDimension();\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n    return measuredDimension;\n  }\n\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _shrinkContentsUntilTheyFit(\n    data: any,\n    onReduceData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension!) {\n      const nextMeasuredData = onReduceData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink',\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined,\n    };\n  }\n\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _growDataUntilItDoesNotFit(\n    data: any,\n    onGrowData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n    onReduceData: (prevData: any) => any,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension!) {\n      const nextMeasuredData = onGrowData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to re-render with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    // Once the loop is done, we should now shrink until the contents fit.\n    return {\n      resizeDirection: 'shrink',\n      ..._shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension),\n    };\n  }\n\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n  function _updateContainerDimension(\n    newDimension: number,\n    fullDimensionData: any,\n    renderedData: any,\n    onGrowData?: (prevData: any) => any,\n  ): IResizeGroupState {\n    let nextState: IResizeGroupState;\n    if (newDimension > _containerDimension!) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData),\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData,\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData,\n      };\n    }\n    _containerDimension = newDimension;\n    return { ...nextState, measureContainer: false };\n  }\n\n  function getNextState(\n    props: IResizeGroupProps,\n    currentState: IResizeGroupState,\n    getElementToMeasureDimension: () => number,\n    newContainerDimension?: number,\n  ): IResizeGroupState | undefined {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return {\n          ...currentState,\n          ..._updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData),\n        };\n      }\n\n      // If we are just setting the container width/height for the first time, we can't do any optimizations\n      _containerDimension = newContainerDimension;\n    }\n\n    let nextState: IResizeGroupState = {\n      ...currentState,\n      measureContainer: false,\n    };\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = {\n          ...nextState,\n          ..._growDataUntilItDoesNotFit(\n            currentState.dataToMeasure,\n            props.onGrowData,\n            getElementToMeasureDimension,\n            props.onReduceData,\n          ),\n        };\n      } else {\n        nextState = {\n          ...nextState,\n          ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension),\n        };\n      }\n    }\n\n    return nextState;\n  }\n\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n  function shouldRenderDataForMeasurement(dataToMeasure: any | undefined): boolean {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data: any): IResizeGroupState {\n    return {\n      dataToMeasure: { ...data },\n      resizeDirection: 'grow',\n      measureContainer: true,\n    };\n  }\n\n  return {\n    getNextState,\n    shouldRenderDataForMeasurement,\n    getInitialResizeGroupState,\n  };\n};\n\n// Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\nexport const MeasuredContext = React.createContext({ isMeasured: false });\n\n// Styles for the hidden div used for measurement\nconst hiddenDivStyles: React.CSSProperties = { position: 'fixed', visibility: 'hidden' };\nconst hiddenParentStyles: React.CSSProperties = { position: 'relative' };\nconst COMPONENT_NAME = 'ResizeGroup';\n\ntype ResizeDataAction = {\n  type: 'resizeData' | keyof IResizeGroupState;\n  value: IResizeGroupState[keyof IResizeGroupState] | IResizeGroupState;\n};\n\n/**\n * Use useReducer instead of userState because React is not batching the state updates\n * when state is set in callbacks of setTimeout or requestAnimationFrame.\n * See issue: https://github.com/facebook/react/issues/14259\n */\nfunction resizeDataReducer(state: IResizeGroupState, action: ResizeDataAction): IResizeGroupState {\n  switch (action.type) {\n    case 'resizeData':\n      return { ...action.value };\n    case 'dataToMeasure':\n      return { ...state, dataToMeasure: action.value, resizeDirection: 'grow', measureContainer: true };\n    default:\n      return { ...state, [action.type]: action.value };\n  }\n}\n\nfunction useResizeState(\n  props: IResizeGroupProps,\n  nextResizeGroupStateProvider: ReturnType<typeof getNextResizeGroupStateProvider>,\n  rootRef: React.RefObject<HTMLDivElement | null>,\n) {\n  const initialStateData = useConst(() => nextResizeGroupStateProvider.getInitialResizeGroupState(props.data));\n  const [resizeData, dispatchResizeDataAction] = React.useReducer(resizeDataReducer, initialStateData);\n\n  // Reset state when new data is provided\n  React.useEffect(() => {\n    dispatchResizeDataAction({\n      type: 'dataToMeasure',\n      value: props.data,\n    });\n  }, [props.data]);\n\n  // Because it's possible that we may force more than one re-render per animation frame, we\n  // want to make sure that the RAF request is using the most recent data.\n  const stateRef = React.useRef<IResizeGroupState>(initialStateData);\n  stateRef.current = { ...resizeData };\n\n  const updateResizeState = React.useCallback((nextState?: IResizeGroupState) => {\n    if (nextState) {\n      dispatchResizeDataAction({\n        type: 'resizeData',\n        value: nextState,\n      });\n    }\n  }, []);\n\n  const remeasure: () => void = React.useCallback(() => {\n    if (rootRef.current) {\n      dispatchResizeDataAction({\n        type: 'measureContainer',\n        value: true,\n      });\n    }\n  }, [rootRef]);\n\n  return [stateRef, updateResizeState, remeasure] as const;\n}\n\nfunction useResizingBehavior(props: IResizeGroupProps, rootRef: React.RefObject<HTMLDivElement | null>) {\n  const nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider);\n\n  // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n  // of the component being measured for the initial render.\n  const initialHiddenDiv = React.useRef<HTMLDivElement | null>(null);\n  // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n  // div without unmounting the currently visible content.\n  const updateHiddenDiv = React.useRef<HTMLDivElement | null>(null);\n\n  // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n  // for the initial render.\n  const hasRenderedContent = React.useRef(false);\n\n  const async: Async = useAsync();\n\n  const [stateRef, updateResizeState, remeasure] = useResizeState(props, nextResizeGroupStateProvider, rootRef);\n\n  React.useEffect(() => {\n    if (stateRef.current.renderedData) {\n      hasRenderedContent.current = true;\n      props.dataDidRender?.(stateRef.current.renderedData);\n    }\n  });\n\n  React.useEffect((): void => {\n    async.requestAnimationFrame(() => {\n      let containerDimension = undefined;\n      if (stateRef.current.measureContainer && rootRef.current) {\n        const boundingRect = rootRef.current.getBoundingClientRect();\n        containerDimension =\n          props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n      const nextState = nextResizeGroupStateProvider.getNextState(\n        props,\n        stateRef.current,\n        () => {\n          const refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;\n          if (!refToMeasure.current) {\n            return 0;\n          }\n          const measuredBoundingRect = refToMeasure.current.getBoundingClientRect();\n          return props.direction === ResizeGroupDirection.vertical\n            ? measuredBoundingRect.height\n            : measuredBoundingRect.width;\n        },\n        containerDimension,\n      );\n\n      updateResizeState(nextState);\n    }, rootRef.current);\n  });\n\n  const win = useWindow();\n  useOnEvent(win, 'resize', async.debounce(remeasure, RESIZE_DELAY, { leading: true }));\n\n  const dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(\n    stateRef.current.dataToMeasure,\n  );\n\n  const isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;\n\n  return [\n    stateRef.current.dataToMeasure,\n    stateRef.current.renderedData,\n    remeasure,\n    initialHiddenDiv,\n    updateHiddenDiv,\n    dataNeedsMeasuring,\n    isInitialMeasure,\n  ] as const;\n}\n\nfunction useDebugWarnings(props: IResizeGroupProps) {\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks -- build-time conditional\n    useWarnings({\n      name: COMPONENT_NAME,\n      props,\n      deprecations: { styles: 'className' },\n    });\n  }\n}\n\nconst measuredContextValue = { isMeasured: true };\n\nexport const ResizeGroupBase: React.FunctionComponent<IResizeGroupProps> = React.forwardRef<\n  HTMLDivElement,\n  IResizeGroupProps\n>((props, forwardedRef) => {\n  const rootRef = React.useRef<HTMLDivElement | null>(null);\n  // The root div which is the container inside of which we are trying to fit content.\n  const mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n\n  const [\n    dataToMeasure,\n    renderedData,\n    remeasure,\n    initialHiddenDiv,\n    updateHiddenDiv,\n    dataNeedsMeasuring,\n    isInitialMeasure,\n  ] = useResizingBehavior(props, rootRef);\n\n  React.useImperativeHandle(props.componentRef, () => ({ remeasure }), [remeasure]);\n\n  useDebugWarnings(props);\n\n  const { className, onRenderData } = props;\n  const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, divProperties, ['data']);\n\n  // We only ever render the final content to the user. All measurements are done in a hidden div.\n  // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n  // version of the component for measurement and the final render. For renders that update what is on screen, we\n  // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n  // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n  // leave the rendered content untouched until we know the next state to show to the user.\n  return (\n    <div {...divProps} className={className} ref={mergedRootRef}>\n      <div style={hiddenParentStyles}>\n        {dataNeedsMeasuring && !isInitialMeasure && (\n          <div style={hiddenDivStyles} ref={updateHiddenDiv}>\n            <MeasuredContext.Provider value={measuredContextValue}>\n              {onRenderData(dataToMeasure)}\n            </MeasuredContext.Provider>\n          </div>\n        )}\n\n        <div\n          ref={initialHiddenDiv}\n          style={isInitialMeasure ? hiddenDivStyles : undefined}\n          data-automation-id=\"visibleContent\"\n        >\n          {isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)}\n        </div>\n      </div>\n    </div>\n  );\n});\nResizeGroupBase.displayName = 'ResizeGroupBase';\n"]}