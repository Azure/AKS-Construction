{"version":3,"file":"useOverflow.js","sourceRoot":"../src/","sources":["utilities/useOverflow.ts"],"names":[],"mappings":";;;;IAoCA;;;;;;;;;;;;;;;;;OAiBG;IACI,IAAM,WAAW,GAAG,UAAC,EAA4D;YAA1D,sBAAsB,4BAAA,EAAE,GAAG,SAAA,EAAE,WAAW,iBAAA;QACpE,IAAM,iBAAiB,GAAG,KAAK,CAAC,MAAM,EAAc,CAAC;QACrD,IAAM,iBAAiB,GAAG,KAAK,CAAC,MAAM,EAAU,CAAC;QAEjD,4CAA4C;QAC5C,IAAM,YAAY,GAAG,0BAAY,CAAc,UAAA,SAAS;YACtD,IAAM,eAAe,GAAG,6BAAa,CAAC,SAAS,EAAE,UAAA,OAAO;gBACtD,iBAAiB,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC;gBAC3F,IAAI,iBAAiB,CAAC,OAAO,EAAE;oBAC7B,iBAAiB,CAAC,OAAO,EAAE,CAAC;iBAC7B;YACH,CAAC,CAAC,CAAC;YAEH,OAAO;gBACL,eAAe,EAAE,CAAC;gBAClB,iBAAiB,CAAC,OAAO,GAAG,SAAS,CAAC;YACxC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,IAAM,aAAa,GAAG,0BAAY,CAAc,UAAA,UAAU;YACxD,YAAY,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;YACvC,OAAO,cAAM,OAAA,YAAY,CAAC,IAAI,CAAC,EAAlB,CAAkB,CAAC;QAClC,CAAC,CAAC,CAAC;QAEH,uCAAyB,CAAC;YACxB,IAAM,SAAS,GAAG,YAAY,CAAC,OAAO,CAAC;YACvC,IAAM,UAAU,GAAG,aAAa,CAAC,OAAO,CAAC;YACzC,IAAI,CAAC,SAAS,IAAI,CAAC,UAAU,EAAE;gBAC7B,OAAO;aACR;YAED,qFAAqF;YACrF,IAAM,KAAK,GAAkB,EAAE,CAAC;YAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAClD,IAAM,IAAI,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACnC,IAAI,IAAI,YAAY,WAAW,IAAI,IAAI,KAAK,UAAU,EAAE;oBACtD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAClB;aACF;YAED,4EAA4E;YAC5E,2GAA2G;YAC3G,0GAA0G;YAC1G,IAAM,iBAAiB,GAAa,EAAE,CAAC;YACvC,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC,mEAAmE;YAEvF,iBAAiB,CAAC,OAAO,GAAG;gBAC1B,IAAM,cAAc,GAAG,iBAAiB,CAAC,OAAO,CAAC;gBACjD,IAAI,cAAc,KAAK,SAAS,EAAE;oBAChC,OAAO;iBACR;gBAED,oGAAoG;gBACpG,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;oBAC1C,4EAA4E;oBAC5E,IAAI,iBAAiB,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;wBACtC,IAAM,aAAa,GAAG,GAAG,CAAC,CAAC,CAAC,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;wBAE9G,6DAA6D;wBAC7D,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,KAAK,WAAW,EAAE;4BACjD,kFAAkF;4BAClF,2EAA2E;4BAC3E,UAAU,GAAG,iBAAiB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa,CAAC;yBACvD;wBAED,mFAAmF;wBACnF,IAAI,CAAC,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;4BAC1B,UAAU,IAAI,UAAU,CAAC,WAAW,CAAC;yBACtC;wBAED,iBAAiB,CAAC,CAAC,CAAC,GAAG,aAAa,GAAG,UAAU,CAAC;qBACnD;oBAED,IAAI,cAAc,GAAG,iBAAiB,CAAC,CAAC,CAAC,EAAE;wBACzC,gBAAgB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBACxB,OAAO;qBACR;iBACF;gBAED,oDAAoD;gBACpD,gBAAgB,CAAC,CAAC,CAAC,CAAC;YACtB,CAAC,CAAC;YAEF,IAAI,iBAAiB,GAAG,KAAK,CAAC,MAAM,CAAC;YACrC,IAAM,gBAAgB,GAAG,UAAC,aAAqB;gBAC7C,IAAI,iBAAiB,KAAK,aAAa,EAAE;oBACvC,iBAAiB,GAAG,aAAa,CAAC;oBAClC,sBAAsB,CACpB,aAAa,EACb,KAAK,CAAC,GAAG,CAAC,UAAC,GAAG,EAAE,KAAK,IAAK,OAAA,CAAC;wBACzB,GAAG,KAAA;wBACH,aAAa,EAAE,KAAK,IAAI,aAAa,IAAI,KAAK,KAAK,WAAW;qBAC/D,CAAC,EAHwB,CAGxB,CAAC,CACJ,CAAC;iBACH;YACH,CAAC,CAAC;YAEF,IAAI,oBAAoB,GAA6B,SAAS,CAAC;YAE/D,sGAAsG;YACtG,yEAAyE;YACzE,IAAI,iBAAiB,CAAC,OAAO,KAAK,SAAS,EAAE;gBAC3C,IAAM,KAAG,GAAG,qBAAS,CAAC,SAAS,CAAC,CAAC;gBACjC,IAAI,KAAG,EAAE;oBACP,IAAM,kBAAgB,GAAG,KAAG,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;oBAC9E,oBAAoB,GAAG,cAAM,OAAA,KAAG,CAAC,oBAAoB,CAAC,kBAAgB,CAAC,EAA1C,CAA0C,CAAC;iBACzE;aACF;YAED,OAAO;gBACL,IAAI,oBAAoB,EAAE;oBACxB,oBAAoB,EAAE,CAAC;iBACxB;gBAED,yDAAyD;gBACzD,yDAAyD;gBACzD,gBAAgB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBAC/B,iBAAiB,CAAC,OAAO,GAAG,SAAS,CAAC;YACxC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,OAAO,EAAE,aAAa,eAAA,EAAE,CAAC;IAC3B,CAAC,CAAC;IA1HW,QAAA,WAAW,eA0HtB","sourcesContent":["import * as React from 'react';\nimport { useIsomorphicLayoutEffect, useRefEffect } from '@fluentui/react-hooks';\nimport { getWindow } from '@fluentui/utilities';\nimport { observeResize } from './observeResize';\nimport type { RefCallback } from '@fluentui/react-hooks';\n\n/**\n * Callback to notify the user that the items in the overflow have changed. This should ensure that the overflow menu\n * is visible, and contains all of the overflowing items.\n *\n * @param overflowIndex - The index of the first item in the overflow, or items.length if nothing is overflowing.\n * @param items - The list of all items in the container, and whether that particular item is in the overflow\n */\nexport type OverflowItemsChangedCallback = (\n  overflowIndex: number,\n  items: { ele: HTMLElement; isOverflowing: boolean }[],\n) => void;\n\n/** Parameters for {@see useOverflow} */\nexport type OverflowParams = {\n  /** Callback to notify the user that the items in the overflow have changed. */\n  onOverflowItemsChanged: OverflowItemsChangedCallback;\n\n  /** True if the element containing overflowMenuButtonRef is in right-to-left order */\n  rtl: boolean;\n\n  /** Optional: Index of item that should never go into the overflow menu. */\n  pinnedIndex?: number;\n};\n\n/** Return value for {@see useOverflow} */\nexport type OverflowRefs = {\n  /** Set the overflow menu button's ref to this ref callback */\n  menuButtonRef: RefCallback<HTMLElement>;\n};\n\n/**\n * Track whether any items don't fit within their container, and move them to the overflow menu.\n * Items are moved into the overflow menu from back to front, excluding pinned items.\n *\n * The overflow menu button must be the last sibling of all of the items that can be put into the overflow, and it\n * must be hooked up to the `setMenuButtonRef` setter function that's returned by `useOverflow`:\n * ```ts\n * const overflow = useOverflow(...);\n * ```\n * ```jsx\n * <Container>\n *  <Item /> // Index 0\n *  <Item /> // Index 1\n *  ...\n *  <Button ref={overflow.setMenuButtonRef} /> // Can be any React.Component or HTMLElement\n * </Container>\n * ```\n */\nexport const useOverflow = ({ onOverflowItemsChanged, rtl, pinnedIndex }: OverflowParams): OverflowRefs => {\n  const updateOverflowRef = React.useRef<() => void>();\n  const containerWidthRef = React.useRef<number>();\n\n  // Attach a resize observer to the container\n  const containerRef = useRefEffect<HTMLElement>(container => {\n    const cleanupObserver = observeResize(container, entries => {\n      containerWidthRef.current = entries ? entries[0].contentRect.width : container.clientWidth;\n      if (updateOverflowRef.current) {\n        updateOverflowRef.current();\n      }\n    });\n\n    return () => {\n      cleanupObserver();\n      containerWidthRef.current = undefined;\n    };\n  });\n\n  const menuButtonRef = useRefEffect<HTMLElement>(menuButton => {\n    containerRef(menuButton.parentElement);\n    return () => containerRef(null);\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const container = containerRef.current;\n    const menuButton = menuButtonRef.current;\n    if (!container || !menuButton) {\n      return;\n    }\n\n    // items contains the container's children, excluding the overflow menu button itself\n    const items: HTMLElement[] = [];\n    for (let i = 0; i < container.children.length; i++) {\n      const item = container.children[i];\n      if (item instanceof HTMLElement && item !== menuButton) {\n        items.push(item);\n      }\n    }\n\n    // Keep track of the minimum width of the container to fit each child index.\n    // This cache is an integral part of the algorithm and not just a performance optimization: it allows us to\n    // recalculate the overflowIndex on subsequent resizes even if some items are already inside the overflow.\n    const minContainerWidth: number[] = [];\n    let extraWidth = 0; // The accumulated width of items that don't move into the overflow\n\n    updateOverflowRef.current = () => {\n      const containerWidth = containerWidthRef.current;\n      if (containerWidth === undefined) {\n        return;\n      }\n\n      // Iterate the items in reverse order until we find one that fits within the bounds of the container\n      for (let i = items.length - 1; i >= 0; i--) {\n        // Calculate the min container width for this item if we haven't done so yet\n        if (minContainerWidth[i] === undefined) {\n          const itemOffsetEnd = rtl ? containerWidth - items[i].offsetLeft : items[i].offsetLeft + items[i].offsetWidth;\n\n          // If the item after this one is pinned, reserve space for it\n          if (i + 1 < items.length && i + 1 === pinnedIndex) {\n            // Use distance between the end of the previous item and this one (rather than the\n            // pinned item's offsetWidth), to account for any margin between the items.\n            extraWidth = minContainerWidth[i + 1] - itemOffsetEnd;\n          }\n\n          // Reserve space for the menu button after the first item was added to the overflow\n          if (i === items.length - 2) {\n            extraWidth += menuButton.offsetWidth;\n          }\n\n          minContainerWidth[i] = itemOffsetEnd + extraWidth;\n        }\n\n        if (containerWidth > minContainerWidth[i]) {\n          setOverflowIndex(i + 1);\n          return;\n        }\n      }\n\n      // If we got here, nothing fits outside the overflow\n      setOverflowIndex(0);\n    };\n\n    let prevOverflowIndex = items.length;\n    const setOverflowIndex = (overflowIndex: number) => {\n      if (prevOverflowIndex !== overflowIndex) {\n        prevOverflowIndex = overflowIndex;\n        onOverflowItemsChanged(\n          overflowIndex,\n          items.map((ele, index) => ({\n            ele,\n            isOverflowing: index >= overflowIndex && index !== pinnedIndex,\n          })),\n        );\n      }\n    };\n\n    let cancelAnimationFrame: (() => void) | undefined = undefined;\n\n    // If the container width is already known from a previous render, update the overflow with its width.\n    // Do this in an animation frame to avoid forcing layout to happen early.\n    if (containerWidthRef.current !== undefined) {\n      const win = getWindow(container);\n      if (win) {\n        const animationFrameId = win.requestAnimationFrame(updateOverflowRef.current);\n        cancelAnimationFrame = () => win.cancelAnimationFrame(animationFrameId);\n      }\n    }\n\n    return () => {\n      if (cancelAnimationFrame) {\n        cancelAnimationFrame();\n      }\n\n      // On cleanup, need to remove all items from the overflow\n      // so they don't have stale properties on the next render\n      setOverflowIndex(items.length);\n      updateOverflowRef.current = undefined;\n    };\n  });\n\n  return { menuButtonRef };\n};\n"]}