{"version":3,"file":"observeResize.js","sourceRoot":"../src/","sources":["utilities/observeResize.ts"],"names":[],"mappings":";;;;IAEA;;;;;;;;;;;;;OAaG;IACI,IAAM,aAAa,GAAG,UAC3B,MAA2B,EAC3B,QAAuE;QAEvE,IAAI,OAAO,cAAc,KAAK,WAAW,EAAE;YACzC,IAAM,UAAQ,GAAG,IAAI,cAAc,CAAC,QAAQ,CAAC,CAAC;YAE9C,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;gBACzB,MAAM,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,UAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAnB,CAAmB,CAAC,CAAC;aAC1C;iBAAM;gBACL,UAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;aAC1B;YAED,OAAO,cAAM,OAAA,UAAQ,CAAC,UAAU,EAAE,EAArB,CAAqB,CAAC;SACpC;aAAM;YACL,0DAA0D;YAC1D,IAAM,iBAAe,GAAG,cAAM,OAAA,QAAQ,CAAC,SAAS,CAAC,EAAnB,CAAmB,CAAC;YAElD,IAAM,KAAG,GAAG,qBAAS,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;YAClE,IAAI,CAAC,KAAG,EAAE;gBACR,4DAA4D;gBAC5D,OAAO;oBACL,sBAAsB;gBACxB,CAAC,CAAC;aACH;YAED,mFAAmF;YACnF,IAAM,kBAAgB,GAAG,KAAG,CAAC,qBAAqB,CAAC,iBAAe,CAAC,CAAC;YACpE,KAAG,CAAC,gBAAgB,CAAC,QAAQ,EAAE,iBAAe,EAAE,KAAK,CAAC,CAAC;YAEvD,OAAO;gBACL,KAAG,CAAC,oBAAoB,CAAC,kBAAgB,CAAC,CAAC;gBAC3C,KAAG,CAAC,mBAAmB,CAAC,QAAQ,EAAE,iBAAe,EAAE,KAAK,CAAC,CAAC;YAC5D,CAAC,CAAC;SACH;IACH,CAAC,CAAC;IAnCW,QAAA,aAAa,iBAmCxB","sourcesContent":["import { getWindow } from '@fluentui/utilities';\n\n/**\n * Wrapper for ResizeObserver, with fallback for browsers that don't support ResizeObserver.\n *\n * Calls the onResize callback once layout is complete, and again whenever any of the target(s) change size.\n * Or if ResizeObserver isn't supported, calls the callback whenever the window changes size.\n *\n * @param target - Either a single element, or array of elements to watch for size changes.\n * @param onResize - Callback to be notified when layout is complete, and when the target(s) change size.\n *    If this browser supports ResizeObserver, the callback will be passed the ResizeObserverEntry[] array.\n *    Otherwise, the entries array will be undefined, and you'll need to find another way to get the element's size,\n *    (e.g. clientWidth/clientHeight or getBoundingClientRect).\n *\n * @returns A function to clean up the observer/listener.\n */\nexport const observeResize = (\n  target: Element | Element[],\n  onResize: (entries: readonly ResizeObserverEntry[] | undefined) => void,\n): (() => void) => {\n  if (typeof ResizeObserver !== 'undefined') {\n    const observer = new ResizeObserver(onResize);\n\n    if (Array.isArray(target)) {\n      target.forEach(t => observer.observe(t));\n    } else {\n      observer.observe(target);\n    }\n\n    return () => observer.disconnect();\n  } else {\n    // Fallback for browsers that don't support ResizeObserver\n    const onResizeWrapper = () => onResize(undefined);\n\n    const win = getWindow(Array.isArray(target) ? target[0] : target);\n    if (!win) {\n      // Can't listen for resize if we can't get the window object\n      return () => {\n        // Nothing to clean up\n      };\n    }\n\n    // Listen for the first animation frame, which will happen after layout is complete\n    const animationFrameId = win.requestAnimationFrame(onResizeWrapper);\n    win.addEventListener('resize', onResizeWrapper, false);\n\n    return () => {\n      win.cancelAnimationFrame(animationFrameId);\n      win.removeEventListener('resize', onResizeWrapper, false);\n    };\n  }\n};\n\n/** Temporary type definition for ResizeObserver. Can be removed when official types are available. */\ntype ResizeObserver = {\n  new (callback: (entries: readonly ResizeObserverEntry[], observer: ResizeObserver) => void): ResizeObserver;\n  observe(target: Element, options?: { box: 'content-box' | 'border-box' }): void;\n  unobserve(target: Element): void;\n  disconnect(): void;\n};\n\n/** Temporary type definition for ResizeObserverEntry. Can be removed when official types are available. */\ntype ResizeObserverEntry = {\n  readonly contentRect: DOMRectReadOnly;\n  readonly target: Element;\n};\n\n/** Temporary definition for ResizeObserver. Can be removed when official types are available. */\ndeclare const ResizeObserver: ResizeObserver | undefined;\n"]}