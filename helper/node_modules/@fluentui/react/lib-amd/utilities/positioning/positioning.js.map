{"version":3,"file":"positioning.js","sourceRoot":"../src/","sources":["utilities/positioning/positioning.ts"],"names":[],"mappings":"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","sourcesContent":["import { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\nimport type { IRectangle, Point } from '../../Utilities';\nimport type {\n  IPositionDirectionalHintData,\n  IPositionedData,\n  ICalloutPositionedInfo,\n  ICalloutBeakPositionedInfo,\n  IPositionProps,\n  ICalloutPositionProps,\n  IWindowWithSegments,\n} from './positioning.types';\n\nfunction _createPositionData(\n  targetEdge: RectangleEdge,\n  alignmentEdge?: RectangleEdge,\n  isAuto?: boolean,\n): IPositionDirectionalHintData {\n  return {\n    targetEdge: targetEdge,\n    alignmentEdge: alignmentEdge,\n    isAuto: isAuto,\n  };\n}\n\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nconst DirectionalDictionary: { [key: number]: IPositionDirectionalHintData } = {\n  [DirectionalHint.topLeftEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.left),\n  [DirectionalHint.topCenter]: _createPositionData(RectangleEdge.top),\n  [DirectionalHint.topRightEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.right),\n  [DirectionalHint.topAutoEdge]: _createPositionData(RectangleEdge.top, undefined, true),\n  [DirectionalHint.bottomLeftEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.left),\n  [DirectionalHint.bottomCenter]: _createPositionData(RectangleEdge.bottom),\n  [DirectionalHint.bottomRightEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.right),\n  [DirectionalHint.bottomAutoEdge]: _createPositionData(RectangleEdge.bottom, undefined, true),\n  [DirectionalHint.leftTopEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.top),\n  [DirectionalHint.leftCenter]: _createPositionData(RectangleEdge.left),\n  [DirectionalHint.leftBottomEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.bottom),\n  [DirectionalHint.rightTopEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.top),\n  [DirectionalHint.rightCenter]: _createPositionData(RectangleEdge.right),\n  [DirectionalHint.rightBottomEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.bottom),\n};\n\n/**\n * Do not call methods from this directly, use either positionCallout or positionElement or make another function that\n * utilizes them.\n * START Private functions and interfaces\n */\n\nexport interface IElementPosition {\n  elementRectangle: Rectangle;\n  targetEdge: RectangleEdge;\n  alignmentEdge: RectangleEdge | undefined;\n  forcedInBounds?: boolean;\n}\n\nexport interface IElementPositionInfo extends IElementPosition {\n  targetRectangle: Rectangle;\n}\n\ntype PartialIRectangle = Partial<IRectangle>;\n\ninterface IPartialIRectangle extends PartialIRectangle {\n  [key: string]: number | undefined;\n}\n\nfunction _isRectangleWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\n  if (rect.top < boundingRect.top) {\n    return false;\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    return false;\n  }\n  if (rect.left < boundingRect.left) {\n    return false;\n  }\n  if (rect.right > boundingRect.right) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\nfunction _getOutOfBoundsEdges(rect: Rectangle, boundingRect: Rectangle): RectangleEdge[] {\n  const outOfBounds: RectangleEdge[] = [];\n\n  if (rect.top < boundingRect.top) {\n    outOfBounds.push(RectangleEdge.top);\n  }\n  if (rect.bottom > boundingRect.bottom) {\n    outOfBounds.push(RectangleEdge.bottom);\n  }\n  if (rect.left < boundingRect.left) {\n    outOfBounds.push(RectangleEdge.left);\n  }\n  if (rect.right > boundingRect.right) {\n    outOfBounds.push(RectangleEdge.right);\n  }\n\n  return outOfBounds;\n}\n\nfunction _getEdgeValue(rect: Rectangle, edge: RectangleEdge): number {\n  return (rect as any)[RectangleEdge[edge]] as number;\n}\n\nfunction _setEdgeValue(rect: Rectangle, edge: RectangleEdge, value: number) {\n  (rect as any)[RectangleEdge[edge]] = value;\n  return rect;\n}\n\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\nfunction _getCenterValue(rect: Rectangle, edge: RectangleEdge): number {\n  const edges = _getFlankingEdges(edge);\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\nfunction _getRelativeEdgeValue(edge: RectangleEdge, value: number): number {\n  if (edge > 0) {\n    return value;\n  } else {\n    return value * -1;\n  }\n}\n\nfunction _getRelativeRectEdgeValue(edge: RectangleEdge, rect: Rectangle): number {\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\n\nfunction _getRelativeEdgeDifference(rect: Rectangle, hostRect: Rectangle, edge: RectangleEdge): number {\n  const edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n  return _getRelativeEdgeValue(edge, edgeDifference);\n}\n\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n * if maintainSize is set to false, it will only adjust the specified edge value\n */\nfunction _moveEdge(rect: Rectangle, edge: RectangleEdge, newValue: number, maintainSize = true): Rectangle {\n  const difference = _getEdgeValue(rect, edge) - newValue;\n  let returnRect = _setEdgeValue(rect, edge, newValue);\n  if (maintainSize) {\n    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n  }\n  return returnRect;\n}\n\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\nfunction _alignEdges(rect: Rectangle, target: Rectangle, edge: RectangleEdge, gap: number = 0): Rectangle {\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\nfunction _alignOppositeEdges(\n  rect: Rectangle,\n  target: Rectangle,\n  targetEdge: RectangleEdge,\n  gap: number = 0,\n): Rectangle {\n  const oppositeEdge = targetEdge * -1;\n  const adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\nfunction _isEdgeInBounds(rect: Rectangle, bounds: Rectangle, edge: RectangleEdge): boolean {\n  const adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n\n/**\n * Returns a measure of how much a rectangle is out of bounds for a given alignment;\n * this can be used to compare which rectangle is more or less out of bounds.\n * A value of 0 means the rectangle is entirely in bounds\n */\nfunction _getOutOfBoundsDegree(rect: Rectangle, bounds: Rectangle) {\n  const breakingEdges = _getOutOfBoundsEdges(rect, bounds);\n  let total = 0;\n  for (const edge of breakingEdges) {\n    total += _getRelativeEdgeDifference(rect, bounds, edge) ** 2;\n  }\n\n  return total;\n}\n\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the least bad option should be returned.\n */\nfunction _flipToFit(\n  rect: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n): IElementPosition {\n  const directions: RectangleEdge[] = [\n    RectangleEdge.left,\n    RectangleEdge.right,\n    RectangleEdge.bottom,\n    RectangleEdge.top,\n  ];\n  // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n  if (getRTL()) {\n    directions[0] *= -1;\n    directions[1] *= -1;\n  }\n  let currentEstimate = rect;\n  let currentEdge = positionData.targetEdge;\n  let currentAlignment = positionData.alignmentEdge;\n\n  // keep track of least bad option, in case no sides fit\n  let oobDegree;\n  let bestEdge = currentEdge;\n  let bestAlignment = currentAlignment;\n\n  // Keep switching sides until one is found with enough space.\n  // If all sides don't fit then return the unmodified element.\n  for (let i = 0; i < 4; i++) {\n    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n      // update least-bad edges\n      const currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);\n      if (!oobDegree || currentOOBDegree < oobDegree) {\n        oobDegree = currentOOBDegree;\n        bestEdge = currentEdge;\n        bestAlignment = currentAlignment;\n      }\n\n      directions.splice(directions.indexOf(currentEdge), 1);\n      if (directions.length > 0) {\n        if (directions.indexOf(currentEdge * -1) > -1) {\n          currentEdge = currentEdge * -1;\n        } else {\n          currentAlignment = currentEdge;\n          currentEdge = directions.slice(-1)[0];\n        }\n        currentEstimate = _estimatePosition(\n          rect,\n          target,\n          { targetEdge: currentEdge, alignmentEdge: currentAlignment },\n          gap,\n        );\n      }\n    } else {\n      return {\n        elementRectangle: currentEstimate,\n        targetEdge: currentEdge,\n        alignmentEdge: currentAlignment,\n      };\n    }\n  }\n\n  // nothing fits, use least-bad option\n  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);\n  return {\n    elementRectangle: currentEstimate,\n    targetEdge: bestEdge,\n    alignmentEdge: bestAlignment,\n  };\n}\n\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when `alignTargetEdge` is specified.\n */\nfunction _flipAlignmentEdge(\n  elementEstimate: IElementPosition,\n  target: Rectangle,\n  gap: number,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, targetEdge, elementRectangle } = elementEstimate;\n  const oppositeEdge = alignmentEdge! * -1;\n  const newEstimate = _estimatePosition(\n    elementRectangle,\n    target,\n    { targetEdge: targetEdge, alignmentEdge: oppositeEdge },\n    gap,\n    coverTarget,\n  );\n\n  return {\n    elementRectangle: newEstimate,\n    targetEdge: targetEdge,\n    alignmentEdge: oppositeEdge,\n  };\n}\n\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\nfunction _adjustFitWithinBounds(\n  element: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const { alignmentEdge, alignTargetEdge } = positionData;\n  let elementEstimate: IElementPosition = {\n    elementRectangle: element,\n    targetEdge: positionData.targetEdge,\n    alignmentEdge: alignmentEdge,\n  };\n\n  if (!directionalHintFixed && !coverTarget) {\n    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);\n  }\n  const outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);\n  // if directionalHintFixed is specified, we need to force the target edge to not change\n  // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite\n  const fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;\n\n  if (outOfBounds.length > 0) {\n    if (alignTargetEdge) {\n      // The edge opposite to the alignment edge might be out of bounds.\n      // Flip alignment to see if we can get it within bounds.\n      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n        const flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n          return flippedElementEstimate;\n        } else {\n          // If the flipped elements edges are still out of bounds, try nudging it.\n          elementEstimate = _alignOutOfBoundsEdges(\n            _getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding),\n            elementEstimate,\n            bounding,\n            fixedEdge,\n          );\n        }\n      } else {\n        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n      }\n    } else {\n      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n    }\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n * @param preserveEdge - Specify an edge that should not be modified\n */\nfunction _alignOutOfBoundsEdges(\n  outOfBoundsEdges: RectangleEdge[],\n  elementEstimate: IElementPosition,\n  bounding: Rectangle,\n  preserveEdge?: RectangleEdge,\n) {\n  for (const direction of outOfBoundsEdges) {\n    let edgeAttempt;\n\n    // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge\n    // this is because _alignEdges will move the opposite edge\n    if (preserveEdge && preserveEdge === direction * -1) {\n      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);\n      elementEstimate.forcedInBounds = true;\n    } else {\n      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n      const inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);\n      // only update estimate if the attempt didn't break out of the opposite bounding edge\n      if (!inBounds) {\n        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);\n        elementEstimate.forcedInBounds = true;\n      }\n    }\n\n    elementEstimate.elementRectangle = edgeAttempt;\n  }\n\n  return elementEstimate;\n}\n\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\nfunction _centerEdgeToPoint(rect: Rectangle, edge: RectangleEdge, point: number): Rectangle {\n  const { positiveEdge } = _getFlankingEdges(edge);\n  const elementMiddle = _getCenterValue(rect, edge);\n  const distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\nfunction _estimatePosition(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number = 0,\n  coverTarget?: boolean,\n): Rectangle {\n  let estimatedElementPosition = new Rectangle(\n    elementToPosition.left,\n    elementToPosition.right,\n    elementToPosition.top,\n    elementToPosition.bottom,\n  );\n  const { alignmentEdge, targetEdge } = positionData;\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  estimatedElementPosition = coverTarget\n    ? _alignEdges(estimatedElementPosition, target, targetEdge, gap)\n    : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);\n  // if no alignment edge is provided it's supposed to be centered.\n  if (!alignmentEdge) {\n    const targetMiddlePoint = _getCenterValue(target, targetEdge);\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n  } else {\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n  }\n\n  return estimatedElementPosition;\n}\n\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\nfunction _getFlankingEdges(edge: RectangleEdge): { positiveEdge: RectangleEdge; negativeEdge: RectangleEdge } {\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n    return {\n      positiveEdge: RectangleEdge.left,\n      negativeEdge: RectangleEdge.right,\n    };\n  } else {\n    return {\n      positiveEdge: RectangleEdge.top,\n      negativeEdge: RectangleEdge.bottom,\n    };\n  }\n}\n\n/**\n * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\nfunction _finalizeReturnEdge(\n  elementRectangle: Rectangle,\n  returnEdge: RectangleEdge,\n  bounds?: Rectangle,\n): RectangleEdge {\n  if (\n    bounds &&\n    Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >\n      Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))\n  ) {\n    return returnEdge * -1;\n  }\n\n  return returnEdge;\n}\n\n/**\n * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds\n * @param elementRectangle The rectangle whose edge we are considering\n * @param bounds The rectangle marking the bounds\n * @param edge The target edge we're considering\n * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds\n */\nfunction _isEdgeOnBounds(elementRectangle: Rectangle, edge: RectangleEdge, bounds?: Rectangle): boolean {\n  return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);\n}\n\n/**\n * Finalizes the element position based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.\n */\nfunction _finalizeElementPosition(\n  elementRectangle: Rectangle,\n  hostElement: HTMLElement,\n  targetEdge: RectangleEdge,\n  bounds?: Rectangle,\n  alignmentEdge?: RectangleEdge,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n  forceWithinBounds?: boolean,\n): IPartialIRectangle {\n  const returnValue: IPartialIRectangle = {};\n\n  const hostRect: Rectangle = _getRectangleFromElement(hostElement);\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n  let returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n\n  // If we are finalizing the return edge, choose the edge such that we grow away from the bounds\n  // If we are not finalizing the return edge but the opposite edge is flush against the bounds,\n  // choose that as the anchor edge so the element rect can grow away from the bounds' edge\n  // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow\n  // in the usual direction\n  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {\n    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n  }\n\n  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n\n  // if the positioned element will still overflow, return all four edges with in-bounds values\n  if (forceWithinBounds) {\n    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      elementEdge * -1,\n    );\n    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(\n      elementRectangle,\n      hostRect,\n      returnEdge * -1,\n    );\n  }\n\n  return returnValue;\n}\n\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\nfunction _calculateActualBeakWidthInPixels(beakWidth: number): number {\n  return Math.sqrt(beakWidth * beakWidth * 2);\n}\n\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\nfunction _getPositionData(\n  directionalHint: DirectionalHint = DirectionalHint.bottomAutoEdge,\n  directionalHintForRTL?: DirectionalHint,\n  previousPositions?: IPositionDirectionalHintData,\n): IPositionDirectionalHintData {\n  if (previousPositions) {\n    return {\n      alignmentEdge: previousPositions.alignmentEdge,\n      isAuto: previousPositions.isAuto,\n      targetEdge: previousPositions.targetEdge,\n    };\n  }\n  const positionInformation: IPositionDirectionalHintData = { ...DirectionalDictionary[directionalHint] };\n  if (getRTL()) {\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n    }\n\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n  }\n  return positionInformation;\n}\n\n/**\n * Gets the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\nfunction _getAlignmentData(\n  positionData: IPositionDirectionalHintData,\n  target: Rectangle,\n  boundingRect: Rectangle,\n  coverTarget?: boolean,\n  alignTargetEdge?: boolean,\n): IPositionDirectionalHintData {\n  if (positionData.isAuto) {\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n  }\n\n  positionData.alignTargetEdge = alignTargetEdge;\n  return positionData;\n}\n\nfunction getClosestEdge(targetEdge: RectangleEdge, target: Rectangle, boundingRect: Rectangle): RectangleEdge {\n  const targetCenter: number = _getCenterValue(target, targetEdge);\n  const boundingCenter: number = _getCenterValue(boundingRect, targetEdge);\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(targetEdge);\n  if (targetCenter <= boundingCenter) {\n    return positiveEdge;\n  } else {\n    return negativeEdge;\n  }\n}\n\nfunction _positionElementWithinBounds(\n  elementToPosition: Rectangle,\n  target: Rectangle,\n  bounding: Rectangle,\n  positionData: IPositionDirectionalHintData,\n  gap: number,\n  directionalHintFixed?: boolean,\n  coverTarget?: boolean,\n): IElementPosition {\n  const estimatedElementPosition: Rectangle = _estimatePosition(\n    elementToPosition,\n    target,\n    positionData,\n    gap,\n    coverTarget,\n  );\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n    return {\n      elementRectangle: estimatedElementPosition,\n      targetEdge: positionData.targetEdge,\n      alignmentEdge: positionData.alignmentEdge,\n    };\n  } else {\n    return _adjustFitWithinBounds(\n      estimatedElementPosition,\n      target,\n      bounding,\n      positionData,\n      gap,\n      directionalHintFixed,\n      coverTarget,\n    );\n  }\n}\n\nfunction _finalizeBeakPosition(\n  elementPosition: IElementPositionInfo,\n  positionedBeak: Rectangle,\n  bounds?: Rectangle,\n): ICalloutBeakPositionedInfo {\n  const targetEdge = elementPosition.targetEdge * -1;\n  // The \"host\" element that we will use to help position the beak.\n  const actualElement = new Rectangle(\n    0,\n    elementPosition.elementRectangle.width,\n    0,\n    elementPosition.elementRectangle.height,\n  );\n  const returnValue: IPartialIRectangle = {};\n  const returnEdge = _finalizeReturnEdge(\n    elementPosition.elementRectangle,\n    elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge,\n    bounds,\n  );\n\n  // only show the beak if the callout is not fully covering the target\n  const beakEdgeDifference = _getRelativeEdgeDifference(\n    elementPosition.elementRectangle,\n    elementPosition.targetRectangle,\n    targetEdge,\n  );\n  const showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));\n\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n\n  return {\n    elementPosition: { ...returnValue },\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n    targetEdge: targetEdge,\n    hideBeak: !showBeak,\n  };\n}\n\nfunction _positionBeak(beakWidth: number, elementPosition: IElementPositionInfo): Rectangle {\n  const target = elementPosition.targetRectangle;\n  /**\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n   */\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(elementPosition.targetEdge);\n  const beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n  const elementBounds = new Rectangle(\n    beakWidth / 2,\n    elementPosition.elementRectangle.width - beakWidth / 2,\n    beakWidth / 2,\n    elementPosition.elementRectangle.height - beakWidth / 2,\n  );\n\n  let beakPosition: Rectangle = new Rectangle(0, beakWidth, 0, beakWidth);\n\n  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n\n  beakPosition = _centerEdgeToPoint(\n    beakPosition,\n    elementPosition.targetEdge * -1,\n    beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle),\n  );\n\n  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n  }\n\n  return beakPosition;\n}\n\nfunction _getRectangleFromElement(element: Element): Rectangle {\n  const clientRect: ClientRect = element.getBoundingClientRect();\n\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\n\nfunction _getRectangleFromIRect(rect: IRectangle): Rectangle {\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\n\nfunction _getTargetRect(bounds: Rectangle, target: Element | MouseEvent | Point | Rectangle | undefined): Rectangle {\n  let targetRectangle: Rectangle;\n  if (target) {\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (!!(target as MouseEvent).preventDefault) {\n      const ev = target as MouseEvent;\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n      // eslint-disable-next-line no-extra-boolean-cast\n    } else if (!!(target as Element).getBoundingClientRect) {\n      targetRectangle = _getRectangleFromElement(target as Element);\n      // HTMLImgElements can have x and y values. The check for it being a point must go last.\n    } else {\n      const rectOrPoint: Point & Rectangle = target as Point & Rectangle;\n      // eslint-disable-next-line deprecation/deprecation\n      const left = rectOrPoint.left || rectOrPoint.x;\n      // eslint-disable-next-line deprecation/deprecation\n      const top = rectOrPoint.top || rectOrPoint.y;\n      const right = rectOrPoint.right || left;\n      const bottom = rectOrPoint.bottom || top;\n      targetRectangle = new Rectangle(left, right, top, bottom);\n    }\n\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n      const outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\n\n      for (const direction of outOfBounds) {\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\n      }\n    }\n  } else {\n    targetRectangle = new Rectangle(0, 0, 0, 0);\n  }\n\n  return targetRectangle;\n}\n\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\nfunction _getMaxHeightFromTargetRectangle(\n  targetRectangle: Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number,\n  bounds: Rectangle,\n  coverTarget?: boolean,\n) {\n  let maxHeight = 0;\n  const directionalHint = DirectionalDictionary[targetEdge];\n\n  // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n  // that's the direction that the callout will expand in.\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n  // is (bottom of target) - (top of screen) - gapSpace.\n  const target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n\n  if (target === RectangleEdge.top) {\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n  } else if (target === RectangleEdge.bottom) {\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n  } else {\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n  }\n\n  return maxHeight > 0 ? maxHeight : bounds.height;\n}\n\nfunction _positionElementRelative(\n  props: IPositionProps,\n  elementToPosition: HTMLElement,\n  boundingRect: Rectangle,\n  previousPositions?: IPositionedData,\n): IElementPositionInfo {\n  const gap: number = props.gapSpace ? props.gapSpace : 0;\n  const targetRect: Rectangle = _getTargetRect(boundingRect, props.target);\n  const positionData: IPositionDirectionalHintData = _getAlignmentData(\n    _getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions)!,\n    targetRect,\n    boundingRect,\n    props.coverTarget,\n    props.alignTargetEdge,\n  );\n  const positionedElement: IElementPosition = _positionElementWithinBounds(\n    _getRectangleFromElement(elementToPosition),\n    targetRect,\n    boundingRect,\n    positionData,\n    gap,\n    props.directionalHintFixed,\n    props.coverTarget,\n  );\n  return { ...positionedElement, targetRectangle: targetRect };\n}\n\nfunction _finalizePositionData(\n  positionedElement: IElementPosition,\n  hostElement: HTMLElement,\n  bounds?: Rectangle,\n  coverTarget?: boolean,\n  doNotFinalizeReturnEdge?: boolean,\n): IPositionedData {\n  const finalizedElement: IPartialIRectangle = _finalizeElementPosition(\n    positionedElement.elementRectangle,\n    hostElement,\n    positionedElement.targetEdge,\n    bounds,\n    positionedElement.alignmentEdge,\n    coverTarget,\n    doNotFinalizeReturnEdge,\n    positionedElement.forcedInBounds,\n  );\n  return {\n    elementPosition: finalizedElement,\n    targetEdge: positionedElement.targetEdge,\n    alignmentEdge: positionedElement.alignmentEdge,\n  };\n}\n\nfunction _positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPosition = _positionElementRelative(\n    props,\n    elementToPosition,\n    boundingRect,\n    previousPositions,\n  );\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\n\nfunction _positionCallout(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n  doNotFinalizeReturnEdge?: boolean,\n): ICalloutPositionedInfo {\n  const beakWidth: number = props.isBeakVisible ? props.beakWidth || 0 : 0;\n  const gap: number = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\n  const positionProps: IPositionProps = props;\n  positionProps.gapSpace = gap;\n  const boundingRect: Rectangle = props.bounds\n    ? _getRectangleFromIRect(props.bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n  const positionedElement: IElementPositionInfo = _positionElementRelative(\n    positionProps,\n    callout,\n    boundingRect,\n    previousPositions,\n  );\n\n  const beakPositioned: Rectangle = _positionBeak(beakWidth, positionedElement);\n  const finalizedBeakPosition: ICalloutBeakPositionedInfo = _finalizeBeakPosition(\n    positionedElement,\n    beakPositioned,\n    boundingRect,\n  );\n\n  return {\n    ..._finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge),\n    beakPosition: finalizedBeakPosition,\n  };\n}\n\nfunction _positionCard(\n  props: ICalloutPositionProps,\n  hostElement: HTMLElement,\n  callout: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, callout, previousPositions, true);\n}\n// END PRIVATE FUNCTIONS\n\nexport const __positioningTestPackage = {\n  _finalizePositionData,\n  _finalizeBeakPosition,\n  _calculateActualBeakWidthInPixels,\n  _positionElementWithinBounds,\n  _positionBeak,\n  _getPositionData,\n  _getMaxHeightFromTargetRectangle,\n};\n\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\nexport function positionElement(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: IPositionedData,\n): IPositionedData {\n  return _positionElement(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCallout(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions);\n}\n\nexport function positionCard(\n  props: IPositionProps,\n  hostElement: HTMLElement,\n  elementToPosition: HTMLElement,\n  previousPositions?: ICalloutPositionedInfo,\n): ICalloutPositionedInfo {\n  return _positionCard(props, hostElement, elementToPosition, previousPositions);\n}\n\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(\n  target: Element | MouseEvent | Point | Rectangle,\n  targetEdge: DirectionalHint,\n  gapSpace: number = 0,\n  bounds?: IRectangle,\n  coverTarget?: boolean,\n): number {\n  const mouseTarget: MouseEvent = target as MouseEvent;\n  const elementTarget: Element = target as Element;\n  const rectOrPointTarget: Point & Rectangle = target as Point & Rectangle;\n  let targetRect: Rectangle;\n  const boundingRectangle = bounds\n    ? _getRectangleFromIRect(bounds)\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\n\n  // eslint-disable-next-line deprecation/deprecation\n  const left = rectOrPointTarget.left || rectOrPointTarget.x;\n  // eslint-disable-next-line deprecation/deprecation\n  const top = rectOrPointTarget.top || rectOrPointTarget.y;\n  const right = rectOrPointTarget.right || left;\n  const bottom = rectOrPointTarget.bottom || top;\n\n  // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n  if (!!mouseTarget.stopPropagation) {\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n  } else if (left !== undefined && top !== undefined) {\n    targetRect = new Rectangle(left, right, top, bottom);\n  } else {\n    targetRect = _getRectangleFromElement(elementTarget);\n  }\n\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\nexport function getOppositeEdge(edge: RectangleEdge): RectangleEdge {\n  return edge * -1;\n}\n\nfunction _getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  let segments = undefined;\n  if (targetWindow.getWindowSegments) {\n    segments = targetWindow.getWindowSegments();\n  }\n\n  // Identify if we're dealing with single screen scenarios.\n  if (segments === undefined || segments.length <= 1) {\n    return {\n      top: 0,\n      left: 0,\n      right: targetWindow.innerWidth,\n      bottom: targetWindow.innerHeight,\n      width: targetWindow.innerWidth,\n      height: targetWindow.innerHeight,\n    };\n  }\n\n  // Logic for determining dual screen scenarios.\n  let x: number | undefined = 0;\n  let y: number | undefined = 0;\n\n  // If the target is an Element get coordinates for its center.\n  if (target !== null && !!(target as Element).getBoundingClientRect) {\n    const clientRect = (target as Element).getBoundingClientRect();\n    x = (clientRect.left + clientRect.right) / 2;\n    y = (clientRect.top + clientRect.bottom) / 2;\n  }\n  // If the target is not null get x-axis and y-axis coordinates directly.\n  else if (target !== null) {\n    // eslint-disable-next-line deprecation/deprecation\n    x = (target as Point).left || (target as MouseEvent | Point).x;\n    // eslint-disable-next-line deprecation/deprecation\n    y = (target as Point).top || (target as MouseEvent | Point).y;\n  }\n\n  let bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };\n\n  // Define which window segment are the coordinates in and calculate bounds based on that.\n  for (const segment of segments) {\n    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n      bounds = {\n        top: segment.top,\n        left: segment.left,\n        right: segment.right,\n        bottom: segment.bottom,\n        width: segment.width,\n        height: segment.height,\n      };\n    }\n  }\n\n  return bounds;\n}\n\nexport function getBoundsFromTargetWindow(\n  target: Element | MouseEvent | Point | Rectangle | null,\n  targetWindow: IWindowWithSegments,\n): IRectangle {\n  return _getBoundsFromTargetWindow(target, targetWindow);\n}\n"]}