{"version":3,"file":"SelectionZone.js","sourceRoot":"../src/","sources":["utilities/selection/SelectionZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  KeyCodes,\n  elementContains,\n  findScrollableParent,\n  getParent,\n  getDocument,\n  getWindow,\n  isElementTabbable,\n  css,\n  initializeComponentRef,\n  FocusRects,\n} from '../../Utilities';\nimport { SelectionMode } from './interfaces';\nimport type { ISelection, IObjectWithKey } from './interfaces';\n\n// Selection definitions:\n//\n// Anchor index: the point from which a range selection starts.\n// Focus index: the point from which layout movement originates from.\n//\n// These two can differ. Tests:\n//\n// If you start at index 5\n// Shift click to index 10\n//    The focus is 10, the anchor is 5.\n// If you shift click at index 0\n//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.\n// If you click index 8\n//    The anchor and focus are set to 8.\n\nconst SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';\nconst SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';\nconst SELECTION_SPAN_ATTRIBUTE_NAME = 'data-selection-span';\nconst SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';\nconst SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';\nconst SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = 'data-selection-touch-invoke';\nconst SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';\nconst SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZone {\n  /**\n   * Method to ignore subsequent focus.\n   */\n  ignoreNextFocus: () => void;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneProps extends React.ClassAttributes<SelectionZone> {\n  children?: React.ReactNode;\n  /**\n   * Reference to the component interface.\n   */\n  componentRef?: () => void;\n  /**\n   * Required {@link ISelection} instance bound to the {@link SelectionZone}.\n   */\n  selection: ISelection;\n  /**\n   * @deprecated No longer in use, focus is now managed by {@link FocusZone}.\n   */\n  layout?: {};\n  /**\n   * The mode of Selection, where the value is one of\n   * 'none', 'single', or 'multiple'.\n   *\n   * @defaultvalue {@link SelectionMode.multiple}\n   */\n  selectionMode?: SelectionMode;\n  /**\n   * If true, selection is preserved on outer click.\n   */\n  selectionPreservedOnEmptyClick?: boolean;\n  /**\n   * If true, disables automatic selection on input elements.\n   */\n  disableAutoSelectOnInputElements?: boolean;\n  /**\n   * If true, modal selection is enabled on touch event.\n   */\n  enterModalOnTouch?: boolean;\n  /**\n   * Determines whether elements with the attribute `data-selection-touch-invoke` should be used as invocation targets\n   * for an item if the user is using touch.\n   *\n   * @defaultvalue false\n   */\n  enableTouchInvocationTarget?: boolean;\n  /**\n   * Determines if an item is selected on focus.\n   *\n   * @defaultvalue true\n   */\n  isSelectedOnFocus?: boolean;\n  /**\n   * Determines if elements within the selection zone that DO NOT have the 'data-selection-toggle' or\n   * 'data-selection-all-toggle' attribute are clickable and can alter the selection.\n   *\n   * @defaultvalue true\n   */\n  selectionClearedOnSurfaceClick?: boolean;\n\n  /**\n   * Determines if pressing the Escape clears the selection.\n   *\n   * @defaultvalue true\n   */\n  selectionClearedOnEscapePress?: boolean;\n\n  /**\n   * Allows the default toggle behavior to be overridden.\n   * When set to `true` users do not have press a modifier key (e.g., ctrl or meta)\n   * to toggle values.\n   *\n   * @default false\n   */\n  toggleWithoutModifierPressed?: boolean;\n\n  /**\n   * Optional callback for when an item is\n   * invoked via ENTER or double-click.\n   */\n  onItemInvoked?: (item?: IObjectWithKey, index?: number, ev?: Event) => void;\n  /**\n   * Optional callback for when an\n   * item's contextual menu action occurs.\n   */\n  onItemContextMenu?: (item?: any, index?: number, ev?: Event) => void | boolean;\n  /**\n   * Additional CSS class(es) to apply to the SelectionZone.\n   */\n  className?: string;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneState {\n  isModal: boolean | undefined;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport class SelectionZone extends React.Component<ISelectionZoneProps, ISelectionZoneState> {\n  public static defaultProps = {\n    isSelectedOnFocus: true,\n    toggleWithoutModifierPressed: false,\n    selectionMode: SelectionMode.multiple,\n    selectionClearedOnEscapePress: true,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _isCtrlPressed: boolean;\n  private _isShiftPressed: boolean;\n  private _isMetaPressed: boolean;\n  private _isTabPressed: boolean;\n  private _shouldHandleFocus: boolean;\n  private _shouldHandleFocusTimeoutId: number | undefined;\n  private _isTouch: boolean;\n  private _isTouchTimeoutId: number | undefined;\n\n  public static getDerivedStateFromProps(\n    nextProps: ISelectionZoneProps,\n    prevState: ISelectionZoneState,\n  ): ISelectionZoneState {\n    const isModal = nextProps.selection.isModal && nextProps.selection.isModal();\n\n    return {\n      ...prevState,\n      isModal,\n    };\n  }\n\n  constructor(props: ISelectionZoneProps) {\n    super(props);\n\n    this._events = new EventGroup(this);\n    this._async = new Async(this);\n    initializeComponentRef(this);\n\n    const { selection } = this.props;\n\n    // Reflect the initial modal state of selection into the state.\n    const isModal = selection.isModal && selection.isModal();\n\n    this.state = {\n      isModal,\n    };\n  }\n\n  public componentDidMount(): void {\n    const win = getWindow(this._root.current);\n\n    // Track the latest modifier keys globally.\n    this._events.on(win, 'keydown, keyup', this._updateModifiers, true);\n    this._events.on(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(document.body, 'touchstart', this._onTouchStartCapture, true);\n    this._events.on(document.body, 'touchend', this._onTouchStartCapture, true);\n\n    // Subscribe to the selection to keep modal state updated.\n    this._events.on(this.props.selection, 'change', this._onSelectionChange);\n  }\n\n  public render(): JSX.Element {\n    const { isModal } = this.state;\n\n    return (\n      <div\n        className={css('ms-SelectionZone', this.props.className, {\n          'ms-SelectionZone--modal': !!isModal,\n        })}\n        ref={this._root}\n        onKeyDown={this._onKeyDown}\n        onMouseDown={this._onMouseDown}\n        onKeyDownCapture={this._onKeyDownCapture}\n        onClick={this._onClick}\n        role=\"presentation\"\n        onDoubleClick={this._onDoubleClick}\n        onContextMenu={this._onContextMenu}\n        onMouseDownCapture={this._onMouseDownCapture}\n        onFocusCapture={this._onFocus}\n        data-selection-is-modal={isModal ? true : undefined}\n      >\n        {this.props.children}\n        <FocusRects />\n      </div>\n    );\n  }\n\n  public componentDidUpdate(previousProps: ISelectionZoneProps): void {\n    const { selection } = this.props;\n\n    if (selection !== previousProps.selection) {\n      // Whenever selection changes, update the subscripton to keep modal state updated.\n      this._events.off(previousProps.selection);\n      this._events.on(selection, 'change', this._onSelectionChange);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  /**\n   * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone\n   * react to the event. Note that focus events in IE \\<= 11 will occur asynchronously after .focus() has\n   * been called on an element, so we need a flag to store the idea that we will bypass the \"next\"\n   * focus event that occurs. This method does that.\n   */\n  public ignoreNextFocus = (): void => {\n    this._handleNextFocus(false);\n  };\n\n  private _onSelectionChange = (): void => {\n    const { selection } = this.props;\n\n    const isModal = selection.isModal && selection.isModal();\n\n    this.setState({\n      isModal,\n    });\n  };\n\n  private _onMouseDownCapture = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n\n    if (document.activeElement !== target && !elementContains(document.activeElement as HTMLElement, target)) {\n      this.ignoreNextFocus();\n      return;\n    }\n\n    if (!elementContains(target, this._root.current)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n        this.ignoreNextFocus();\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  /**\n   * When we focus an item, for single/multi select scenarios, we should try to select it immediately\n   * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them\n   * specially.\n   */\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n    const { selection } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (this._shouldHandleFocus && selectionMode !== SelectionMode.none) {\n      const isToggle = this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);\n      const itemRoot = this._findItemRoot(target);\n\n      if (!isToggle && itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n        const span = this._getItemSpan(itemRoot);\n\n        if (span === undefined) {\n          if (isToggleModifierPressed) {\n            // set anchor only.\n            selection.setIndexSelected(index, selection.isIndexSelected(index), true);\n            if (this.props.enterModalOnTouch && this._isTouch && selection.setModal) {\n              selection.setModal(true);\n              this._setIsTouch(false);\n            }\n          } else {\n            if (this.props.isSelectedOnFocus) {\n              this._onItemSurfaceClick('focus', index);\n            }\n          }\n        }\n      }\n    }\n\n    this._handleNextFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    const { toggleWithoutModifierPressed } = this.props;\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    // No-op if selection is disabled\n    if (this._isSelectionDisabled(target)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        break;\n      } else if (itemRoot) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (\n          (target === itemRoot || this._shouldAutoSelect(target)) &&\n          !this._isShiftPressed &&\n          !this._isCtrlPressed &&\n          !this._isMetaPressed &&\n          !toggleWithoutModifierPressed\n        ) {\n          this._onInvokeMouseDown(ev, this._getItemIndex(itemRoot), this._getItemSpan(itemRoot));\n\n          break;\n        } else if (\n          this.props.disableAutoSelectOnInputElements &&\n          (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')\n        ) {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onTouchStartCapture = (ev: React.TouchEvent<HTMLElement>): void => {\n    this._setIsTouch(true);\n  };\n\n  private _onClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { enableTouchInvocationTarget = false } = this.props;\n\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        if (!isSelectionDisabled) {\n          this._onToggleAllClick(ev);\n        }\n        break;\n      } else if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n        const span = this._getItemSpan(itemRoot);\n\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          if (!isSelectionDisabled) {\n            if (this._isShiftPressed) {\n              this._onItemSurfaceClick('click', index, span);\n            } else {\n              this._onToggleClick(ev, index, span);\n            }\n          }\n          break;\n        } else if (\n          (this._isTouch &&\n            enableTouchInvocationTarget &&\n            this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME)) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          if (span === undefined) {\n            // Items should be invokable even if selection is disabled.\n            this._onInvokeClick(ev, index);\n          }\n          break;\n        } else if (target === itemRoot) {\n          if (!isSelectionDisabled) {\n            this._onItemSurfaceClick('click', index, span);\n          }\n          break;\n        } else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onContextMenu = (ev: React.MouseEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n\n    const { onItemContextMenu, selection } = this.props;\n    if (onItemContextMenu) {\n      const itemRoot = this._findItemRoot(target);\n\n      if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n\n        this._onInvokeMouseDown(ev, index);\n\n        const skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent);\n\n        // In order to keep back compat, if the value here is undefined, then we should still\n        // call preventDefault(). Only in the case where true is explicitly returned should\n        // the call be skipped.\n        if (!skipPreventDefault) {\n          ev.preventDefault();\n        }\n      }\n    }\n  };\n\n  private _isSelectionDisabled(target: HTMLElement): boolean {\n    if (this._getSelectionMode() === SelectionMode.none) {\n      return true;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {\n        return true;\n      }\n      target = getParent(target) as HTMLElement;\n    }\n\n    return false;\n  }\n\n  /**\n   * In multi selection, if you double click within an item's root (but not within the invoke element or\n   * input elements), we should execute the invoke handler.\n   */\n  private _onDoubleClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n\n    const { onItemInvoked } = this.props;\n    const itemRoot = this._findItemRoot(target);\n\n    if (itemRoot && onItemInvoked && !this._isInputElement(target)) {\n      const index = this._getItemIndex(itemRoot);\n\n      while (target !== this._root.current) {\n        if (\n          this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          break;\n        } else if (target === itemRoot) {\n          this._onInvokeClick(ev, index);\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onKeyDownCapture = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    this._handleNextFocus(true);\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    const { selection, selectionClearedOnEscapePress } = this.props;\n    // eslint-disable-next-line deprecation/deprecation\n    const isSelectAllKey = ev.which === KeyCodes.a && (this._isCtrlPressed || this._isMetaPressed);\n    // eslint-disable-next-line deprecation/deprecation\n    const isClearSelectionKey = ev.which === KeyCodes.escape;\n\n    // Ignore key downs from input elements.\n    if (this._isInputElement(target)) {\n      // A key was pressed while an item in this zone was focused.\n      return;\n    }\n\n    const selectionMode = this._getSelectionMode();\n\n    // If ctrl-a is pressed, select all (if all are not already selected.)\n    if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(true);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    // If escape is pressed and the component is configured to clear on escape press,\n    // clear selection (if any are selected.)\n    if (selectionClearedOnEscapePress && isClearSelectionKey && selection.getSelectedCount() > 0) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(false);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    const itemRoot = this._findItemRoot(target);\n\n    // If a key was pressed within an item, we should treat \"enters\" as invokes and \"space\" as toggle\n    if (itemRoot) {\n      const index = this._getItemIndex(itemRoot);\n      const span = this._getItemSpan(itemRoot);\n\n      while (target !== this._root.current) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          // For toggle elements, assuming they are rendered as buttons, they will generate a click event,\n          // so we can no-op for any keydowns in this case.\n          break;\n        } else if (this._shouldAutoSelect(target)) {\n          if (!isSelectionDisabled && span === undefined) {\n            // If the event went to an element which should trigger auto-select, select it and then let\n            // the default behavior kick in.\n            this._onInvokeMouseDown(ev, index, span);\n          }\n          break;\n        } else if (\n          // eslint-disable-next-line deprecation/deprecation\n          (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) &&\n          (target.tagName === 'BUTTON' ||\n            target.tagName === 'A' ||\n            target.tagName === 'INPUT' ||\n            target.tagName === 'SUMMARY')\n        ) {\n          return false;\n        } else if (target === itemRoot) {\n          // eslint-disable-next-line deprecation/deprecation\n          if (ev.which === KeyCodes.enter) {\n            if (span === undefined) {\n              // Items should be invokable even if selection is disabled.\n              this._onInvokeClick(ev, index);\n              ev.preventDefault();\n            }\n            return;\n            // eslint-disable-next-line deprecation/deprecation\n          } else if (ev.which === KeyCodes.space) {\n            if (!isSelectionDisabled) {\n              this._onToggleClick(ev, index, span);\n            }\n            ev.preventDefault();\n            return;\n          }\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n    }\n  };\n\n  private _onToggleAllClick(ev: React.MouseEvent<HTMLElement>): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleAllSelected();\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  }\n\n  private _onToggleClick(\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    index: number,\n    span?: number,\n  ): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    selection.setChangeEvents(false);\n\n    if (\n      this.props.enterModalOnTouch &&\n      this._isTouch &&\n      (span !== undefined ? !selection.isRangeSelected(index, span) : !selection.isIndexSelected(index)) &&\n      selection.setModal\n    ) {\n      selection.setModal(true);\n      this._setIsTouch(false);\n    }\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (span !== undefined) {\n        selection.toggleRangeSelected(index, span);\n      } else {\n        selection.toggleIndexSelected(index);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      if (span === undefined || span === 1) {\n        const isSelected = selection.isIndexSelected(index);\n        const isModal = selection.isModal && selection.isModal();\n        selection.setAllSelected(false);\n        selection.setIndexSelected(index, !isSelected, true);\n        if (isModal && selection.setModal) {\n          // Since the above call to setAllSelected(false) clears modal state,\n          // restore it. This occurs because the SelectionMode of the Selection\n          // may differ from the SelectionZone.\n          selection.setModal(true);\n        }\n      }\n    } else {\n      selection.setChangeEvents(true);\n      return;\n    }\n\n    selection.setChangeEvents(true);\n\n    ev.stopPropagation();\n\n    // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior\n    // for checkboxes if you use a checkbox for the toggle.\n  }\n\n  private _onInvokeClick(ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, index: number): void {\n    const { selection, onItemInvoked } = this.props;\n\n    if (onItemInvoked) {\n      onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _onItemSurfaceClick(type: 'focus' | 'click', index: number, span?: number): void {\n    const { selection, toggleWithoutModifierPressed } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (this._isShiftPressed && !this._isTabPressed) {\n        if (span !== undefined) {\n          selection.selectToRange?.(index, span, !isToggleModifierPressed);\n        } else {\n          selection.selectToIndex(index, !isToggleModifierPressed);\n        }\n      } else if (type === 'click' && (isToggleModifierPressed || toggleWithoutModifierPressed)) {\n        if (span !== undefined) {\n          selection.toggleRangeSelected(index, span);\n        } else {\n          selection.toggleIndexSelected(index);\n        }\n      } else {\n        this._clearAndSelectIndex(index, span);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      this._clearAndSelectIndex(index, span);\n    }\n  }\n\n  private _onInvokeMouseDown(\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    index: number,\n    span?: number,\n  ): void {\n    const { selection } = this.props;\n\n    if (span !== undefined) {\n      if (selection.isRangeSelected(index, span)) {\n        return;\n      }\n    } else {\n      // Only do work if item is not selected.\n      if (selection.isIndexSelected(index)) {\n        return;\n      }\n    }\n\n    this._clearAndSelectIndex(index, span);\n  }\n\n  /**\n   * To avoid high startup cost of traversing the DOM on component mount,\n   * defer finding the scrollable parent until a click interaction.\n   *\n   * The styles will probably already calculated since we're running in a click handler,\n   * so this is less likely to cause layout thrashing then doing it in mount.\n   */\n  private _findScrollParentAndTryClearOnEmptyClick(ev: MouseEvent) {\n    const scrollParent = findScrollableParent(this._root.current) as HTMLElement;\n    // unbind this handler and replace binding with a binding on the actual scrollable parent\n    this._events.off(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(scrollParent, 'click', this._tryClearOnEmptyClick);\n\n    // If we clicked inside the scrollable parent, call through to the handler on this click.\n    if ((scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target)) || scrollParent === ev.target) {\n      this._tryClearOnEmptyClick(ev);\n    }\n  }\n\n  private _tryClearOnEmptyClick(ev: MouseEvent): void {\n    if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target as HTMLElement)) {\n      this.props.selection.setAllSelected(false);\n    }\n  }\n\n  private _clearAndSelectIndex(index: number, span?: number): void {\n    const { selection, selectionClearedOnSurfaceClick = true } = this.props;\n    const isAlreadySingleSelected =\n      (span === undefined || span === 1) && selection.getSelectedCount() === 1 && selection.isIndexSelected(index);\n\n    if (!isAlreadySingleSelected && selectionClearedOnSurfaceClick) {\n      const isModal = selection.isModal && selection.isModal();\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n      if (span !== undefined) {\n        selection.setRangeSelected?.(index, span, true, true);\n      } else {\n        selection.setIndexSelected(index, true, true);\n      }\n      if (isModal || (this.props.enterModalOnTouch && this._isTouch)) {\n        if (selection.setModal) {\n          selection.setModal(true);\n        }\n        if (this._isTouch) {\n          this._setIsTouch(false);\n        }\n      }\n      selection.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * We need to track the modifier key states so that when focus events occur, which do not contain\n   * modifier states in the Event object, we know how to behave.\n   */\n  private _updateModifiers(ev: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void {\n    this._isShiftPressed = ev.shiftKey;\n    this._isCtrlPressed = ev.ctrlKey;\n    this._isMetaPressed = ev.metaKey;\n\n    // eslint-disable-next-line deprecation/deprecation\n    const keyCode = (ev as React.KeyboardEvent<HTMLElement>).keyCode;\n    this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;\n  }\n\n  private _findItemRoot(target: HTMLElement): HTMLElement | undefined {\n    const { selection } = this.props;\n\n    while (target !== this._root.current) {\n      const indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);\n      const index = Number(indexValue);\n\n      if (indexValue !== null && index >= 0 && index < selection.getItems().length) {\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n\n    if (target === this._root.current) {\n      return undefined;\n    }\n\n    return target;\n  }\n\n  private _getItemIndex(itemRoot: HTMLElement): number {\n    const indexValue = parseInt(itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME) ?? '', 10);\n\n    return isNaN(indexValue) ? -1 : indexValue;\n  }\n\n  private _getItemSpan(itemRoot: HTMLElement): number | undefined {\n    const spanValue = parseInt(itemRoot.getAttribute(SELECTION_SPAN_ATTRIBUTE_NAME) ?? '', 10);\n\n    return isNaN(spanValue) ? undefined : spanValue;\n  }\n\n  private _shouldAutoSelect(element: HTMLElement): boolean {\n    return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);\n  }\n\n  private _hasAttribute(element: HTMLElement, attributeName: string): boolean {\n    let isToggle = false;\n\n    while (!isToggle && element !== this._root.current) {\n      const value = element.getAttribute(attributeName);\n      if (value === 'false') {\n        isToggle = false;\n        break;\n      }\n      isToggle = value === 'true';\n      element = getParent(element) as HTMLElement;\n    }\n\n    return isToggle;\n  }\n\n  private _isInputElement(element: HTMLElement): boolean {\n    return (\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      element.getAttribute('contenteditable') === 'true' ||\n      element.getAttribute('contenteditable') === ''\n    );\n  }\n\n  private _isNonHandledClick(element: HTMLElement): boolean {\n    const doc = getDocument();\n\n    if (doc && element) {\n      while (element && element !== doc.documentElement) {\n        if (isElementTabbable(element) || element.hasAttribute('data-selection-index')) {\n          return false;\n        }\n\n        element = getParent(element) as HTMLElement;\n      }\n    }\n\n    return true;\n  }\n\n  private _handleNextFocus(handleFocus: boolean): void {\n    if (this._shouldHandleFocusTimeoutId) {\n      this._async.clearTimeout(this._shouldHandleFocusTimeoutId);\n      this._shouldHandleFocusTimeoutId = undefined;\n    }\n\n    this._shouldHandleFocus = handleFocus;\n\n    if (handleFocus) {\n      this._async.setTimeout(() => {\n        this._shouldHandleFocus = false;\n      }, 100);\n    }\n  }\n\n  private _setIsTouch(isTouch: boolean): void {\n    if (this._isTouchTimeoutId) {\n      this._async.clearTimeout(this._isTouchTimeoutId);\n      this._isTouchTimeoutId = undefined;\n    }\n\n    this._isTouch = true;\n\n    if (isTouch) {\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 300);\n    }\n  }\n\n  private _getSelectionMode(): SelectionMode {\n    const { selection } = this.props;\n\n    const { selectionMode = selection ? selection.mode : SelectionMode.none } = this.props;\n\n    return selectionMode;\n  }\n}\n"]}