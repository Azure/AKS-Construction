{"version":3,"file":"scheme.js","sourceRoot":"../src/","sources":["styles/scheme.ts"],"names":[],"mappings":";;;;IAIA;;;;;;;;;;;;;;OAcG;IACH,SAAgB,gBAAgB,CAC9B,OAA2B,EAC3B,MAAqB,EACrB,KAAc;QAEd,IAAI,UAAU,GAAuB,OAAO,CAAC;QAC7C,IAAI,WAAW,CAAC;QAEhB,+EAA+E;QAC/E,IAAI,YAAY,GAAG,KAAK,IAAI,0BAAc,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC;QAE3G,IAAI,KAAK,EAAE;YACT,WAAW,GAAG,EAAE,KAAK,OAAA,EAAE,CAAC;SACzB;QAED,IAAM,WAAW,GACf,MAAM,IAAI,YAAY,IAAI,YAAY,CAAC,OAAO,IAAI,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAEjF,sGAAsG;QACtG,+BAA+B;QAC/B,IAAI,YAAY,IAAI,WAAW,IAAI,YAAY,KAAK,WAAW,EAAE;YAC/D,WAAW,GAAG,EAAE,KAAK,EAAE,WAAW,EAAE,CAAC;YACrC,WAAW,CAAC,KAAK,CAAC,OAAO,GAAG,YAAY,CAAC,OAAO,CAAC;SAClD;QAED,IAAI,WAAW,EAAE;YACf,UAAU,GAAG;gBACX,cAAc,EAAE;oBACd,QAAQ,EAAE,yBAAa,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,CAAC;oBACrE,cAAc,EAAE,OAAO,CAAC,cAAc,CAAC,cAAc;iBACtD;aACF,CAAC;SACH;QAED,OAAO,UAAU,CAAC;IACpB,CAAC;IAnCD,4CAmCC","sourcesContent":["import { Customizations, mergeSettings } from '@fluentui/utilities';\nimport type { ICustomizerContext } from '@fluentui/utilities';\nimport type { ISchemeNames, ITheme } from '../interfaces/index';\n\n/**\n * @internal\n * This function is still in experimental phase in support of Foundation experimental development.\n * Its API signature and existence are subject to change.\n *\n * Modify context to activate the specified scheme or theme. For schemes, look in context (if available) and fall back\n * to global Customizations. If both scheme and theme are specified, scheme will be looked up in theme. In this case,\n * scheme must be present in theme arg, otherwise new context will default to theme arg (there is no fallback to\n * settings to look up scheme.)\n *\n * @param context - Context in which to get schemed customizations.\n * @param scheme - Scheme to get customizations for from theme arg (if supplied) OR from context and global settings.\n * @param theme - Theme to merge into context.\n * @returns modified schemed context if scheme is valid and not already applied, unmodified context otherwise.\n */\nexport function getThemedContext(\n  context: ICustomizerContext,\n  scheme?: ISchemeNames,\n  theme?: ITheme,\n): ICustomizerContext {\n  let newContext: ICustomizerContext = context;\n  let newSettings;\n\n  // Only fall back to context and customizations when theme arg is not provided.\n  let schemeSource = theme || Customizations.getSettings(['theme'], undefined, context.customizations).theme;\n\n  if (theme) {\n    newSettings = { theme };\n  }\n\n  const schemeTheme: ITheme | undefined =\n    scheme && schemeSource && schemeSource.schemes && schemeSource.schemes[scheme];\n\n  // These first two checks are logically redundant but TS doesn't infer schemeSource.schemes is defined\n  // when schemeTheme is defined.\n  if (schemeSource && schemeTheme && schemeSource !== schemeTheme) {\n    newSettings = { theme: schemeTheme };\n    newSettings.theme.schemes = schemeSource.schemes;\n  }\n\n  if (newSettings) {\n    newContext = {\n      customizations: {\n        settings: mergeSettings(context.customizations.settings, newSettings),\n        scopedSettings: context.customizations.scopedSettings,\n      },\n    };\n  }\n\n  return newContext;\n}\n"]}