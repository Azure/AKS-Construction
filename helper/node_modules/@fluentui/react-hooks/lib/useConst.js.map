{"version":3,"file":"useConst.js","sourceRoot":"../src/","sources":["useConst.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAE/B;;;;;;;;;;GAUG;AACH,MAAM,UAAU,QAAQ,CAAI,YAA2B;IACrD,+FAA+F;IAC/F,8FAA8F;IAC9F,0DAA0D;IAC1D,IAAM,GAAG,GAAG,KAAK,CAAC,MAAM,EAAgB,CAAC;IACzC,IAAI,GAAG,CAAC,OAAO,KAAK,SAAS,EAAE;QAC7B,wFAAwF;QACxF,uBAAuB;QACvB,GAAG,CAAC,OAAO,GAAG;YACZ,KAAK,EAAE,OAAO,YAAY,KAAK,UAAU,CAAC,CAAC,CAAE,YAAyB,EAAE,CAAC,CAAC,CAAC,YAAY;SACxF,CAAC;KACH;IACD,OAAO,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC;AAC3B,CAAC","sourcesContent":["import * as React from 'react';\n\n/**\n * Hook to initialize and return a constant value. Unlike `React.useMemo`, this is guaranteed to\n * always return the same value (and if the initializer is a function, only call it once).\n * This is similar to setting a private member in a class constructor.\n *\n * If the value should ever change based on dependencies, use `React.useMemo` instead.\n *\n * @param initialValue - Initial value, or function to get the initial value. Similar to `useState`,\n * only the value/function passed in the first time this is called is respected.\n * @returns The value. The identity of this value will always be the same.\n */\nexport function useConst<T>(initialValue: T | (() => T)): T {\n  // Use useRef to store the value because it's the least expensive built-in hook that works here\n  // (we could also use `const [value] = React.useState(initialValue)` but that's more expensive\n  // internally due to reducer handling which we don't need)\n  const ref = React.useRef<{ value: T }>();\n  if (ref.current === undefined) {\n    // Box the value in an object so we can tell if it's initialized even if the initializer\n    // returns/is undefined\n    ref.current = {\n      value: typeof initialValue === 'function' ? (initialValue as Function)() : initialValue,\n    };\n  }\n  return ref.current.value;\n}\n"]}