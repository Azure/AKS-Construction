{"version":3,"file":"useControllableValue.js","sourceRoot":"../src/","sources":["useControllableValue.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAkCtC,MAAM,UAAU,oBAAoB,CAKlC,eAAmC,EACnC,wBAA4C,EAC5C,QAAmD;IAE7C,IAAA,KAAoB,KAAK,CAAC,QAAQ,CAAqB,wBAAwB,CAAC,EAA/E,KAAK,QAAA,EAAE,QAAQ,QAAgE,CAAC;IACvF,IAAM,YAAY,GAAG,QAAQ,CAAU,eAAe,KAAK,SAAS,CAAC,CAAC;IACtE,IAAM,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,KAAK,CAAC;IAE5D,8EAA8E;IAC9E,oEAAoE;IACpE,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;IAC5C,IAAM,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC3C,KAAK,CAAC,SAAS,CAAC;QACd,QAAQ,CAAC,OAAO,GAAG,YAAY,CAAC;QAChC,WAAW,CAAC,OAAO,GAAG,QAAQ,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,2FAA2F;IAC3F,4FAA4F;IAC5F,IAAM,sBAAsB,GAAG,QAAQ,CAAC,cAAM,OAAA,UAAC,MAAgD,EAAE,EAAW;QAC1G,2FAA2F;QAC3F,yCAAyC;QACzC,IAAM,QAAQ,GAAG,OAAO,MAAM,KAAK,UAAU,CAAC,CAAC,CAAE,MAAmB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAEhG,IAAI,WAAW,CAAC,OAAO,EAAE;YACvB,WAAW,CAAC,OAAO,CAAC,EAAG,EAAE,QAAQ,CAAC,CAAC;SACpC;QAED,IAAI,CAAC,YAAY,EAAE;YACjB,QAAQ,CAAC,QAAQ,CAAC,CAAC;SACpB;IACH,CAAC,EAZ6C,CAY7C,CAAC,CAAC;IAEH,OAAO,CAAC,YAAY,EAAE,sBAAsB,CAAU,CAAC;AACzD,CAAC","sourcesContent":["import * as React from 'react';\nimport { useConst } from './useConst';\n\nexport type ChangeCallback<\n  TElement extends HTMLElement,\n  TValue,\n  TEvent extends React.SyntheticEvent<TElement> | undefined\n> = (ev: TEvent, newValue: TValue | undefined) => void;\n\n/**\n * Hook to manage a value that could be either controlled or uncontrolled, such as a checked state or\n * text box string.\n * @param controlledValue - The controlled value passed in the props. This value will always be used if provided,\n * and the internal state will be updated to reflect it.\n * @param defaultUncontrolledValue - Initial value for the internal state in the uncontrolled case.\n * @returns An array of the current value and an updater callback. Like `React.useState`, the updater\n * callback always has the same identity, and it can take either a new value, or a function which\n * is passed the previous value and returns the new value.\n * @see https://reactjs.org/docs/uncontrolled-components.html\n */\nexport function useControllableValue<TValue, TElement extends HTMLElement>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n): Readonly<[TValue | undefined, (update: React.SetStateAction<TValue | undefined>) => void]>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TEvent extends React.SyntheticEvent<TElement> | undefined\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange: ChangeCallback<TElement, TValue, TEvent> | undefined,\n): Readonly<\n  [TValue | undefined, (update: React.SetStateAction<TValue | undefined>, ev?: React.FormEvent<TElement>) => void]\n>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TEvent extends React.SyntheticEvent<TElement> | undefined\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange?: ChangeCallback<TElement, TValue, TEvent>,\n) {\n  const [value, setValue] = React.useState<TValue | undefined>(defaultUncontrolledValue);\n  const isControlled = useConst<boolean>(controlledValue !== undefined);\n  const currentValue = isControlled ? controlledValue : value;\n\n  // Duplicate the current value and onChange in refs so they're accessible from\n  // setValueOrCallOnChange without creating a new callback every time\n  const valueRef = React.useRef(currentValue);\n  const onChangeRef = React.useRef(onChange);\n  React.useEffect(() => {\n    valueRef.current = currentValue;\n    onChangeRef.current = onChange;\n  });\n\n  // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n  const setValueOrCallOnChange = useConst(() => (update: React.SetStateAction<TValue | undefined>, ev?: TEvent) => {\n    // Assuming here that TValue is not a function, because a controllable value will typically\n    // be something a user can enter as input\n    const newValue = typeof update === 'function' ? (update as Function)(valueRef.current) : update;\n\n    if (onChangeRef.current) {\n      onChangeRef.current(ev!, newValue);\n    }\n\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  });\n\n  return [currentValue, setValueOrCallOnChange] as const;\n}\n"]}