{"version":3,"file":"testUtilities.js","sourceRoot":"../src/","sources":["testUtilities.tsx"],"names":[],"mappings":";;;AAAA,6BAA+B;AAC/B,iCAA+B;AAE/B;;;;;;;GAOG;AACH,8DAA8D;AAC9D,SAAgB,2BAA2B,CACzC,eAAuB,EACvB,OAAsB,EACtB,YAA4B;IAE5B,EAAE,CAAC,eAAe,IAAI,qCAAqC,EAAE;QAC3D,IAAI,YAAiC,CAAC;QACtC,IAAI,SAAS,GAAG,CAAC,CAAC;QAElB,IAAM,aAAa,GAA4B;YAC7C,SAAS,EAAE,CAAC;YACZ,sDAAsD;YACtD,YAAY,GAAG,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,OAAO,CAAC,EAAE,CAAC;YACzE,OAAO,gCAAO,CAAC;QACjB,CAAC,CAAC;QAEF,IAAM,OAAO,GAAG,cAAK,CAAC,oBAAC,aAAa,OAAG,CAAC,CAAC;QACzC,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC1B,IAAM,WAAW,GAAG,YAAY,CAAC;QACjC,MAAM,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAC;QAClC,YAAY,GAAG,SAAS,CAAC;QAEzB,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACrB,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC1B,MAAM,CAAC,YAAY,CAAC,CAAC,WAAW,EAAE,CAAC;QACnC,MAAM,CAAC,YAAY,CAAC,CAAC,YAAY,CAAC,WAAY,CAAC,MAAM,CAAC,CAAC;QAEvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC7C,IAAI;gBACF,MAAM,CAAC,YAAa,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAY,CAAC,CAAC,CAAC,CAAC,CAAC;aAChD;YAAC,OAAO,GAAG,EAAE;gBACZ,wCAAwC;gBACxC,IAAM,SAAS,GAAG,YAAa,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC9C,MAAM,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,gCAA8B,CAAC,oDAA+C,SAAW,CAAC,CAAC;aAC5G;SACF;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AArCD,kEAqCC","sourcesContent":["import * as React from 'react';\nimport { mount } from 'enzyme';\n\n/**\n * Validate that value(s) returned by a hook do not change in identity.\n * @param testDescription - Custom test description\n * @param useHook - Function to invoke the hook and return an array of return values which\n * should not change\n * @param useHookAgain - If you want to verify that the return value doesn't change when hook\n * parameters change, you can pass this second callback which calls the hook differently.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function validateHookValueNotChanged<TValues extends NonNullable<any>[]>(\n  testDescription: string,\n  useHook: () => TValues,\n  useHookAgain?: () => TValues,\n) {\n  it(testDescription || 'returns the same value(s) each time', () => {\n    let latestValues: TValues | undefined;\n    let callCount = 0;\n\n    const TestComponent: React.FunctionComponent = () => {\n      callCount++;\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      latestValues = callCount === 1 ? useHook() : (useHookAgain || useHook)();\n      return <div />;\n    };\n\n    const wrapper = mount(<TestComponent />);\n    expect(callCount).toBe(1);\n    const firstValues = latestValues;\n    expect(firstValues).toBeDefined();\n    latestValues = undefined;\n\n    wrapper.setProps({});\n    expect(callCount).toBe(2);\n    expect(latestValues).toBeDefined();\n    expect(latestValues).toHaveLength(firstValues!.length);\n\n    for (let i = 0; i < latestValues!.length; i++) {\n      try {\n        expect(latestValues![i]).toBe(firstValues![i]);\n      } catch (err) {\n        // Make a more informative error message\n        const valueText = latestValues![i].toString();\n        expect('').toBe(`Identity of value at index ${i} has changed. This might help identify it:\\n${valueText}`);\n      }\n    }\n  });\n}\n"]}